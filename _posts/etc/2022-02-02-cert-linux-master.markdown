---
title:  "[자격증] 리눅스 마스터 1급 준비하기"
created:   2022-02-02 18:08:00 +0900
updated:   2022-02-02 18:08:00 +0900
author: namu
categories: etc
permalink: "/etc/:year/:month/:day/:title"
image: https://media.vlpt.us/images/may_soouu/post/11a98732-df94-4e66-94d4-033634093313/linux.png
image-view: true
image-author: 개벨로그
image-source: https://velog.io/@may_soouu/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0
---

<br>
## 시험 안내

**리눅스 마스터**는 리눅스 기반의 Desktop 활용 및 Server 운영 능력, 리눅스 시스템의 설계 개발 및 관리 능력,
리눅스 기반의 네트워크 및 서버 구축/운영 능력을 검정하는 자격시험입니다.

그 중 1급 시험의 목적은 다음과 같습니다.

- **1급**
    - 지식: 고도의 리눅스 활용능력에 대한 이해도 평가
    - 기능: 리눅스를 안전하고 효율적으로 운영하기 위한 실무 기능 평가

이 시험은 **1차시**에서
**(1) 리눅스 실무의 이해(20%)**, **(2) 리눅스 시스템 관리(40%)**, **(3) 네트워크 및 서비스의 활용(40%)** 비중의 사지선다 필기 100문항,
**2차시**에서 **단답 및 서술식 필기 10문항**, **실기(60%) 5~7문항**으로 구성됩니다.

이번 글은 해당 시험을 너무 깊게 파기보다는 전체적인 이론의 맥락을 짚어보거나 몰랐던 부분을 정리하는 수준에서 작성하고자 합니다.
자격증 시험의 특성상, 이론보다는 기출문제를 통해 공부하는 것이 더 효율적이기 때문입니다.

<br><br>

---

### 목차

1. [리눅스 실무의 이해](#1-리눅스-실무의-이해)
2. [리눅스 시스템 관리](#2-리눅스-시스템-관리)
3. [네트워크 및 서비스의 활용](#3-네트워크-및-서비스의-활용)
4. [기출 및 부록 정리](#4-기출-및-부록-정리)

### 참조

- <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62844304" target="_blank">
리눅스 마스터 1급 정복하기 (2018, 북스홀릭)</a>

---

<br><br>
## 1. 리눅스 실무의 이해

### 1-1. 리눅스의 개요

### 운영체제의 개요

**운영체제**는 **컴퓨터 하드웨어와 컴퓨터 사용자 간의 매개체 역할을 하는 시스템 소프트웨어**입니다.

- 좁은 의미: 하드웨어와 응용 프로그램 간의 다리 역할하는 커널(Kernel)
- 넓은 의미: 커널 포함 미들웨어, 응용 프로그램 실행 환경과 사용자 인터페이스 프레임워크 모두 포괄

- **운영체제의 주목적**: 컴퓨터 시스템을 편리하게 이용하고, CPU, 주기억장치, 입출력장치 등의 컴퓨터 하드웨어를 효율적으로 관리하는 데 있음

초기 운영체제는 사용자 편의성을 고려하지 않았으나(효율적 자원 관리에 치중), 대중화가 진행되며 편리함과 친근함의 형태로 변화되었습니다.
이러한 것이 GUI 기반의 윈도우 OS 입니다.

GUI 기반 윈도우 OS 에서는 명령어 기반이 아닌 아이콘 이미지 클릭 방식을 지원합니다.

하지만 현재는 **유휴 자원의 효율적 활용**을 위해 가상화 기술을 OS 에서 기본적으로 내장하거나 커널 단에서 지원하고 있습니다.

또한 스마트폰이나 태블릿 전용 모바일 운영체제, 웹 브라우저 전용 OS 도 탄생되었습니다.

- **운영체제의 주요 역할**
    - 컴퓨터의 하드웨어 제어
    - 작업의 순서를 정하며, 입출력 연산을 제어
    - 프로그램의 실행 제어, 데이터와 파일의 저장을 관리
    - 사용자들 간의 하드웨어 자원 공유 제공
    - 시스템 자원을 스케줄링하여 효율적으로 활용
    - 입출력을 쉽게 하는 기능 제공
    - 응용 프로그램의 작성과 실행을 편리하게 함
    - 오류의 발생을 막고 복구를 지원
    - 데이터의 조직화, 네트워크 통신 처리 기능 수행
    - 편리한 사용자 인터페이스 제공

- **최근 운영체제의 주요 특징**
    - 다중 사용자 시스템(Multi-User System)
    - 다중 작업 시스템(Multi-Tasking System)
    - 강력한 네트워크 지원
    - 편리한 사용자 인터페이스 지원
    - 계층적 파일 시스템 운영
    - 가상 메모리 지원
    - 고성능의 프로세서에 최적화
    - 개방형 운영체제화
    - 뛰어난 이식성 지원
    - 가상화 기술 지원

- **운영체제의 역사**
    - 40년대: 초기전자식 디지털 컴퓨터
        - 운영체제가 없음
        - 단순한 기계적인 스위치에 의존
    - 50년대: 단순순차처리
        - 한 번에 오직 하나의 작업만 수행
        - 단일 흐름 일괄 처리
    - 60년대: 다중프로그래밍
        - 멀티프로그래밍, 멀티프로세싱 개념 대두
        - 시분할 처리 개념 대두
        - 데이터 통신 지원
    - 70년대: 다중 모드 시분할
        - 일괄처리, 시분할 및 실시간처리의 보편화
        - 범용 시스템 개념 도입
    - 80년대: 분산네트워크
        - 각종 응용 프로그램 개발
        - 데이터베이스 활용 확대
        - 네트워크 기반으로 한 서버/클라이언트 모델 확대
        - 운영체제 기능들이 하드웨어에 포함된 펌웨어(Firmware) 개념 대두
    - 90년대: 병렬계산과 분산계산
        - 중앙집중식이 아닌 분산으로 발전
        - PC용과 서버용 운영체제의 보편화
    - 2000년대 ~ 현재: 모바일 및 임베디드
        - 네트워크 기반의 분산 및 병렬 운영체제의 보편화
        - 스마트폰, 태블릿 등의 모바일 장치와 가전제품을 위한 모바일 및 임베디드 운영체제의 보편화
        - 다양한 기능, 확장성과 호환성 극대화
        - 다양한 통신망의 확대와 개방형 시스템 발달
        
다음은 리눅스의 특징입니다.

- **리눅스의 특징**
    - 1) 다중 사용자 및 다중 처리 시스템(Multi-User and Multi-Tasking)
    - 2) 완전히 공개된 시스템
        - 커널 및 대부분의 응용 프로그램 소스가 공개됨
    - 3) 뛰어난 네트워크 환경
        - 이더넷(Ethernet), SLIP, PPP, ATM 등의 환경
        - TCP/IP, IPX, AppleTalk 등 프로토콜 지원
    - 4) 다양한 파일 시스템 지원
        - 프로그램과 자료를 저장하기 위해 리눅스 고유 파일 시스템인 ext2, ext3, ext4 등 사용
        - 고유 파일 시스템뿐 아니라 다른 파일 시스템도 지원 > FAT, FAT32, NTFS, ISO 9660, HPFS, SCO 제닉스 등
        - 시스템 다운 시 즉시 복구할 수 있는 저널링 파일 시스템 지원 > ReiserFS, XFS, JFS 등
        - 네트워크 파일 시스템 지원 > SMB, CIFS, NFS, NCPFS 등
    - 5) 뛰어난 이식성
        - 약간의 어셈블리과 대부분의 C언어
    - 6) 유연성과 확장성
        - 유닉스 표준인 POSIX를 준수
        - 공개용 유닉스 프로그램들은 원시코드 접근이 용이하고 다른 시스템에 이식 및 자유로운 배포 가능
    - 7) 뛰어난 안정성과 보안성
        - 공개된 리눅스 커널은 폐쇄된 Windows 에 비해 보안상의 취약점 노출 가능성은 높지만
        - 수많은 전문가들에 의해 빠르게 오류 수정 및 보안 패치가 발표되고 있음
    - 8) 우수한 가격대 성능비
        - PC급 서버에서도 엔터프라이즈급의 성능 발휘
    - 9) 다양한 응용 프로그램의 제공
        - 커널을 비롯, 셸과 기본 명령어, X Window 시스템(Xorg, KDE, GNOME 등의 GUI), vi 등의 편집기(emacs), 웹, 메일, FTP 등
        - 개발 도구 지원(C, C++, Java, Python), 보안 도구(nmap, tcpdump), 게임 등
    - 10) 다양한 배포판의 존재
        - 서버, 개발용, PC용 등 다양한 목적의 배포판
        - RedHat, Debian, Ubuntu, SUSE, 한컴리눅스, SULinux 등
        - 상용 및 무료 배포판

- **리눅스의 단점**
    - 1) 기술지원의 부족
        - 대부분 비상업적 제품들이라 전세계 개발자들이 일일히 기술지원이 불가
    - 2) 특정 하드웨어에 대한 지원 부족
    - 3) 사용자의 숙련된 기술 요구됨
        - 아직 중요한 설정은 명령어를 입력하거나 관련 환경 설정 파일을 편집기를 사용해 수정해야 함

- **리눅스의 기술적인 특징**
    - 1) 계층적인 파일 구조
        - /(root) 기준으로 하위로 가지를 뻗어나가는 트리 구조(usr, var, bin 등)
    - 2) 장치의 파일화
        - 하드디스크, 키보드, 프린터, 화면출력장치 등의 디바이스까지도 모두 파일화하여 사용
        - 해당하는 장치 (실행 혹은 설정) 파일에 명령을 내리는 방식
    - 3) **가상메모리 사용**
        - Virtual Memory 란 하드디스크의 일부를 메모리처럼 사용하는 것을 말함
        - 이곳에는 임시 데이터가 저장되고, RAM 은 작업공간으로 사용
        - RAM 부족 시 큰 프로그램은 실행할 수 없는데, 이를 극복하는 데 가상메모리가 사용됨
        - 이러한 영역을 **스왑(SWAP)** 이라고 함
    - 4) 동적 라이브러리 지원
        - 프로그램 특정 기능을 하는 루틴들을 모아 놓은 것을 라이브러리라 함
        - 개발 시 라이브러리 중 필요한 루틴들을 받아서 링크(Link) 시킴
        - 컴파일 시 프로그램에 들어가는 정적 라이브러리에 비해, 동적 공유 라이브러리는 실행 파일에 들어가지 않고 프로그램 실행 시
        가져다 사용하므로 메모리 효율성이 아주 높음
    - 5) 가상 콘솔
        - Virtual Console 은 하나의 모니터를 장착한 시스템에 여러 개의 가상 화면을 제공
        - 기본 6개의 가상 콘솔 제공 > CTRL + ALT + F1~F6
    - 6) 파이프(Pipe, '|')
        - 프로세스의 통신을 위해 도입
        - 어떤 프로세스의 표준 출력이 다른 프로세스의 표준 입력으로 쓰이게 함
    - 7) 리디렉션(Redirection)
        - 어떤 프로세스의 입/출력을 표준 입출력이 아닌 다른 입출력으로 변경할 때 사용됨
        - 출력 결과를 파일로 저장하거나 파일의 내용을 프로세스의 입력으로 사용

> **스와핑(Swapping)**
> - 메모리에 프로그램들이 많이 올라와 공간이 꽉 찼다고 하더라도 가상메모리를 설정하면 추가로 새로운 프로그램을 실행시킬 수 있게 됩니다.
> 이것은 메모리에 올라와 있지만 사용하지 않고 있는 프로그램을 하드디스크에 설정된 가상메모리 공간으로 보내고 그 빈 공간에 새로운 프로그램을
> 로딩하기 때문입니다. 또한 가상메모리에 있는 내용을 사용하려면 다시 메모리로 올리고, 그 대신에 메모리에 있던 다른 내용이 하드디스크에 저장됩니다.
> 이처럼 메모리와 하드디스크 사이의 데이터 교환을 스와핑이라고 합니다.
>
> **스왑의 확인**
> - 설치 후 스왑 용량의 확인은 메모리 확인 명령어린 free 를 사용합니다. 기본 블록 단위로 출력되므로 -m 옵션을 사용하면 MB 단위로 확인합니다.
> ```text
> ~$ free -m
>         total   used    free    shared  buffers cached
> Mem:    1006    715     291     0       6       326
> Swap:   2047    0       2047
> ```

다음으로 **운영체제의 종류**에 대해 살펴봅시다.

현재 운영체제는 사용 환경에 따라 크게 **서버, 데스크톱, 모바일 및 임베디드, 기타 분야**로 분류할 수 있습니다.

특히 **모바일 운영체제**인 안드로이드나 iOS는 휴대폰, PDA, 스마트폰, 태블릿 뿐만아니라 스마트 TV, 가전제품,
자동차에 내장되는 IVI(In-Vehicle Infotainment)까지 영역을 확대하고 있어 임베디드 운영체제 영역과의 경계가 모호해지고 있습니다.

**기타 분야**에서 웹 기반 운영체제(Web-based Operation System, 이하 Web OS)로써 구글의 크롬 OS가 등장했습니다.

주요 서버 및 데스크톱 운영체제는 다음과 같습니다.

**1) 유닉스(UNIX)**

유닉스의 특징으로는 **다중 사용자(Multi-User) 및 다중 작업(Multi-Tasking)** 지원, 강력한 네트워크 지원, 뛰어난 이식성 및 확장성,
계층적 파일 구조, 가상 메모리 및 공유 라이브러리 지원 등이 있습니다.

- 1969년 미국 AT&T 사의 벨(Bell) 연구소의 연구원 켄 톰슨(Ken Tompson) 및 데니스 리치(Dennis Ritchie)에 의해 만들어짐
- 이후 AT&T는 무료로 여러 연구소 및 대학교에 OS와 소스를 보급하여 여러 버전의 유닉스 등장
- 대표적으로 **System V 계열**과 **BSD 계열**
    - System V 계열: (주로 상업적) IBM, HP, Sun Microsystem, SGI
    - BSD 계열: (주로 오픈소스) NetBSD, FreeBSD, OpenBSD, SunOS, NextStep, Mac OS X, GNU/Linux

**2) 윈도(Windows)**

- 1975년 빌 게이츠(Bill Gates)와 폴 앨런(Paul Allen)이 설립한 마이크로소프트(Microsoft)
- 1982년 MS-DOS 는 IBM PC 호환기종용으로 출시됨
- 1994년 MS-DOS 6.2 버전까지 출시
- 1995년 본격적인 GUI 기반 운영체제인 Windows 95, 이후 Windows 98, Windows ME
- Windows XP 부터는 MS-DOS 가 사라짐

**3) Mac OS X**

...

- Mac OS X 은 Mac OS 의 열 번째 버전이라는 의미였지만, OS X 가 하나의 상품명으로 자리잡음
- BSD 유닉스 기반으로 만든 '넥스트스텝' 을 확장하여 만든 것으로, 결국 유닉스 기반 운영체제라고 볼 수 있음

**4) 모바일 운영체제**

모바일 운영체제는 기본적으로 데스크톱용 윈도우, 맥, 리눅스와 같은 운영체제와 비슷하나 모바일 장치 및 환경적 특성에 적합하도록 설계되었습니다.

- 배터리 사용 최적화
- PC에 비해 상대적으로 낮은 사양
- 무선 기반 광대역 및 지역 연결 특화
- 다양한 멀티미디어 지원
- 커널, 하드웨어 드라이버, 미들웨어, 응용 프로그램 실행 환경, 사용자 인터페이스 프레임워크 등 제공

모바일 운영체제는 TV나 자동차 영역까지 확대되었습니다.

**5) 리눅스 기반 모바일 운영체제**

리눅스는 BSD 계열의 유닉스 수정본입니다.

- **구글의 안드로이드(Android)**
    - 리눅스 커널 위에서 동작하는 대표적인 운영체제
    - 다양한 C/C++ 라이브러리 포함
    - 자바 언어로 작성된 응용 프로그램 구동 > 달빅(Dalvik) 가상 머신으로 프로그램을 별도의 프로세스로 실행
    - 2005년 구글이 안드로이드사를 인수하면서 대세가 됨
    - 50여만 개의 다양한 애플리케이션을 제공하는 안드로이드 생태계
    - iOS 에 비해 개발 진입장벽이 낮음
    - [단점] 오픈소스로 인한 보안상의 취약점
    - [단점] 다수의 하드웨어로 통일성이 떨어짐, 안정성 확보 어려움
- 바다(Bada) OS, 마에모(Maemo), 모블린(Moblin), 미고(MeeGo), 리모(LiMo), 타이젠(Tizen)

**6) 스마트 TV**

스마트 TV 란 운영체제를 탑재하고 TV 본연의 기능인 실시간 방송 시청뿐만 아니라 인터넷 접속 기능을 기반으로 웹 검색, VOD, 게임, SNS, 앱스토어
등의 기능이 가능한 TV 를 말합니다.

스마트 TV 는 기본적으로 모바일 기기와 동일한 운영체제를 탑재합니다.

애플은 iOS, 구글은 안드로이드, 삼성전자는 바다OS 혹은 타이젠, LG 전자는 자체 넷캐스트 OS(또는 Web OS)

**7) IVI(In-Vehicle Infotainment)**

IVI 는 ICE(In-Car Entertainment) 라고도 하며, 자동차 내에서 다양한 편의 기능과 오락시설을 제공하는 것이 목적입니다.

- MS 의 Windows Embedded Automotive, QNX, GENIVI, 안드로이드, MeeGo/Tizen IVI

**8) 웹 운영체제**

2000년대 초반의 웹 OS(제1세대형) 는
"인터넷 기반의 운영체제로 인터넷 접속이 가능한 곳이라면 언제 어디서나 자신의 데스크톱을 사용하는 것과 같은 환경을 제공하는 서비스"를 의미했습니다.

따라서 기존의 윈도우나 리눅스 등에서 웹 브라우저를 호출하여 인터넷 접속으로 개인 데스크톱을 활성화합니다.
이곳에 로그인 후 생성한 파일이나 애플리케이션은 유저의 하드웨어가 아닌 웹 서버에 저장됩니다.

최근의 웹 OS(제2세대형) 는 "웹 브라우저를 기반으로 동작하는 가상의 운영체제"의 개념으로 진화했습니다.
사용자는 별도 OS 설치과정 없이 경량화된 최소 크기의 커널 위에서 웹 브라우저를 통해 서비스 제공자 웹 사이트에 접속하여 다양한 서비스를 이용합니다.

최근에는 클라우드 컴퓨팅 서비스와 결합하여 더 강력해졌습니다.
대표적으로 구글의 크롬 OS가 있습니다.

- 어디서나 동일한 작업 환경
- 데이터는 사용자의 하드디스크가 아니라 원격지나 클라우드에 저장
- 네트워크가 지원되는 환경이라면 어디서든지 빠르게 사용
- 크롬 웹 스토어를 통해 사용자가 일부 프로그램을 설치하도록 지원
- 높은 보안성 제공

### 리눅스 기초

**리눅스의 철학**은 다음과 같습니다.

- **상용 유닉스**
    - 기업의 엄격한 통제 및 계획 아래서 진행, 개발자가 임의로 기능 추가 수정할 수 없음
- **리눅스**
    - 엄격한 정책 하에 이루어지지 않고, 인터넷 연결된 전 세계 개발자 그룹들의 기여를 통해 발전하므로
    - 리눅스 시스템을 통합적으로 책임지고 개발하는 어떠한 조직이나 기업체가 존재하지 않음
    - 리눅스 공동체는 다양한 메일링 리스트, 유즈넷 뉴스그룹 등을 통해 소통
    - 리눅스 커널은 최초 개발자인 리누스 토발즈 주도하에 발전됨
- **GNU**
    - 'GNU is Not Unix' 의 재귀적 용법
    - 유닉스와 호환이 되면서도 유닉스와는 다르게 자유 소프트웨어로 만들어졌음
    - 리처드 스톨먼을 주축으로 자유로운 소프트웨어를 희망하던 공동체들이 가장 먼저 운영체제인 유닉스를 모태로 개발을 시작하면서 탄생
    - GNU C 컴파일러인 gcc뿐 아니라 emacs, GNOME, GNU tar, bash, GRUB 등 응용 프로그램 만들어짐
- **FSF(Free Software Foundation) 와 자유 소프트웨어**
    - 자유 소프트웨어 재단은 1985년 리처드 스톨먼이 세운 비영리 조직
    - 무료나 공짜가 아니라 자유(Free), 즉 '구속되지 않는다' > 프로그램의 변경이나 수정의 자유
    - 즉, 규칙을 지키기만 하면 변경, 수정, 추가 배포 등이 자유로움
- **카피레프트(Copyleft)와 GNU GPL(General Public License)**
    - 카피레프트는 저작권을 뜻하는 카피라이트(Copyright)의 반대 의미
    - 개작된 프로그램에 대한 배포상의 제한조건이 별도로 없다면 모든 사람에게 허용(사적 소유 > 공적 소유)
    - GNU GPL 은 카피레프트를 실제 구현한 라이선스

> **자유 소프트웨어**
> 1. 목적에 상관없이 프로그램을 실행시킬 수 있는 자유
> 2. 프로그램이 어떻게 동작하는지 학습하고, 필요에 따라서 프로그램을 개작할 수 있는 자유(실제로 소스코드 이용 가능해야 함)
> 3. 무료 또는 유료로 프로그램을 재배포할 수 있는 자유
> 4. 프로그램을 개선시킬 수 있는 자유와 개선된 이점을 공동체 전체가 누릴 수 있도록 발표할 수 있는 자유

**주요 라이선스**는 다음과 같습니다.

- **GPL(General Public License)**
    - FSF 의 창시자인 리처드 스톨먼이 GNU GPL 에서 다섯 가지 의무를 저작권의 한 부분으로 강제
    1. 컴퓨터 프로그램은 어떠한 목적으로든지 사용할 수 있다. 다만 법으로 제한하는 행위는 할 수 없다.
    2. 컴퓨터 프로그램의 실행 복사본은 언제나 프로그램의 소스 코드와 함께 판매하거나 소스 코드를 무료로 배포해야 한다.
    3. 컴퓨터 프로그램의 소스 코드를 용도에 따라 변경할 수 있다.
    4. 변경된 컴퓨터 프로그램 역시 프로그램의 소스 코드를 반드시 공개 배포해야 한다.
    5. 변경된 컴퓨터 프로그램 역시 반드시 똑같은 라이선스인 GPL 라이선스를 적용해야 한다.

> **GPLv1**
> - 1989년 1월 발표, 사람이 이해하기 쉬운 코드를 같이 배포해야 한다는 조건 추가
>
> **GPLv2**
> - 1991년 6월 발표, 특허로 인해 소스코드 공개가 불가능한 경우 실행 바이너리 프로그램까지 배포할 수 없도록 보완
>
> **GPLv3**
> - 2007년 6월 발표, 소프트웨어 특허 대처법, 다른 라이선스와의 호환성, 원시 코드 구성 부분, 디지털 제한 권리 관련 내용 추가

- **LGPL(Library/Lesser General Public License)**
    - 1991년 6월, 리처드 스톨먼에 의해 GPL 라이선스의 강력한 카피레프트 조건과 단순한 사용 허가를 위한 절충안 발표
    - 주로 소프트웨어 라이브러리에 사용되어 자유 소프트웨어뿐 아니라 독점 소프트웨어에서도 사용 가능하도록 됨
    - 하지만 LGPL 적용 소스 코드 수정시 2차적 파생물 저작물에 해당하므로 라이브러리 소스 코드를 반드시 제공해야 함

- **BSD(Berkeley Software Distribution)**
    - 버클리의 캘리포니아 대학에서 배포하는 공개 소프트웨어 라이선스
    - 누구나 개작 가능, 수정본 배포 가능. 의무적 재배포 사항이 없어 원시 소스코드 비공개 허용. 상용 사용 가능

- **아파치(Apache)**
    - 아파치 소프트웨어 재단에서 자체적으로 만든 소프트웨어에 대한 라이선스 규정
    - 누구든 아파치 소프트웨어의 부분 혹은 전체를 개인적, 상업적 목적으로 이용 가능
    - 재배포 시 아파치 라이선스 2.0 소프트웨어임을 명확히 밝히면 수정한 소스 코드를 반드시 포함시키지 않아도 됨
    - 대표적으로 Apache HTTP Server, Hadoop, Hbase, Tomcat 등

- **MPL(Mozilla Public License)**
    - 모질라 재단에서 규정한 라이선스로 BSD 와 GPL 의 혼합적 성격
    - 수정 시 소스 코드 공개는 필수이지만 MPL 소스를 제외한 소스는 공개하지 않아도 됨

- **MIT(Massachusetts Institute of Technology)**
    - 미국 MIT 대학의 BSD 기초한 라이선스
    - 라이선스와 저작권 관련 명시만 지키면 됨
    - X Window System, JQuery, Node.js 등

**리눅스의 역사**는 다음과 같습니다.

1987년 개발된 교육용 유닉스인 미닉스를 토대로 1991년 리누스 토발즈가 POSIX 에 호환되는 운영체제 커널을 만들 목적으로 리눅스 개발했습니다.
리눅스는 0.02 버전을 10월에 공식 발표한 이후로 전 세계 개발자들의 도움으로 발전했습니다.

초기 리눅스는 운영체제의 핵심인 커널(Kernel)을 지칭하였으나,
GNU 프로젝트의 라이브러리와 도구들이 포함되면서 하나의 운영체제로 발전하였습니다. 이러한 운영체제를 GNU/Linux 라고 합니다.

> **커널**
> - 시스템 부팅 시 로드되는 커널은 운영체제의 뇌에 해당
> - 주된 역할은 시스템의 하드웨어의 효율적 제어 (메모리, CPU, 디스크, 단말기, 프린터 등)
> - 활용도를 높이기 위한 스케줄링 및 실행중인 프로그램 관리, 자료관리

또한 **리눅스 배포판**이란, 리눅스 커널 이외의 핵심적인 부분을 GNU 정신을 바탕으로 만들어진 다양한 자유 소프트웨어와 공개 프로그램을
모아서 하나의 운영체제로 만든 것을 말합니다.

- **리눅스 배포판**
    - 최초의 배포판은 피터 맥도널드의 SLS, 패트릭 볼커딩의 슬랙웨어, 이안 머독에 의한 데비안 프로젝트
    - 분류(패키지 관리 기법에 따라 분류됨)
        - **슬랙웨어**: 최상단에서 최대한 수정되어 배포, 새로운 적용 및 수정이 어려움. SuSE, Porteus, Vector Linux, Salix OS 등
        - **데비안**: dpkg 및 apt 도구 사용. Knoppix, Corel, Lindows, Ubuntu, Linux Mint, Elementary OS 등
        - **레드햇**: rpm 및 yum 도구 사용. RHEL, CentOS, Fedora, Oracle Linux, Scientific Linux, Asianux 등
    - 수세와 우분투 리눅스가 각 계파의 리더격임

소프트웨어 패키지 의존성을 자동으로 해결해주지 않는 보수적인 슬랙웨어에 비해 데비안은 패키지 관리 면에서
사용자친화적이기 때문에 쉽게 대중화되었습니다. 레드햇 또한 독자적인 패키지 관리 툴이 존재하여 인기가 많으며,
2003년 배포된 Red Hat Linux 9 까지만 무상 배포되었고 현재 RHEL의 유료 배포판을 지원합니다.
레드햇의 무료 배포판은 현재 fedora 오픈 소스 프로젝트로 관리되며, RHEL 의 복제판인 CentOs 도 2014년 흡수되었습니다.

- **리눅스 동향**
    - 리눅스는 초기부터 주로 서버로 이용됨
    - 자유 소프트웨어의 이점으로 다양한 분야로 진출 (서버, 데스크톱 및 개발, 임베디드)
    - 서버 및 슈퍼컴퓨팅에서 우수, 데스크톱은 우분투가 각광, 모바일 분야 및 스마트 TV, IVI, 자동차 등에서도 활용
    - 나아가 클라우드 컴퓨팅 인프라 구축과 빅데이터 및 사물인터넷 환경에서도 중추적인 역할을 수행할 것으로 사료

- **리눅스 클러스터링(Linux Clustering)**
    - 단말 제어 장치와 그에 접속된 복수의 단말의 총칭. 서버 분야에서는 여러 대의 컴퓨터를 연결하여 하나처럼 활용하는 시스템 지칭
    - **고계산용 클러스터(HPC)**: 주로 과학계산용. 병렬 컴퓨터로 슈퍼컴퓨터의 성능
    - **부하분산 클러스터(LVS)**: 대규모의 서비스 제공 목적. 이용자가 많은 웹 서비스 등에 활용. 부하 분산을 위한 로드밸런서를 둠
    - **고가용성 클러스터(HA)**: 지속적인 서비스 제공 목적. LVS 와 연동하여 많이 사용. Primary Node 와 Backup Node 의 커버링 구성

**임베디드 시스템(Embedded System)**, **클라우드 컴퓨팅(Cloud Computing)**, **빅 데이터(Big Data)**, **사물인터넷(IoT)** 등
리눅스가 활용되는 다양한 분야가 존재합니다.    

### 1-2. 리눅스 시스템의 이해

### 리눅스와 하드웨어

리눅스 설치 시 사용 목적에 따른 적절한 리눅스 배포판과 이에 맞는 하드웨어를 선택해야 합니다.
배포판마다 지원하는 아키텍쳐가 다르기 때문에 시스템에서 사용하는 CPU 를 지원하는 리눅스를 고려해야 합니다.

- **CPU**
    - 인텔의 x86 계열과 AMD 계열이 대표적이며, CPU 가 32비트인지 64비트인지에 따라 지원되는 메모리 양이 다르므로 이것도 고려해야 함
    - 추가적으로 클라우드 인프라 환경에서 사용한다면 가상화 기술 지원 여부도 확인
- **메모리(RAM)**
    - 메모리의 용량은 하드디스크 일부 공간을 램처럼 사용하는 Swap 파티션 설정과 관련이 있으므로 꼭 확인
    - 32비트 리눅스에서는 페이징 기법의 차이로 4GB 이상의 램을 인식할 수 없음
    - 64비트 리눅스에서는 대용량 메모리 지원
- **하드디스크 드라이브**
    - 하드디스크 인터페이스인 IDE(ATA), E-IDE, SCSI, S-ATA 등을 지원
    - 초고속 반도체 메모리를 저장 매체로 사용하는 USB 메모리나 SSD 도 지원
    - 하드디스크 드라이브는 파티션 변경이나 스왑 등 설정할 영역이 존재 (IDE 는 /dev/hdx 형식으로, SCSI 는 /dev/sdx 형식으로 관리)
- **모니터와 비디오 어댑터**
    - X-Window 기반의 GUI 환경에서 고려 대상. 장치에 맞는 정확한 드라이버를 사용해야 함
- **네트워크 인터페이스**
    - 이더넷(Ethernet), 모뎀, ISDN, AX.25, ATM 등의 네트워크 인터페이스 지원
    - 특히 이더넷 카드는 LAN 어댑터 제조사 상관없이 대부분 지원. 무선랜 어댑터도 지원
    - 네트워크 설정을 위해 IP 주소, 넷마스크, 게이트웨이 주소, DNS 주소 등을 잘 설정해야 함
- **키보드 및 마우스**
    - 현존 대부분을 지원. X-Window 환경에서 마우스 휠도 지원
- **CD-ROM 및 DVD-ROM**
    - 하드디스크 인터페이스와 같이 대부분을 파일 형식으로 자동 인식되어 관리됨
- **기타 하드웨어**
    - 사운드카드와 프린터 등 데스크탑 목적 하드웨어도 지원

**RAID(Redundant Array of Independent Disks)** 는 여러 개의 하드디스크가 있을 때 동일한 데이터를 다른 위치에 중복해서 저장하는
방법입니다. 운영체제에서 하나의 RAID 는 논리적으로 하나의 디스크로 인식하여 처리합니다.

- **RAID 의 이용**
    - 초기에는 저용량 하드디스크를 하나의 디스크로 확장하여 사용하는 것이 주류
    - 현재는 백업을 가능하게 하고 안정적인 데이터의 보존과 유지 기능, 속도 향상 등에 사용
    - 소프트웨어적 RAID 는 비용적인 측면에서 유리하나, 성능 면에서는 하드웨어 RAID 가 좋음
- **RAID 에서 사용하는 기술**
    - 스트라이핑(Striping): 연속된 데이터를 여러 개의 디스크에 라운드로빈 방식으로 기록하는 기술. 여러 디스크에 동시적으로 접근시 유리
    - 미러링(Mirroring): 디스크에 에러 발생 시 데이터의 손실을 막기 위해 추가적으로 하나 이상의 장치에 중복 저장하는 기술
- **RAID 의 종류**
    - RAID-0: 스트라이핑 기술을 사용하여 빠른 입출력 속도 제공. 중복이나 패리티 없이 디스크에 분산 기록. 따라서 오류시 복구 불가능
    - RAID-1: 미러링 기술을 사용하여 두 개의 디스크에 데이터를 동일하게 기록.
    동시 읽기가 가능해 읽기 속도는 향상되나 쓰기는 단일 디스크와 같음. 오류시 복구 능력 탁월하지만, 중복 저장으로 디스크 낭비가 50%에 이름
    - RAID-2: 디스크들은 스트라이핑 기술을 사용하고, 에러 감지 및 수정을 위해 ECC(Error Check & Correction) 정보를 활용
    - RAID-3: 스트라이핑 기술을 사용하여 디스크를 구성하고, 패리티 정보를 저장하기 위해 별도로 하나의 디스크 사용.
    입출력 작업이 동시에 모든 디스크에 대해 이루어지므로 입출력을 겹치게 할 수는 없음. 보통 대형 레코드가 많은 시스템에서 사용.
    - RAID-4: 블록 형태의 스트라이핑 기술을 사용하여 디스크 구성하는데, 이는 단일 디스크로부터 레코드를 읽을 수 있고 데이터를
    읽을 때 중첩 입출력의 장점이 있음
    - RAID-5: 패리티 정보를 이용하여 커버하며 최소 3개의 디스크로 구성. 패리티는 각 디스크에 분산 기록됨. RAID-0 의 단점인 결합
    허용을 지원하지 않는 점과 RAID-1 의 저장공간 비효율성을 보완한 레벨로 디스크 개수를 늘릴수록 저장 효율성이 높아짐.
    - RAID-6: RAID-5 에서 디스크에 2차 패리티 구성을 포함하여 매우 높은 고장 대비 능력 발휘. 2개의 디스크 오류에도 데이터 읽기 가능.
    최소 4개의 디스크로 구성해야 하며, RAID-5 에 비해 공간 효율성이 떨어짐
    - RAID-7: 하드웨어 컨트롤러에 내장되어 있는 실시간 운영체제를 사용하여 구성하는 방식으로 속도가 빠른 버스를 이용.
    - RAID 0+1: 디스크 2개를 RAID-0 의 스트라이핑 기술로, 다시 RAID-1 의 미러링으로 구성하는 방식. 최소 4개 필요
    - RAID-10: RAID 0+1 의 반대 개념으로 디스크 2개를 먼저 미러링하고 다시 스트라이핑
    - RAID-53: RAID-3 방식에 별도로 스트라이프 어레이를 구성하는 방식. 보다 높은 성능을 제공하지만 구성 비용이 많이 듬

**LVM(Local Volume Manager)** 이란, 논리적으로 유연하게 파티션을 분할 관리하는 방법입니다.

- **LVM** 은 찰흙과 같은 개념으로 이해하면 좋은데, 고정적인 여러 개의 하드디스크를 논리적으로 원하는 크기와 개수로 파티셔닝 가능하게 함
- 사용중인 파티션의 크기를 줄이거나 늘릴 수 있으며, 파티션 확장은 디스크 추가 이후 간단한 명령만으로 데이터 이전 없이 손쉽게 가능
- **LVM 구성도와 관련 용어**
    - 물리적 볼륨(PV): 실제 디스크에 물리적으로 분할한 파티션. (/dev/sdb1, /dev/sdc1 등)
    - 볼륨 그룹(VG): 물리적 볼륨이 모여서 생성되는 덩어리. PE(Physical Extent)의 큰 덩어리.
    - 논리적 볼륨(LV): 볼륨 그룹에서 사용자가 필요한 만큼 할당하여 만들어지는 공간. 물리적으로는 디스크에서 분할하여 사용하는 파티션.
    - 물리적 확장(PE): 물리적 볼륨에서 나누어 사용하는 일종의 블록 같은 영역. 보통 1PE 가 4MB 정도씩 할당됨

### 리눅스의 구조

**부트 매니저(Boot Manager)** 란 부팅을 도와주는 프로그램으로, 한 컴퓨터에 여러 운영체제가 설치된 경우 선택하여 부팅할 수 있도록 합니다.
부트 매니저는 부트 로더라고도 부릅니다. 이것은 하드디스크의 맨 앞쪽 영역인 MBR(Master Boot Record) 에 설치되며,
MBR 은 0번 섹터에 512 바이트 크기입니다. MBR 에는 부트 매니저가 설치됨과 함께 파티션 정보가 기록됩니다.

리눅스의 대표적인 부트 매니저 프로그램은 다음과 같습니다.

- LILO(Linux Loader): 파일 시스템 구애 없이 플로피 디스크와 하드 디스크를 이용한 부팅 지원
- **GRUB(Grand Unified BootLoader)**
    - GNU 에서 만든 부트로더로 LILO 보다 다양한 파일 시스템을 지원하고 부팅시 커널 인자를 조정하여 동적인 부팅을 지원함
    - 메뉴 인터페이스 방식과 bash 와 같은 명령행 인터페이스 또한 제공 (그래픽 메뉴, 그림 삽입 가능)
    - 레드햇의 경우 /boot/grub/grub.conf 파일에서 설정. 재부팅시 반영
- GRUB 의 부팅 모드
    - 메뉴 화면에서 지정된 키를 입력하여 여러 동작 가능
    - \[a]: grub.conf 에서 커널과 관련된 부분의 매개변수를 추가할 수 있게 해줌
    - \[e]: grub.conf 에 등록된 부팅 목록의 모든 항목을 직접 편집할 수 있도록 해줌. 파일을 변경하진 않고 현재 부팅 시에만 일시적으로 적용
        - e: 커서가 위치한 줄 편집
        - d: 커서가 위치한 줄 삭제
        - o: 명령 줄을 커서가 위치한 줄 아래에 추가
        - O: 명령 줄을 커서가 위치한 줄 위에 추가
        - b: 부팅 시작(최종 편집 후 부팅)
    - \[c]: bash 셸과 유사한 상호대화식 명령행 모드로 진입. TAB, ESC 키 사용 가능하며, 마지막에 'boot' 입력하면 부팅이 됨
- GRUB 의 환경 설정 파일
    - 환경 설정 파일은 /boot/grub/grub.conf 이며, 리눅스와 윈도우 멀티 부팅 환경인 경우 이 파일 내의 title 영역에 각각의 설정이 나타남
    - (교재에서 각 라인에 대한 의미를 확인할 것.)

**디렉토리(Directory)** 란 파일을 보관하는 곳으로써 리눅스에서는 최상위 root(/) 를 중심으로 트리 형식으로 하위 디렉토리 및 파일이
계층적으로 분포됩니다.

- **/**: 최상위 루트 디렉토리
- **/bin**: 실행 파일 모음. 보통 PATH 환경변수 경로에 설정되어 있음 (cp, mkdir, rmdir, mv, rm, cat 등 명령)
- **/boot**: 부팅 이미지 파일이나 커널 등 시스템 부팅 시 필요한 파일 모음. grub 관련 파일도 존재
- **/dev**: 물리적 디바이스 장치들이 파일 형식으로 저장됨
- **/etc**: 시스템 환경 설정 파일 및 부팅과 관련된 여러 스크립트 파일 모음. 이 설정들을 읽어 관련 프로그램들이 실행됨
- **/home**: 개인 사용자들의 홈 디렉토리가 모여 있음
- **/lib**: 각종 라이브러리 모음. 커널 모듈도 들어 있음
- **/lost+found**: fsck 명령어를 이용하여 파일 시스템을 복구할 때 작업하는 디렉토리 RHEL 7 버전부터는 사용되지 않음
- **/mnt**: CD-ROM, 플로피디스크, 하드디스크, 네트워크 파일 시스템 등을 마운트할 때 포인트가 되는 디렉토리.
최근에는 장치별로 /media, /net 등이 추가 제공되기도 함
- **/misc**: 자동 마운트 프로그램인 autofs 에 의해 사용되는 디렉토리
- **/opt**: 응용 프로그램들의 설치를 위해 사용되는 디렉토리
- **/proc**: 가상 파일 시스템으로 시스템에서 운영되고 있는 다양한 프로세스의 상태 정보, 하드웨어 정보, 기타 시스템 정보 등을 담고 있음
- **/root**: 시스템 관리자인 root 의 사용자 홈 디렉토리
- **/sbin**: System Binary 의 약자로 주로 시스템 관리에 대한 명령어들이 들어 있는 디렉토리. 보통 수퍼유저인 root 가 사용.
시스템 종료 명령, 네트워크 인터페이스 설정 명령, 시스템 점검과 복구 등의 명령어
- **/tmp**: 임시 저장 디렉토리로서 각종 프로그램이나 소켓 파일, 프로세스 작업을 할 때 임시로 생성되는 파일을 저장하는 공간
- **/usr**: 시스템 운영에 필요한 명령, 응용 프로그램들이 위치하는 디렉토리. 커널 소스, C 헤더 파일, C 컴파일러와 같은 개발 도구,
apache 나 mysql, php 등 모두 이 디렉토리의 하위에 설치됨. /usr/bin, /usr/sbin 에는 주요 응용프로그램의 명령어들이 존재함.
로컬에서 응용프로그램을 추가로 설치할 때 사용되는 /usr/local 등도 존재
- **/var**: 시스템 운영 로그 파일과 스풀링과 같은 가변적인 데이터를 보관하는 디렉토리. 메일 서버의 경우 수신 메일 보관함 존재
- /media, /selinux, /srv, /sys, /cgroup, /lib64, /run 등 추가로 존재

**부팅(Booting)** 은 하드웨어적 단계와 프로그램 메모리 적재의 소프트웨어적 단계로 나눠집니다.

- 하드디스크에 설치된 운영체제의 부팅 과정
    1. 컴퓨터 전원을 켜면 바이오스는 컴퓨터에 장착된 하드웨어를 점검한다.
    2. 바이오스는 하드웨어 검사가 끝나면 CMOS 에 설정된 첫 번째 부팅 하드디스크를 확인한다.
    3. 첫 번째 하드디스크의 MBR 영역에 있는 부트 매니저 프로그램을 실행한다.
    4. 부트 매니저 프로그램은 관련 환경 설정 파일을 참고하여 운영체제 부팅을 시작한다.
- **리눅스의 부팅**
    - 리눅스의 부팅은 GRUB 의 시작부터 텍스트 기반 콘솔 로그인 화면 혹은 X-Window 가 구동되어 로그인 창이 나타나기까지를 지칭
    - **하드웨어 인식 단계**: 하드웨어를 인식하고, grub 부트 메뉴에서 [a] 혹은 [e] 로 매개변수=값을 추가로 입력
    - **소프트웨어 구동 단계**
        - 부팅 시 커널이 로드되면 커널은 우선 루트 파일 시스템을 읽기 전용 형태로 마운트, 검사 후 쓰기 가능 형태로 다시 마운트
        - 이후 커널은 init 프로세스를 발생시키는데, 리눅스 부팅과 관련된 소프트웨어 구동은 init 프로세스에 위임됨
        - init 은 /etc/init 디렉토리 안의 환경 설정 파일을 읽어 동작

> **init 프로세스 관련 환경 설정 파일**
> - /etc/inittab: 부팅과 관련된 실행레벨(Runlevel) 정의
> - /etc/init/rcS.conf: 시스템 초기화 관련 설정. /etc/rc.d/rc.sysinit 스크립트 실행하여 호스트명 설정, 시스템 점검, RAID 및 LVM
> 장치 활성화, 쿼터 설정 활성화 등 진행
> - /etc/init/rc.conf: 각 레벨별 진행되는 내용 설정 파일. /etc/rc.d/rc 스크립트 실행. 이 스크립트는 런레벨 3인 경우
> /etc/rc.d/rc3.d 디렉토리의 실행 데몬 스크립트 중 S 로 시작되는 것을 찾아 부팅 시 실행함
> - /etc/rc.d/rc.local: 런레벨 2, 3, 5 에서 가장 마지막에 실행되는 파일로써, 보통 사용자가 부팅 시에 필요한 서비스 구동

- **실행 레벨(Runlevel)**
    - init 데몬 프로세스에 의해 수행되어질 내용이나 시스템 초기화 등을 정의해둔 여러 모드. 리눅스는 총 8개
    - 그래픽 환경은 런레벨 5, 텍스트 환경은 런레벨 3 로 부팅
    - **0**: 시스템 중지(종료). 기본값으로 설정해서는 안됨
    - **1**: 단일 사용자 모드. 로그인 없이 root 로 부팅하여 일종의 관리자 모드 역할. root 패스워드 분실 혹은 파일 시스템이나 시스템
    점검 및 복구 시 접근
    - **2**: 네트워크 사용하지 않는 다중 사용자 모드
    - **3**: 네트워크 지원하는 다중 사용자 모드. 가장 보편적 레벨이며, X-Window 사용하지 않아 메모리 효율적 사용 가능
    - **4**: 사용되지 않음. 사용자가 정의하여 사용 가능
    - **5**: X-Window 를 사용하는 다중 사용자 모드. 최근 배포판에서 기본 설정임
    - **6**: 시스템 재부팅 레벨. 기본값으로 설정해서는 안됨

0~6 까지 7개의 런레벨 외에 emergency 모드라 부르는 S 또는 s 모드는 1 과 유사하나 관련 프로세스나 데몬을 최소화하여
유지 보수나 점검에 적합합니다.

- **로그인**
    - 런레벨 3인 경우 CTRL+ALT+F1~F6 으로 6개의 가상 콘솔 통해 로그인
    - getty(mingetty) 프로그램이 터미널이나 콘솔에 로그인 프로그램을 실행. 이때, /etc/issue 의 내용이 상단에 출력됨
    - 런레벨 5인 경우 CTRL+ALT+F7 (배포판에 따라 F1) 에 그래픽하게 나타남
    - /etc/issue 는 로컬, /etc/issue.net 은 텔넷을 통한 네트워크 접속 시 출력되는 메시지 기록
    - /etc/motd 는 로그인 성공 시 보여주는 메시지
- **로그아웃**
    - 자원 효율성 및 보안의 측면에서 로그아웃은 필수 (logout, exit 혹은 메뉴 선택으로)
    - root 사용자가 /etc/profile 의'TMOUT=초' 로 지정하면 지정된 시간동안 작업이 없을 시 해당 사용자를 강제 로그아웃 시킴
    
**시스템 종료(Shutdown)** 를 위해 터미널 환경에서 shutdown, halt, reboot, poweroff, init 등의 명령이 사용됩니다.

- **shutdown**
    - root 권한자만 실행 가능
    - **```# shutdown [option] 시간 [경고메시지]```**
    - 시간은 +m 형식 혹은 hh:mm 형식으로 설정 가능
    - 옵션
        - -r: 재부팅(reboot)
        - -h: 종료(halt)
        - -c: 예약된 shutdown 명령 취소
        - -k: 실제로 shutdown 하지 않고 경고 메시지만 접속 사용자들에게 전송
- **reboot**
    - 시스템 재시작 명령. 로컬 사용자라면 모두 사용 가능
    - **```$ reboot [option]```**
    - 옵션
        - -w: 재부팅 없이 /var/log/wtmp 에 셧다운 기록만 저장
- **halt**
    - 시스템 종료 명령. 로컬 사용자라면 모두 사용 가능
    - **```$ halt [option]```**
    - 옵션
        - -p: 시스템 종료 후 전원까지 끄는 경우 사용(--poweroff)
- **poweroff**
    - 시스템 종료 및 전원을 끄는 명령
- **init, telinit**
    - 모든 프로세스의 조상인 init 프로세스에 직접 요청하여 런레벨을 변경하는 명령
    - 빠르게 실행되지만, 실행중인 프로세스를 무조건적으로 종료하므로 권장되지 않음
    - **```$ init [실행 레벨]```**
    - ```init 0``` 은 시스템 즉시 종료, ```init 6``` 은 시스템 즉시 재부팅

**파일 시스템(File System)** 이란, 운영체제가 파티션이나 디스크에 데이터를 저장하고, 읽고, 쓰고, 찾기 위해 구성하는 일련의 체계를
의미하는데, 운영체제가 사용자에게 제공하는 가장 직접적인 서비스 형태 중 하나입니다.

파일 시스템의 구성은 운영체제 설치 시에 일어나며, 파티션 분할 작업 후 포맷(Format)을 가장 먼저 하게 되는데,
이것은 파일을 저장하기 위해 디스크를 일정한 크기로 분할하고 주소를 설정하는 작업이라고 할 수 있습니다.
각각의 운영체제들은 포맷이라는 작업을 통해 고유한 파일 시스템을 구축하게 되고, 다양한 규칙들을 설정하게 됩니다.

대부분의 운영체제들은 파일이라는 단위로 저장하고, 파일에 이름을 부여한 뒤에 디렉토리에 저장합니다. 이 과정에서 파일명의 길이를 제한하기도
하고, 어떤 문자들이 사용될 수 있는지를 정하기도 합니다. 파일명에 확장자를 쓰도록 지정하기도 하며, 확장자의 길이도 제한할 수 있습니다.
또한 파일 시스템은 지원하는 파티션의 개수, 크기, 파일 크기 등에도 직접적인 관계가 있으며, 파일 복구와 같은 기능을 부여하기도 합니다.

따라서 파일 시스템의 성능은 운영체제의 성능에도 밀접한 관계가 있다고 볼 수 있습니다.

- **파일 시스템의 기능**
    1. 사용자가 파일을 생성, 수정, 삭제할 수 있도록 제공
    2. 사용자가 파일을 사용하기 적합한 형태의 구조로 구성하고, 다양한 추가 정보 제공
    3. 다른 사용자와의 파일을 공동으로 사용할 수 있는 적절한 제어 방법 제공
    4. 파일 공유를 위하여 판독 접근, 기록 접근, 수행 접근 등의 다양한 접근 제어 방법 제공
    5. 정보 손실이나 파괴를 방지하기 위하여 백업이나 복구를 위한 기능 준비
    6. 사용자와 장치 간의 독립성을 유지하기 위해, 사용자가 물리적인 장치 이름 대신에 적절한 이름 제공
    7. 정보가 안전하게 보호되고 비밀이 보장될 수 있도록 정보의 암호화 및 복호화 기능 제공
    8. 사용자가 파일이나 디렉토리에 접근하기 쉬운 인터페이스 및 명령어 제공
    
- **리눅스의 파일 시스템**
    - 리눅스는 다양한 파일 시스템 지원 (ext > ext2 > ext3, 저널링 파일 시스템 > ext4)
    - 저널링 파일 시스템: 파일 시스템에 대한 변경사항을 반영하기 전에 저널이라 부르는 로그에 저장하여 추적이 가능하게 함.
    데이터 복구 확률을 높여줌
    - ext2, ext3, ext4, nfs, Reiser FS, XFS, JFS 등 지원

> 각 파일 시스템의 특징을 교재에서 참조할 것
>

- **리눅스 파일 시스템의 구조**
    - 파티션 분할 이후 Format(mkfs) 작업을 통해 파일시스템을 생성
    - 파일 시스템에서 **기본적으로 데이터를 저장하는 단위는 블록(Block)**으로써, 기본 4KB 로 지정됨
    - 파일 시스템은 크게 부트 블록(Boot Block, 또는 부트 섹터)과 여러 개의 블록 그룹(Block Group, N-1개)으로 나뉘어짐
    - 블록 그룹은 그룹내 모든 메타 정보를 담고 있는 **슈퍼 블록(Super Block)**, **그룹 기술자(Group Descriptors)**,
    **블록 비트맵(Block Bitmap)**, **아이노드 비트맵(Inode Bitmap)**, **아이노드 테이블(Inode Table, 또는 아이노드 블록)**,
    **데이터 블록(Data Blocks)** 으로 구성됨
    - 슈퍼 블록과 블록 기술자는 모든 메타정보가 있어 중요하므로 모든 블록에 걸쳐 사본이 백업됨
    - **슈퍼 블록**: 특정 파일 시스템임을 알리는 매직 넘버, 마운트 정보, 전체 아이노드 수 및 남은 수, 전체 블록 수 및 남은 수,
    블록 그룹 번호, 블록 크기, 그룹 당 블록 수 등
    - **그룹 기술자**: 각각의 블록 그룹을 기술하는 자료 구조로서, 저장되는 주요 정보는 블록 비트맵, 아이노드 비트맵,
    아이노드 테이블(또는 아이노드 블록)
    - **블록 비트맵**: 블록의 사용 현황을 bit 로 표현
    - **아이노드 비트맵**: 아이노드 할당 상태를 bit 로 표현
    - **아이노드 테이블**: 아이노드 정보가 들어있는 영역. ls -l 명령 시 나타내는 파일 관련 정보가 저장됨
    - **데이터 블록**: 파일이 보관해야 하는 정보를 저장하는 영역(파일 데이터)
        - 추가 데이터 블록의 포인터가 동적으로 할당되는 간접 블록, 아이노드나 간접 블록 안의 데이터 블록의 주소를 저장하는 홀

> **아이노드(Inode)**
> - 일종의 자료구조로 각각의 파일은 하나의 아이노드를 할당받아 관리
> - 파일 정보 저장 (아이노드 넘버, 접근 모드, 파일 형식, 소유자 정보, 파일 크기, 타임 스탬프 등)
> - 파일 시스템 생성 시 전체의 약 1% 공간을 아이노드에 할당하므로, 생성 가능 파일의 최대 개수도 한정되어 있음

> **저널링 기술과 저널링 파일 시스템**
> - 기존의 fsck 에 걸리는 시간을 단축하기 위해 데이터를 디스크에 쓰기 전에 로그에 남겨 비정상적 종료에도 보다 빠르고 안정적인 복구기능 제공
> - fsck 로 복구시 슈퍼 블록, 비트맵, 아이노드 등을 모두 검사하므로 많은 시간이 걸렸지만,
> - 저널링 파일 시스템은 수정 내역을 블록에 적용 전 로그에 수정된 내용을 저장하므로 복구시 단지 로그만 검사하면 됨
> - 로그 기록 중 중지되었다면 아직 실제 적용 전이므로 문제가 되지 않고, 블록에 적용 중 중지되었다면 로그만 살펴보면 되니 안정성이 높음
> - ext3, ext4, XFS, JFS, ReiserFS 등

### X 윈도

(생략)

### 셸(Shell)

**셸**은 커널과 사용자간 다리 역할을 하는 것으로 사용자로부터 명령을 받아 그것을 해석하고 프로그램을 실행시키는 역할을 합니다.

여러 개의 셸이 있는데, 사용자가 로그인을 하면 사용자에게 설정된 셸이 부여됩니다. 따라서 사용자에게 셸을 부여하지 않으면
시스템에 로그인 하더라도 명령 수행이 불가능하여 로그인을 막는 효과와 동일하다고 볼 수 있습니다.

현재 가장 많이 사용되는 표준 셸은 ksh 과 csh 의 장점을 결합한 bash 셸입니다.

- 셸 종류: Bourne Shell(sh), bash, csh, tcsh, ksh 등
- 셸 확인: ```$ echo $SHELL``` > ```/bin/bash```, ```$ chsh -l```
- 셸 변경: ```$ chsh``` > 패스워드 입력 후 변경할 셸의 절대 경로 입력
- 사용자의 로그인 셸 정보 확인: /etc/passwd 설정 파일 내 사용자 라인의 7번째 필드에 기록

```
~$ grep daesungra /etc/passwd
daesungra:x:500:500::/home/daesungra:/bin/bash
```

**셸 변수**는 ```변수명=값``` 형태로 지정하며, ```$ echo $[변수명]``` 로 값을 확인합니다.

**환경 변수**는 프롬프트 변경, PATH 변경 등과 같이 셸의 환경을 정의하는 중요한 역할을 수행하는 변수입니다.
환경 변수는 env 명령으로 확인할 수 있습니다.

- HOME: 사용자의 홈 디렉토리
- PATH: 실행 파일을 찾는 디렉토리 경로
- LANG: 셸 사용 시 기본으로 지원되는 언어
- TERM: 로그인한 터미널 종류
- PWD: 사용자의 현재 작업 디렉토리
- SHELL: 사용자의 로그인 셸
- USER: 사용자의 이름
- DISPLAY: X 에서 프로그램 실행 시 출력되는 창
- PS1: 프롬프트(Prompt) 변수
- PS2: 2차 프롬프트 변수
- HISTFILE: 히스토리 파일의 절대 경로
- HISTSIZE: 히스토리 파일에 저장되는 명령어의 개수(줄 기준)
- HISTFILESIZE: 히스토리 파일의 파일 크기
- HOSTNAME: 시스템의 호스트명
- MAIL: 도착한 메일이 저장되는 경로
- TMOUT: 사용자가 로그인한 후 일정 시간 동안 작업을 하지 않을 경우에 로그아웃시키는 시간으로 단위는 초(second)
- UID: 사용자의 UID

환경 변수의 사용 예는 다음과 같습니다.

- ```$ mkdir $HOME/data``` > 홈 디렉토리에 디렉토리 추가
- ```$ echo $LANG```, ```$ LANG=C``` > 기본 언어 변경
- ```$ PS1="[\u@\t \W]\$ "``` > 프롬프트 형식 변경

> 주요 프롬프트 형식
> - \d: '요일 월 일' 형태로 날짜를 표시 (ex. "Wed Jan 15")
> - \h: 호스트 이름 표시
> - \s: 사용중인 셸의 이름 표시
> - \t: 24시 형태의 현재 시간 표시 (HH:MM:SS)
> - \T: 12시 형태의 현재 시간 표시 (HH:MM:SS)
> - \@ 12시 형태의 현재 시간에 AM/PM 을 추가로 표시
> - \u: 현재 사용자의 이름 표시
> - \w: 현재 작업 디렉토리를 절대 경로로 표시
> - \W: 현재 작업 디렉토리의 전체 경로 중 마지막 디렉토리만 표시
> - \!: 현재 명령의 히스토리 넘버 표시
> - \\: \ 표시 (백슬래시)

가장 빈번하게 사용되는 **bash 셸의 주요 기능**을 살펴봅니다.

- (1) **명령행 완성 기능**
    - tab 키를 눌러서 작성 중인 명령 혹은 파일이나 디렉토리명을 자동 완성
    - 여러 개가 존재한다면 tab 키를 한번 더 눌러서 목록 확인
    
- (2) **명령어 history 기능**
    - history 관련 셸 환경 변수에 따라 실행했던 모든 명령들이 히스토리 리스트 버퍼에 스택으로 저장
    - 위/아래 방향키로 목록을 찾을 수 있음
    - 사용자별 히스토리 파일인 '~/.bash_history' 에 기록됨 (기록은 로그아웃 시 메모리에 기억된 명령의 목록을 저장)
    - 'history' 혹은 '!' 명령으로 확인

> **!와 히스토리 명령문**
> - !!: 마지막에 사용한 명령 실행
> - !n, !-n: n번째 사용한 명령 실행, 역으로 n번째 사용한 명령 실행
> - !문자열: 가장 최근에 사용한 명령 중 '문자열'로 시작하는 명령을 찾아서 실행
> - !?문자열?: 가장 최근에 사용한 명령 중 '문자열'을 포함하는 명령을 찾아서 실행
> - ^문자열1^문자열2: 마지막에 사용한 명령문의 '문자열1' 을 '문자열2'로 대체한 후 실행

> **히스토리 관련 환경 변수**
> - HISTSIZE: 히스토리 스택의 크기가 지정되어 있는 변수
> - HISTFILESIZE: 실질적인 히스토리 파일의 크기
> - HISTFILE: 히스토리 파일의 경로
> - HISTCONTROL: 중복되어지는 명령에 대한 기록 유무를 지정하는 변수
>     - ```$ export HISTOCONTROL=ignoreboth``` > 연속적으로 중복된 명령은 저장하지 않음
> - HISTTIMEFORMAT: history 명령 실행 시 출력되는 시간 형식 지정할때 사용

- (3) **alias 기능**
    - 별명 기능. 특정 명령어와 옵션, 파라미터 등의 조합을 별명으로 지정하여 간편하게 사용 가능
    - ```$ alias [별명='명령어']```
    - ```$ unalias 별명```
    - ex. ```$ alias ll='ls -alF```

alias 를 재로그인 혹은 시스템 재부팅 시에도 유지하려면, .bashrc 파일에 설정하면 됩니다.

- (4) **명령행 편집 기능**
    - (교재 참조, p106)
    
- (5) **명령 대체(Command Substitution, 또는 명령 치환) 기능**
    - 특정 명령의 결과를 다른 명령어의 인자값으로 사용하는 것
    - 이를 위해 '`' (backquotes) 나 $() 활용
    - ex. ```$ ls -l `which passwd` ```
    - ex. ```$ ls -l $(which passwd)```

- (6) **그룹 명령 실행**
    - 하나의 명령 행에 여러 개의 명령어 동시 사용
    - ';' 기호로 구분, 순차적으로 처리
    - ;: 한 줄에 여러 명령을 나열. 순차 처리
    - ||: 논리적 OR(Logical-OR). 앞의 명령이 성공이면 결과를 출력하고 그렇지 않으면 뒤의 명령을 실행하여 결과 출력
    - &&: 논리적 AND(Logical-AND). 앞의 명령이 성공이어야 뒤의 명령을 수행
    - ex. ```$ ls; sleep 10; ls```
    - ex. ```$ ls; find / -type d > list.txt```
    - ex. ```$ (ls; find / -type d) > list2.txt```
    - ex. ```$ pwd; (cd /; pwd); pwd``` > 그룹 명령 실행 후 원래 위치로 돌아옴!
    - ex. ```$ grep daesung /etc/passwd || echo 'No daesung''``` >
    'daesung' 계정이 존재하면 해당 행을 출력, 아니라면 문자열 출력

- (7) **표준 입출력 제어 기능**
    - 표준 입력은 사용자가 키보드를 이용해 입력하는 값, 표준 출력은 화면에 나타나는 결과
    - 표준 입력(Standard Input, stdin): 입력을 담당하는 키보드.
    - 표준 출력(Standard Output, stdout): 결과값이 보여지는 화면. 셸에서는 숫자값 1로 표기되며, 일반적으로 셸 상태에서 숫자값 1은
    생략해서 사용할 수 있음
    - 표준 에러(Standard Error, stderr): 에러 값이 보여지는 화면. 셸에서는 숫자값 2로 표기
    - ```$ abc 2>/dev/null```

- (8) **리다이렉션(Redirection)**
    - 어떤 프로세스의 입/출력을 표준 입출력이 아닌 다른 입출력으로 변경할 때 사용
    - \>: 프로세스의 출력을 표준 출력에서 다른 출력으로 변경
    - \>>: 프로세스의 출력을 지정한 출력(보통은 파일)에 추가
    - <: 프로세스의 입력을 표준 입력에서 다른 입력으로 변경
    - <<: 기호 뒤에 지정한 문자열을 입력으로 받아 해당 문자열이 나오기 전까지를 표준 입력을 삼아 해당 내용을 출력
    - ```$ cat >> tmp.txt```
    - ```$ mail daesungra < abc.txt```
    - ```$ cat << end```, end 라는 문자열이 입력되기 전까지를 표준 입력으로 삼아 화면에 출력

> **리다이렉션 응용 예**
> - ```$ find / -name '*.txt'```: 결과값, 에러 모두 표준 출력
> - ```$ find / -name '*.txt' 2>/dev/null```: 에러는 버림
> - ```$ find / -name '*.txt' >list.txt```: 결과값(1)은 파일에 저장, 에러는 화면에 출력
> - ```$ find / -name '*.txt' 2>/dev/null > list.txt```: 결과값 파일 저장, 에러는 버림
> - ```$ find / -name '*.txt' 2>error.txt```: 결과값 화면 출력, 에러는 파일에 저장
> - ```$ find / -name '*.txt' 2>error.txt > result.txt```: 결과와 에러 각각 파일에 저장
> - ```$ find / -name '*.txt' > data.txt 2>&1```: 결과값과 에러값을 모두 data.txt 파일에 저장.
> ```$ find / -name '*.txt' &> data.txt``` 와 같음
> - ```$ find / -name '*.bak' 2>>error.txt```: 결과값은 화면에 출력, 에러는 파일에 추가하여 저장

- (9) **파이프(Pipe, '\|')**
    - 프로세스 간 통신을 위해 도입. 어떤 프로세스의 표준 출력이 다른 프로세스의 표준 입력으로 쓰이게 하는 것
    - 여러 개를 사용하여 파이프 라인을 만들 수 있음
    - ex. ```$ ls -alF | more```: ls 의 출력이 more 라는 filter 의 입력으로 사용되어 결과가 한 화면씩 출력
    - ex. ```$ ls | sort | more```, ls 의 출력이 정렬되어 한 화면씩 출력

> **tee 명령**
> - 파이프 연결 출력을 두 갈래로 나눌 때 사용
> - ```$ tee [option] [파일]```
> - -i: 인터럽트를 무시하도록 한다
> - -a: 지정된 파일로 출력을 덮어쓰지 않고, 파일 내용 뒤에 추가한다
> - ex. ```$ ls -l | tee list.txt | more```: 파일의 목록을 list.txt 에 기록함과 동시에 more 를 사용하여 화면에도 출력
> - ex. ```$ ls -l /etc | tee etc.txt | tee /tmp/etc.txt | more```: /etc 하위 목록을 etc.txt 와
> /tmp/etc.txt 에 저장하고 화면에소 한 페이지씩 출력
> - ex. ```$ ls -l /etc | tee etc.txt | tee /dev/pts/0 | more```: /dev/pts/0 터미널은 해당 사용자가 권한이 있어야 하고
> /dev/ 는 생략 가능하나, 콘솔 창인 /dev/tty2 등은 버전에 따라 생략하면 안될 수도 있음

- (10) **작업 제어 기능**
    - 작업을 백그라운드와 포그라운드에서 실행할 수 있으며, 이 작업을 서로 전환하여 실행할 수 있음 (프로세스 관리)

- (11) **산술 연산 기능**
    - expr 명령을 이용
    - ```$ expr 값 연산자 값```, 인자 간에 반드시 한 칸씩만 띄워야 함
    - 값 대신 미리 지정한 변수 사용 가능
    - 연산자: +, -, *, /, %
    - ex. ```$ expr 3 + 2``` >> 5 출력
    - ex. ```$ expr 3 \* 2``` >> 6 출력, 그냥 특수문자 * 는 모든 것을 의미하므로, 백슬래시가 있어야 함

- (12) **프롬프트 제어 기능**
    - 프롬프트를 변경 지정 가능. 환경 변수인 PS1 값을 이용

- (13) **확장된 내부 명령어**
    - bash 자체적으로 해석하는 set, export 등의 내부 명령어(Built-in Command)

**bash 셸 관련 파일 및 디렉토리**는 해당 설정 파일을 사용하는 사용자의 배시 셸에서 지속적으로 적용됩니다.
일시적인 환경 변수나 alias 는 로그아웃 시 사라집니다.

- /etc/profile: 시스템 전체에 적용되는 환경 변수와 시작 관련 프로그램 설정
- /etc/bashrc: 시스템 전체에 적용되는 alias 와 함수 설정
- ~/.bash_profile: 개인 사용자의 환경 설정과 시작 프로그램 설정 관련정보 존재. 로그인 시 읽어들임.
경로, 환경 변수 등의 설정이 들어있고, 사용자가 PATH 와 같은 환경 변수 수정시 사용
- ~/.bashrc: 개인 사용자가 정의한  alias 와 함수
- ~/.bash_logout: 개인 사용자가 로그아웃할 때 수행하는 설정
- /etc/profile.d: 몇몇 응용 프로그램들이 시작할 때 필요한 스크립트가 위치하는 디렉토리.
보통 /etc/profile 에서 호출. 일반 사용자의 alias 설정 등과 관련된 스크립트도 존재

**셸에서 사용하는 특수문자(메타문자, Meta Character)** 는 다음과 같습니다.

- ~: 틸드. 홈 디렉토리
- .: 현재 디렉토리 혹은 명령행 맨 앞에서 source 의 의미인데, 이는 셸 스크립트 등을 실행시킬 때 사용됨
- ..: 한 단계 위 디렉토리
- **' '**: 작은 따옴표. 모든 문자나 특수문자들을 일반문자로 취급
- **" "**: 큰 따옴표. 이것은 $, `, \ 를 제외한 모든 문자를 일반문자로 취급. !(history) 로 예외로 인정
- **`**: 역따옴표는 명령 대체 기능을 수행하는데, 명령의 결과를 대체해서 사용
- \#: 주석 기호
- **$**: 셸 변수 기호. 뒤에 오는 문자열을 변수로 취급
- &: 특정 명령을 후면 작업(background job)으로 실행
- *: 아무것도 없는 경우를 포함한 모든 문자
- ?: 보통 한 문자를 대체할 때 사용. 또한 return 변수로도 쓰이는데, 셸 상에서 내린 명령의 에러 유무를 확인 가능
- (): 부속 shell(subshell)을 뜻하는 기호. 하나의 셸 단위로 묶어줌
- **\\**: 이스케이프(escape, 탈출) 문자. 바로 다음에 오는 특수문자의 기능을 없앰. alias 를 없애기도 함
또한 긴 명령행 입력 시 라인 줄바꿈으로 연장할 때도 사용
- []: bracket 이라고 부르며, 사이에 선택할 수 있는 문자를 나열하여 '~중의 하나' 라고 표현됨.
    - ex. [abc], [.,;], [-_], [*?], [a-c], [a-z], [!0-9], [^chars], [a-zA-Z]
- {}: 사이에 제시된 문자열 중 하나로 대치
    - ex. b{ed,olt,ar}s, b{ar{d,n,k},ed}s
- <: 입력 재지정
- \>: 출력 재지정
- /: 경로명 디렉토리 분리자
- !: 명령문 history

대망의 **셸 프로그래밍(Shell Programming)** 입니다.<br>
셸 프로그래밍이란 셸에서 사용되는 여러 명령어들을 모아 하나의 파일로 만드는 과정을 말하며, 그 결과 만들어지는 파일 또는 프로그램을
**셸 스크립트(Shell Script)** 라고 합니다.

셸은 조건문, 반복문, 변수, 함수 등 기본적인 언어적 특성을 가지고 있어 프로그래밍이 가능합니다.

- **셸 스크립트를 작성하는 방법**
    1. vi 편집기로 파일 생성
    2. 첫줄은 ```#!/bin/bash``` 로 bash 셸을 사용할 것을 명시
    3. 두번째 줄부터 원하는 명령 구문 입력
    4. 스크립트를 실행 가능한 파일로 만들기 (보통 755 권한)
    5. 실행

> **셸 스크립트 실행 시..**
> 1. 해당 스크립트 파일의 절대 혹은 상대 경로를 포함하지 않으면 PATH 변수에서 찾으므로,
> './' 혹은 절대경로가 아닌 자유롭게 사용하고자 한다면 파일이 위치한 경로를 PATH 에 등록해 두어야 합니다.
> 2. 실행 권한을 부여하지 않고 실행하려면,
>     - 앞부분에 sh 명령 붙이기
>     - 앞부분에 source 명령 붙이기
>     - 앞부분에 . 붙이기 (source 와 동일)

- **셸 프로그래밍 문법**
    1. **주석**: # 를 라인 앞에 붙이면 주석 처리됨
    2. **변수**: 셸 프로그래밍에서 변수는 변수형 선언이 필요 없음. 값 할당시 공백이 있으면 안됨
        - **변수명=값**
        - ${변수명}: 변수 값으로 치환
        - ${변수명:=값}: 변수명의 값이 null 이면 지정한 값을 할당하여 저장하고, 아니라면 이미 저장된 값 사용
        - ${변수명:+값}: 기존 변수명에 값이 null 이 아니라면(이미 사용되고 있다면) 지정한 값을 사용, 하지만 저장하지는 않음 (1회 사용)
        - ${변수명:-값}: 기존 변수명에 값이 null 이 아니라면(이미 사용되고 있다면) 그 값을 사용, 아니라면 지정한 값을 대입.
        지정한 값을 저장하지는 않음
        - ${변수명:?값}: 기존에 값이 있으면 그것을 기본값으로 하고, 아니라면 error 를 내면서 지정한 값을 보여줌
        - ${#변수명}: 변수명의 문자열 길이를 반환
        - ${변수명:offset}: 변수명 값에서 offset 만큼 삭제한 후 값을 반환
        - ${변수명:offset:length}: 변수명 값에서 offset 만큼 삭제한 후 length 만큼 센 뒤 값을 반환
        - 관련 환경 변수 **'$IFS'**: 입력 필드 구분자. 보통 스페이스, 탭, 개행 문자를 사용
        - 셸 변수의 출력과 제거
            - set: 현재 정의되어 있는 모든 변수와 그 값을 출력
            - env: export 된 변수의 값만 출력
            - export: 특정 변수의 범위를 환경 데이터 공간으로 전송하여 자식 프로세스에서도 사용 가능하게 함
            - unset: 선언된 변수를 제거
        - **Argument 변수**
            - $0: 실행된 셸 스크립트명
            - $1, $2: 입력된 첫 번째와 두 번째 인자
            - $#: 입력된 인자의 개수
            - $$: 셸 스크립트의 PID
            - $*: 입력된 전체 인자를 하나의 문자열로 변수에 저장 시 사용. 구분자는 $IFS 변수의 첫 번째 문자
            - $@: $* 와 동일하나 IFS 환경 변수를 사용하지 않음 (보통 스페이스)
            - $?: 실행한 뒤의 return 값. 참이면 0, 거짓이면 1 반환
            - $-: 현재 셸이 호출될 때 사용한 옵션들
        - ex. ```$ vim test.sh```
        ```
        #!/bin/bash
        num=2
        echo "This is the ${num}nd"  # This is the 2nd 
        ```
        - ex. ```$ vim ./main```
        ```
        #!/bin/bash
        echo Shell Programming
        name=test
        city=seoul
        echo name is $name
        echo city is $city
        export name
        ./sub
        echo stop main
        ```
        ```$ vim ./sub```
        ```
        #!/bin/bash
        echo start sub
        echo name is $name
        echo city is $city
        echo stop sub
        ```
        ```$ ./main```
        ```
        # 출력 결과~
        Shell Programming
        name is test
        city is seoul
        start sub
        name is test
        city is
        stop sub
        stop main
        ```
    3. **echo 문과 escape 문자**: echo 는 라인을 제어하는 명령해석기이며, -e 옵션과 함께 \\ 로 시작하는 escape 특수문자 사용 가능
        - \\f: 폼피드(Formfeed). 앞 문자열만큼 열을 밀어서 이동시킴
        - \\n: New line 줄바꿈
        - \\r: 캐리지 리턴(Carriage Return). 앞 문자열의 앞부분부터 뒷 문자열만큼 대체하고 반환
        - \\t: 탭만큼 띄움
        - \\: \\ 표기
        - ex. ```$ echo -e "yuloje\ralin"``` > ```alinje``` 뒷 문자열만큼 치환되어 반환됨
    4. **간단한 조건식**
        - 명령행에서 ```$ test 표현식``` 형태로 간단히 비교 가능
        - 셸 스크립트에서는 if 문처럼 조건식이 사용됨. 여기서는 test 명령어 생략하고 [] 이용
        - \[ 와 ] 사이에는 반드시 조건식 외 공백문자가 들어가야 함
        - **\[ 문자열 ]**: 문자열이 빈 문자열이 아니라면 참
        - **\[ 문자열1 = 문자열2 ]**: 같다면 참
        - **\[ 문자열1 != 문자열2 ]**: 다르다면 참
        - **\[ -n 문자열 ]**: 문자열이 null(빈 문자열) 이 아니라면 참
        - **\[ -z 문자열 ]**: 문자열이 null(빈 문자열) 이라면 참
        - **\[ expr1 -eq expr2 ]**: Equal. 두 산술표현식 결과가 같다면 참
        - **\[ expr1 -ne expr2 ]**: Not Equal. 두 산술표현식 결과가 다르다면 참
        - **\[ expr1 -gt expr2 ]**: Greater Then. > 관계라면 참
        - **\[ expr1 -ge expr2 ]**: Greater Equal. >= 관계라면 참
        - **\[ expr1 -lt expr2 ]**: Less Then. < 관계라면 참
        - **\[ expr1 -le expr2 ]**: Less Equal. <= 관계라면 참
        - **\[ ! expr ]**: 결과가 참이면 거짓, 거짓이면 참
        - **\[ expr1 -a expr2 ]**: AND 연산. 둘 다 참이어야 참
        - **\[ expr1 -o expr2 ]**: OR 연산. 둘 중 하나라도 참이면 참
        - **\[ -b FILE ]**: 파일이 블록 디바이스면 참
        - **\[ -c FILE ]**: 파일이 문자 디바이스면 참
        - **\[ -d FILE ]**: 파일이 디렉토리면 참
        - **\[ -e FILE ]**: 파일이 존재하면 참
        - **\[ -f FILE ]**: 파일이 존재하고 정규 파일이면 참 (호환성 문제로 주로 -e 보다 -f 사용)
        - **\[ -g FILE ]**: 파일에 SGID 가 있으면 참
        - **\[ -k FILE ]**: 파일에 Sticky bit 가 있으면 참
        - **\[ -L FILE ]**: 파일이 심볼릭 링크면 참
        - **\[ -p FILE ]**: 파일이 Named pipe 면 참
        - **\[ -r FILE ]**: 현재 사용자가 읽을 수 있는 파일이면 참
        - **\[ -s FILE ]**: 파일이 비어있지 않으면 참
        - **\[ -S FILE ]**: 소켓 디바이스면 참
        - **\[ -t FILE ]**: File Descriptor 가 열려진 터미널이면 참
        - **\[ -u FILE ]**: 파일에 SUID 가 있으면 참
        - **\[ -w FILE ]**: Writable file. 현재 사용자가 쓸 수 있는 파일이면 참
        - **\[ -x FILE ]**: Execute file. 현재 사용자가 실행할 수 있는 파일이면 참
        - **\[ -O FILE ]**: 파일의 소유자가 현재 사용자이면 참
        - **\[ -G FILE ]**: 파일의 그룹이 현재 사용자의 그룹과 같으면 참
        - **\[ FILE1 -nt FILE2 ]**: FILE1 이 보다 새로운 파일(최근 파일)이면 참
        - **\[ FILE1 -ot FILE2 ]**: FILE1 이 보다 오래된 파일이면 참
        - **\[ FILE1 -ef FILE2 ]**: FILE1 이 FILE2 의 하드 링크, 즉 Inode 값이 같으면 참
        - ex. ```$ vim ./ex.sh```
        ```
        #!/bin/bash
        [ "$LOGNAME" = "yuloje" ]  # 로그인한 사용자가 "yuloje" 인지 확인
        echo $?
        ```
        ```$ source ./ex.sh```
        ```
        1
        ```

- **조건문**
    1. **if 문**
        - 형식1: 단일 if 문
        ```
        if [ 조건 ]
        then
            실행문장
        fi
        ```
        - 형식2: if ~ else 문
        ```
        if [ 조건 ]
        then
            실행문장1
        else
            실행문장2
        fi
        ```
        - 형식3: if ~ elif 문 (elif 는 여러 번 사용 가능)
        ```
        if [ 조건1 ]
        then
            실행문장1
        elif [ 조건 ]
        then
            실행문장2
        else
            실행문장3
        fi
        ```
        - ex. ```$ vim ./test.sh```
        ```
        #!/bin/bash
        if [ "$SHELL" - "/bin/bash" ]
        then
            echo "Your login shell is the bash (bourne again shell)"
        else
            echo "Your login shell is not bash but $SHELL"
        fi
        ```
    2. **case 문**
        - case 구문은 오른쪽 괄호와 세미콜론은 반드시 사용해야 하고, esac 로 끝내야 함
        ```
        case 문자열
        in
            정규식1) 명령어1;;
            정규식2) 명령어2;;
        ...
        esac
        ```
        - ex. ```$ vim ./ca1```
        ```
        #!/bin/bash
        echo "1. who 2. date 3. pwd 4. ls -l
        echo "******************************"
        echo "수행하고자 하는 명령어는? (번호를 입력하시오)"
        read number;
        case $number in
            1) who;;
            2) date;;
            3) pwd;;
            4) ls -l;;
            *) echo "없는 번호입니다."
        esac
        ```
    3. **select 문**
        - select 구문은 다른 셸에는 없고 Korn Shell 및 Bash 에만 존재하는 구문으로 간단히 나열할 때 사용
        - in 다음에 나오는 값들이 항목으로 된 메뉴로 생성됨. 생략되면 "$@" 가 됨
        - 형식은 번호를 선택하게 되어 있으며, 사용자에게 번호를 표시해줌
        - "변수" 에 선택된 내용을 저장하고 선택된 번호는 내장 변수인 REPLAY 에 저장하고 "실행문장" 이 실행됨
        ```
        select 변수 in 값1, 값2, ...
            do
                실행문장
            done
        ```
        - ex. ```$ vim ./sele1```
        ```
        #!/bin/bash
        echo "What is your favorite OS?"
        select var in "Linux", "Free BSD", "Windows", "Solaris", "Other"
            do
                echo "You have selected $var."
                break
            done
        ```
        - ```$ ./sele1```
        ```
        What is your favorite OS?
        1) Linux
        2) Free BSD
        3) Windows
        4) Solaris
        5) Other
        #? 1
        You have selected Linux.
        ```

- **반복문**
    1. **for 문**
        -  in 다음에 지정된 범주나 값들이 순차적으로 "변수" 에 담겨 do 이하의 문장 수행
        ```
        for 변수 in 값1, 값2, ...
            do
                실행문장
            done
        ```
        - ex. ```$ vim ./tt4```
        ```
        #!/bin/bash
        for flower in Rose Tulip Lily
            do
                echo $flower
            done
        ```
        - ```$ ./tt4```
        ```
        Rose
        Tulip
        Lily
        ```
    2. **while 문**
        - "조건문" 동안 do 이하의 문장이 실행됨
        ```
        while 조건문
            do
                실행문장
            done
        ```
        - ex. ```$ vim ./tt7```
        ```
        #!/bin/bash
        var=1
        while [ "$var" -le 5 ]
            do
                echo $var
                var=`expr $var + 1`
            done
        ```
        - ```$ ./tt7```
        ```
        1
        2
        3
        4
        5
        ```
    3. **until 문**
        - until 문은 while 문과 동일한 효과이지만 조건이 반대임. 즉, 조건이 거짓일 동안 루프 수행
        ```
        until 조건문
            do
                실행문장
            done
        ```
        - ex. ```$ vim ./tt9```
        ```
        #!/bin/bash
        COUNTER=20
        until [ $COUNTER -lt 10 ]
            do
                echo COUNTER is $COUNTER
                COUNTER=`expr $COUNTER - 1`
            done
        ```
        - ```$ ./tt9```
        ```
        COUNTER is 20
        COUNTER is 19
        COUNTER is 18
        COUNTER is 17
        ...
        COUNTER is 11
        COUNTER is 10
        ```

- **함수**
    - 명령어 그룹을 메모리 내에 정의하여 수행 속도를 향상시킴
    ```
    함수 이름()
    {
        command
    }
    ```
    ```
    function 함수 이름
    {
        command
    }
    ```
    - ex. ```$ vim ./fun```
    ```
    #!/bin/bash
    user_print()
    {
        echo "shell programming"
    }
    echo "start user_print""
    user_print
    echo "end user_print"
    ```
    - ```$ ./fun```
    ```
    start user_print
    shell programming
    end user_print
    ```

- **패턴과 패턴 비교**
    - 일종의 문자열 연산. 특정 패턴을 놓고 변수의 문자열 값이 일부분이라도 일치하는지 검사할 때 사용
    - 이 패턴에는 와일드카드 문자(*, ?, \[, ] 를 포함한 문자 세트)를 포함해도 됨
    - 종류
        - **${변수#패턴}**: 처음부터 패턴과 맞는 변수 부분을 찾아 이 중 가장 작은 부분을 제거하고 나머지 반환
        - **${변수##패턴}**: 처음부터 패턴과 맞는 변수 부분을 찾아 가장 큰 부분을 제거하고 나머지 반환
        - **${변수%패턴}**: 끝에서부터 패턴과 일치하는 변수의 최소 부분을 제거하고 나머지 반환
        - **${변수%%패턴}**: 끝에서부터 패턴과 일치하는 변수의 최대 부분을 제거하고 나머지 반환
    - ex. ```$ vim ./ex3```
    ```
    #!/bin/bash
    unset var1
    echo ${var1:-string2}  # var1 이 null 이기 때문에 string2 출력
    var1=string1
    echo ${var1:-string2}  # var1 이 null 이 아니기 때문에 할당된 string1 출력
    var1=/etc/sysconfig/network
    echo ${var1#*/}  # 패턴(*/)과 맞는 부분을 찾아 가장 작은 부분을 제거하고 출력 > etc/sysconfig/network
    echo ${var1##*/}  # 패턴(*/)과 맞는 부분을 찾아 가장 큰 부분을 제거하고 출력 > network
    var2=/etc/sysconfig/network-scripts/sysconfig/ifcfg-lo
    echo ${var2%sysconfig*}  # 뒤에서부터 패턴(sysconfig*)과 맞는 부분을 찾아 최소 부분을 제거하고 출력 > /etc/sysconfig/network-scripts/
    echo ${var2%%sysconfig*}  # 뒤에서부터 패턴(sysconfig*)과 맞는 부분을 찾아 최대 부분을 제거하고 출력 > /etc/
    exit 0
    ```
    - ```$ ./ex3```
    ```
    string2
    string1
    etc/sysconfig/network
    network
    /etc/sysconfig/network-scripts/
    /etc/
    ```

### 프로세스

- **프로세스(Process)의 정의**
    - 하드디스크에 설치된 프로그램들을 실행하면 메모리(RAM)에 적재됨
    - 이렇게 실행 중인 프로그램을 프로세스라 하며, 아이디가 부여됨 (PID, Process ID)
    - 백그라운드 프로세스와 포그라운드 프로세스가 있음

- **프로세스의 생성**
    - **fork** 는 새로운 프로세스를 위해 메모리를 할당받아 복사본 형태의 프로세스를 실행하는 형태. 기존의 프로세스는 그대로 실행되어 있음
    - **exec** 는 원래의 프로세스를 새로운 프로세스로 대체하는 형태. 기존 프로세스의 메모리에 새 프로세스의 코드를 덮어씌움

리눅스가 부팅을 시작하면 커널이 init 이란 최초의 프로세스를 발생시키고 PID 1번을 할당받습니다.
이후 시스템 운영에 필요한 데몬을 비롯한 다른 프로세스들은 자식 프로세스 **fork** 방식으로 생성됩니다.

```pstree``` 명령으로 확인해 보면 부모-자식 구조로 나타납니다.

보통 명령어는 **fork** 형태로 수행됩니다.
사용자가 로그인하면 bash 프로세스가 할당되고, 명령어를 내리면 **fork** 형태로 수행됩니다.

반면 명령어 앞에 **exec** 를 붙이면 기본 프로세스가 교체되면서 새 프로세스가 할당됩니다.

- **프로세스의 종류**
    - foregroud
        - 셸에서 명령을 실행하면 해당 프로세스가 종료될 때까지 기다림
        - 보통 완료되면 프롬프트가 다시 나타남
    - background
        - 실행된 프로세스의 종료를 기다리지 않고 다른 작업 가능. 백단에서 수행됨
        - 명령 구문 맨 뒤에 **'&'** 를 추가하여 실행

- **멀티태스킹(Multi-tasking)과 작업 전환**
    - 여러 백그라운드 프로세스와 하나의 포그라운드 프로세스를 다중 실행 가능
    - 모든 프로세스는 중간에 중지 가능
    - 백 <-> 포 간 전환 가능

> **포그라운드 프로세스와 백그라운드 프로세스 간 전환하기**
> - ```CTRL + z``` 로 메모리에 적재된 포그라운드 프로세스를 대기(suspend)시킨 후,
> - ```bg``` 명령을 입력하여 백그라운드 프로세스로 전환!
> - ```jobs``` 명령으로 현재 상태 확인 가능 (Stopped, Running, ...)
> - 이와 유사한 방식으로 백그라운드를 포그라운드로 전환하기 위해서는, 먼저 ```jobs``` 로 작업 번호를 확인하고, ```fg %작업번호```
> 명령을 입력!
> - ```jobs``` 확인시 '+' 표시가 붙어있는 프로세스가 주로 처리되는 프로세스, 보통은 마지막에 실행한 프로세스인데, 작업번호 없이
> ```fg``` 명령을 입력하면 이 작업이 포그라운드로 전환됨
> - '-' 가 붙은 작업은 '+' 다음 우선순위 작업임

- **시그널(Signal)**
    - 프로세스끼리 통신할 때 사용됨. 특정 프로세스가 다른 프로세스로 신호를 보낼 때
    - 각 시그널에는 이름이 있고, 번호로 관리됨. ```kill -l``` 로 목록을 확인
    - 종류
        - **SIGHUP(HUP)**: 1번. Hangup 의 약어. 로그아웃 등 터미널 접속이 끊길 시 보내지는 시그널. 데몬 관련 환경설정파일을 변경하고
        변화된 내용을 적용하기 위해 재시작시 사용됨
        - **SIGINT(INT)**: 2번. 키보드로부터 오는 인터럽트 시그널. 실행을 중지시킴 (CTRL + c)
        - **SIGQUIT(QUIT)**: 3번. 키보드로부터 오는 실행 중지 시그널 (CTRL + \)
        - **SIGKILL(KILL)**: 9번. 무조건 종료. 프로세스 강제 종료
        - **SIGTERM(TERM)**: 15번. Terminate 의 약자로 가능한 정상 종료. ```kill``` 커맨드릐 기본 시그널임
        - **SIGCONT(CONT)**: 18번. Continue 의 약자로 **STOP** 시그널로 정지된 프로세스를 다시 실행시킬 때 사용
        - **SIGSTOP(STOP)**: 19번. 터미널에서 입력된 정지 시그널
        - **SIGTSTP(TSTP)**: 20번. 실행 정지 후 다시 실행을 계속하기 위해 대기시키는 시그널 (CTRL + z)

**데몬(Daemon)** 이란 주기적이고 지속적인 서비스 요청을 처리하기 위한 프로세스로, 백그라운드로 실행됩니다.
리눅스에서는 보통 서버 역할을 하는 프로그램들이 이에 해당합니다. (이름 뒤에 'd' 를 붙임. httpd, systemd 등등)

이러한 데몬 프로세스를 실행하는 방법에는 **standalone** 방식과 **inet** 방식이 있습니다.

- 데몬 프로세스 실행
    - **standalone** 방식: 부팅 시 실행되어 메모리에 계속 상주. 웹, 메일 등 빈번한 요청 처리 프로세스
    - **inet** 방식: 메모리에 항상 상주하는 것이 아니라 클라이언트 요청에 따라 관련 프로세스를 실행시켰다가 접속 종료 후 종료.
    자주 사용되지 않는 서비스에 대한 효율적 메모리 관리에 유용
    - 리눅스 커널 2.2 버전까지는 inetd 데몬이 이러한 서비스를 관리, 2.4 버전부터는 xinetd 데몬이 수행함

데몬 프로세스는 System V 계열에서 사용하는 각 실행 레벨(런레벨)에 따른 제어 방식을 사용합니다.
부팅 관련 정보는 **/etc/rc.d** 디렉토리에 모아두고, 관련 데몬들은 **/etc/rc.d/init.d** 디렉토리와 **rc0.d ~ rc6.d**
디렉토리를 이용하여 데몬의 실행을 조절합니다.

- **/etc/rc.d/init.d 디렉토리**
    - 시스템에서 제공되는 서비스 관련 스크립트를 포함
    - 기본 형식으로 **start 와 stop, restart, status, reload** 등의 인자 중 하나만 이용하여 서비스 동작을 제어
    - ex. **/etc/rc.d/init.d/httpd** 는 웹서버 데몬을 안전하게 시작하거나 중지하는 스크립트임
    - **restart** 는 중지 후 시작, **reload** 는 중지하지 않고 환경 설정만 다시 읽어들임

- **rc0.d ~ rc6.d 디렉토리**
    - 

### 1-3. 네트워크의 이해

### 네트워크의 기초

### 네트워크 설정

### 기출 예상문제

<br><br>
## 2. 리눅스 시스템 관리


<br><br>
## 3. 네트워크 및 서비스의 활용


<br><br>
## 4. 기출 및 부록 정리
