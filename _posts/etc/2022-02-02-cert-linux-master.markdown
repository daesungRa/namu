---
title:  "[자격증] 리눅스 마스터 1급 준비하기"
created:   2022-02-02 18:08:00 +0900
updated:   2022-02-02 18:08:00 +0900
author: namu
categories: etc
permalink: "/etc/:year/:month/:day/:title"
image: https://media.vlpt.us/images/may_soouu/post/11a98732-df94-4e66-94d4-033634093313/linux.png
image-view: true
image-author: 개벨로그
image-source: https://velog.io/@may_soouu/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0
---

<br>
## 시험 안내

**리눅스 마스터**는 리눅스 기반의 Desktop 활용 및 Server 운영 능력, 리눅스 시스템의 설계 개발 및 관리 능력,
리눅스 기반의 네트워크 및 서버 구축/운영 능력을 검정하는 자격시험입니다.

그 중 1급 시험의 목적은 다음과 같습니다.

- **1급**
    - 지식: 고도의 리눅스 활용능력에 대한 이해도 평가
    - 기능: 리눅스를 안전하고 효율적으로 운영하기 위한 실무 기능 평가

이 시험은 **1차시**에서
**(1) 리눅스 실무의 이해(20%)**, **(2) 리눅스 시스템 관리(40%)**, **(3) 네트워크 및 서비스의 활용(40%)** 비중의 사지선다 필기 100문항,
**2차시**에서 **단답 및 서술식 필기 10문항**, **실기(60%) 5~7문항**으로 구성됩니다.

이번 글은 해당 시험을 너무 깊게 파기보다는 전체적인 이론의 맥락을 짚어보거나 몰랐던 부분을 정리하는 수준에서 작성하고자 합니다.
자격증 시험의 특성상, 이론보다는 기출문제를 통해 공부하는 것이 더 효율적이기 때문입니다.

<br><br>

---

### 목차

1. [리눅스 실무의 이해](#1-리눅스-실무의-이해)
2. [리눅스 시스템 관리](#2-리눅스-시스템-관리)
3. [네트워크 및 서비스의 활용](#3-네트워크-및-서비스의-활용)
4. [기출 및 부록 정리](#4-기출-및-부록-정리)

### 참조

- <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62844304" target="_blank">
리눅스 마스터 1급 정복하기 (2018, 북스홀릭)</a>

---

<br><br>
## 1. 리눅스 실무의 이해

### 1-1. 리눅스의 개요

### 운영체제의 개요

**운영체제**는 **컴퓨터 하드웨어와 컴퓨터 사용자 간의 매개체 역할을 하는 시스템 소프트웨어**입니다.

- 좁은 의미: 하드웨어와 응용 프로그램 간의 다리 역할하는 커널(Kernel)
- 넓은 의미: 커널 포함 미들웨어, 응용 프로그램 실행 환경과 사용자 인터페이스 프레임워크 모두 포괄

- **운영체제의 주목적**: 컴퓨터 시스템을 편리하게 이용하고, CPU, 주기억장치, 입출력장치 등의 컴퓨터 하드웨어를 효율적으로 관리하는 데 있음

초기 운영체제는 사용자 편의성을 고려하지 않았으나(효율적 자원 관리에 치중), 대중화가 진행되며 편리함과 친근함의 형태로 변화되었습니다.
이러한 것이 GUI 기반의 윈도우 OS 입니다.

GUI 기반 윈도우 OS 에서는 명령어 기반이 아닌 아이콘 이미지 클릭 방식을 지원합니다.

하지만 현재는 **유휴 자원의 효율적 활용**을 위해 가상화 기술을 OS 에서 기본적으로 내장하거나 커널 단에서 지원하고 있습니다.

또한 스마트폰이나 태블릿 전용 모바일 운영체제, 웹 브라우저 전용 OS 도 탄생되었습니다.

- **운영체제의 주요 역할**
    - 컴퓨터의 하드웨어 제어
    - 작업의 순서를 정하며, 입출력 연산을 제어
    - 프로그램의 실행 제어, 데이터와 파일의 저장을 관리
    - 사용자들 간의 하드웨어 자원 공유 제공
    - 시스템 자원을 스케줄링하여 효율적으로 활용
    - 입출력을 쉽게 하는 기능 제공
    - 응용 프로그램의 작성과 실행을 편리하게 함
    - 오류의 발생을 막고 복구를 지원
    - 데이터의 조직화, 네트워크 통신 처리 기능 수행
    - 편리한 사용자 인터페이스 제공

- **최근 운영체제의 주요 특징**
    - 다중 사용자 시스템(Multi-User System)
    - 다중 작업 시스템(Multi-Tasking System)
    - 강력한 네트워크 지원
    - 편리한 사용자 인터페이스 지원
    - 계층적 파일 시스템 운영
    - 가상 메모리 지원
    - 고성능의 프로세서에 최적화
    - 개방형 운영체제화
    - 뛰어난 이식성 지원
    - 가상화 기술 지원

- **운영체제의 역사**
    - 40년대: 초기전자식 디지털 컴퓨터
        - 운영체제가 없음
        - 단순한 기계적인 스위치에 의존
    - 50년대: 단순순차처리
        - 한 번에 오직 하나의 작업만 수행
        - 단일 흐름 일괄 처리
    - 60년대: 다중프로그래밍
        - 멀티프로그래밍, 멀티프로세싱 개념 대두
        - 시분할 처리 개념 대두
        - 데이터 통신 지원
    - 70년대: 다중 모드 시분할
        - 일괄처리, 시분할 및 실시간처리의 보편화
        - 범용 시스템 개념 도입
    - 80년대: 분산네트워크
        - 각종 응용 프로그램 개발
        - 데이터베이스 활용 확대
        - 네트워크 기반으로 한 서버/클라이언트 모델 확대
        - 운영체제 기능들이 하드웨어에 포함된 펌웨어(Firmware) 개념 대두
    - 90년대: 병렬계산과 분산계산
        - 중앙집중식이 아닌 분산으로 발전
        - PC용과 서버용 운영체제의 보편화
    - 2000년대 ~ 현재: 모바일 및 임베디드
        - 네트워크 기반의 분산 및 병렬 운영체제의 보편화
        - 스마트폰, 태블릿 등의 모바일 장치와 가전제품을 위한 모바일 및 임베디드 운영체제의 보편화
        - 다양한 기능, 확장성과 호환성 극대화
        - 다양한 통신망의 확대와 개방형 시스템 발달
        
다음은 리눅스의 특징입니다.

- **리눅스의 특징**
    - 1) 다중 사용자 및 다중 처리 시스템(Multi-User and Multi-Tasking)
    - 2) 완전히 공개된 시스템
        - 커널 및 대부분의 응용 프로그램 소스가 공개됨
    - 3) 뛰어난 네트워크 환경
        - 이더넷(Ethernet), SLIP, PPP, ATM 등의 환경
        - TCP/IP, IPX, AppleTalk 등 프로토콜 지원
    - 4) 다양한 파일 시스템 지원
        - 프로그램과 자료를 저장하기 위해 리눅스 고유 파일 시스템인 ext2, ext3, ext4 등 사용
        - 고유 파일 시스템뿐 아니라 다른 파일 시스템도 지원 > FAT, FAT32, NTFS, ISO 9660, HPFS, SCO 제닉스 등
        - 시스템 다운 시 즉시 복구할 수 있는 저널링 파일 시스템 지원 > ReiserFS, XFS, JFS 등
        - 네트워크 파일 시스템 지원 > SMB, CIFS, NFS, NCPFS 등
    - 5) 뛰어난 이식성
        - 약간의 어셈블리과 대부분의 C언어
    - 6) 유연성과 확장성
        - 유닉스 표준인 POSIX를 준수
        - 공개용 유닉스 프로그램들은 원시코드 접근이 용이하고 다른 시스템에 이식 및 자유로운 배포 가능
    - 7) 뛰어난 안정성과 보안성
        - 공개된 리눅스 커널은 폐쇄된 Windows 에 비해 보안상의 취약점 노출 가능성은 높지만
        - 수많은 전문가들에 의해 빠르게 오류 수정 및 보안 패치가 발표되고 있음
    - 8) 우수한 가격대 성능비
        - PC급 서버에서도 엔터프라이즈급의 성능 발휘
    - 9) 다양한 응용 프로그램의 제공
        - 커널을 비롯, 셸과 기본 명령어, X Window 시스템(Xorg, KDE, GNOME 등의 GUI), vi 등의 편집기(emacs), 웹, 메일, FTP 등
        - 개발 도구 지원(C, C++, Java, Python), 보안 도구(nmap, tcpdump), 게임 등
    - 10) 다양한 배포판의 존재
        - 서버, 개발용, PC용 등 다양한 목적의 배포판
        - RedHat, Debian, Ubuntu, SUSE, 한컴리눅스, SULinux 등
        - 상용 및 무료 배포판

- **리눅스의 단점**
    - 1) 기술지원의 부족
        - 대부분 비상업적 제품들이라 전세계 개발자들이 일일히 기술지원이 불가
    - 2) 특정 하드웨어에 대한 지원 부족
    - 3) 사용자의 숙련된 기술 요구됨
        - 아직 중요한 설정은 명령어를 입력하거나 관련 환경 설정 파일을 편집기를 사용해 수정해야 함

- **리눅스의 기술적인 특징**
    - 1) 계층적인 파일 구조
        - /(root) 기준으로 하위로 가지를 뻗어나가는 트리 구조(usr, var, bin 등)
    - 2) 장치의 파일화
        - 하드디스크, 키보드, 프린터, 화면출력장치 등의 디바이스까지도 모두 파일화하여 사용
        - 해당하는 장치 (실행 혹은 설정) 파일에 명령을 내리는 방식
    - 3) **가상메모리 사용**
        - Virtual Memory 란 하드디스크의 일부를 메모리처럼 사용하는 것을 말함
        - 이곳에는 임시 데이터가 저장되고, RAM 은 작업공간으로 사용
        - RAM 부족 시 큰 프로그램은 실행할 수 없는데, 이를 극복하는 데 가상메모리가 사용됨
        - 이러한 영역을 **스왑(SWAP)** 이라고 함
    - 4) 동적 라이브러리 지원
        - 프로그램 특정 기능을 하는 루틴들을 모아 놓은 것을 라이브러리라 함
        - 개발 시 라이브러리 중 필요한 루틴들을 받아서 링크(Link) 시킴
        - 컴파일 시 프로그램에 들어가는 정적 라이브러리에 비해, 동적 공유 라이브러리는 실행 파일에 들어가지 않고 프로그램 실행 시
        가져다 사용하므로 메모리 효율성이 아주 높음
    - 5) 가상 콘솔
        - Virtual Console 은 하나의 모니터를 장착한 시스템에 여러 개의 가상 화면을 제공
        - 기본 6개의 가상 콘솔 제공 > CTRL + ALT + F1~F6
    - 6) 파이프(Pipe, '|')
        - 프로세스의 통신을 위해 도입
        - 어떤 프로세스의 표준 출력이 다른 프로세스의 표준 입력으로 쓰이게 함
    - 7) 리디렉션(Redirection)
        - 어떤 프로세스의 입/출력을 표준 입출력이 아닌 다른 입출력으로 변경할 때 사용됨
        - 출력 결과를 파일로 저장하거나 파일의 내용을 프로세스의 입력으로 사용

> **스와핑(Swapping)**
> - 메모리에 프로그램들이 많이 올라와 공간이 꽉 찼다고 하더라도 가상메모리를 설정하면 추가로 새로운 프로그램을 실행시킬 수 있게 됩니다.
> 이것은 메모리에 올라와 있지만 사용하지 않고 있는 프로그램을 하드디스크에 설정된 가상메모리 공간으로 보내고 그 빈 공간에 새로운 프로그램을
> 로딩하기 때문입니다. 또한 가상메모리에 있는 내용을 사용하려면 다시 메모리로 올리고, 그 대신에 메모리에 있던 다른 내용이 하드디스크에 저장됩니다.
> 이처럼 메모리와 하드디스크 사이의 데이터 교환을 스와핑이라고 합니다.
>
> **스왑의 확인**
> - 설치 후 스왑 용량의 확인은 메모리 확인 명령어린 free 를 사용합니다. 기본 블록 단위로 출력되므로 -m 옵션을 사용하면 MB 단위로 확인합니다.
> ```text
> ~$ free -m
>         total   used    free    shared  buffers cached
> Mem:    1006    715     291     0       6       326
> Swap:   2047    0       2047
> ```

다음으로 **운영체제의 종류**에 대해 살펴봅시다.

현재 운영체제는 사용 환경에 따라 크게 **서버, 데스크톱, 모바일 및 임베디드, 기타 분야**로 분류할 수 있습니다.

특히 **모바일 운영체제**인 안드로이드나 iOS는 휴대폰, PDA, 스마트폰, 태블릿 뿐만아니라 스마트 TV, 가전제품,
자동차에 내장되는 IVI(In-Vehicle Infotainment)까지 영역을 확대하고 있어 임베디드 운영체제 영역과의 경계가 모호해지고 있습니다.

**기타 분야**에서 웹 기반 운영체제(Web-based Operation System, 이하 Web OS)로써 구글의 크롬 OS가 등장했습니다.

주요 서버 및 데스크톱 운영체제는 다음과 같습니다.

**1) 유닉스(UNIX)**

유닉스의 특징으로는 **다중 사용자(Multi-User) 및 다중 작업(Multi-Tasking)** 지원, 강력한 네트워크 지원, 뛰어난 이식성 및 확장성,
계층적 파일 구조, 가상 메모리 및 공유 라이브러리 지원 등이 있습니다.

- 1969년 미국 AT&T 사의 벨(Bell) 연구소의 연구원 켄 톰슨(Ken Tompson) 및 데니스 리치(Dennis Ritchie)에 의해 만들어짐
- 이후 AT&T는 무료로 여러 연구소 및 대학교에 OS와 소스를 보급하여 여러 버전의 유닉스 등장
- 대표적으로 **System V 계열**과 **BSD 계열**
    - System V 계열: (주로 상업적) IBM, HP, Sun Microsystem, SGI
    - BSD 계열: (주로 오픈소스) NetBSD, FreeBSD, OpenBSD, SunOS, NextStep, Mac OS X, GNU/Linux

**2) 윈도(Windows)**

- 1975년 빌 게이츠(Bill Gates)와 폴 앨런(Paul Allen)이 설립한 마이크로소프트(Microsoft)
- 1982년 MS-DOS 는 IBM PC 호환기종용으로 출시됨
- 1994년 MS-DOS 6.2 버전까지 출시
- 1995년 본격적인 GUI 기반 운영체제인 Windows 95, 이후 Windows 98, Windows ME
- Windows XP 부터는 MS-DOS 가 사라짐

**3) Mac OS X**

...

- Mac OS X 은 Mac OS 의 열 번째 버전이라는 의미였지만, OS X 가 하나의 상품명으로 자리잡음
- BSD 유닉스 기반으로 만든 '넥스트스텝' 을 확장하여 만든 것으로, 결국 유닉스 기반 운영체제라고 볼 수 있음

**4) 모바일 운영체제**

모바일 운영체제는 기본적으로 데스크톱용 윈도우, 맥, 리눅스와 같은 운영체제와 비슷하나 모바일 장치 및 환경적 특성에 적합하도록 설계되었습니다.

- 배터리 사용 최적화
- PC에 비해 상대적으로 낮은 사양
- 무선 기반 광대역 및 지역 연결 특화
- 다양한 멀티미디어 지원
- 커널, 하드웨어 드라이버, 미들웨어, 응용 프로그램 실행 환경, 사용자 인터페이스 프레임워크 등 제공

모바일 운영체제는 TV나 자동차 영역까지 확대되었습니다.

**5) 리눅스 기반 모바일 운영체제**

리눅스는 BSD 계열의 유닉스 수정본입니다.

- **구글의 안드로이드(Android)**
    - 리눅스 커널 위에서 동작하는 대표적인 운영체제
    - 다양한 C/C++ 라이브러리 포함
    - 자바 언어로 작성된 응용 프로그램 구동 > 달빅(Dalvik) 가상 머신으로 프로그램을 별도의 프로세스로 실행
    - 2005년 구글이 안드로이드사를 인수하면서 대세가 됨
    - 50여만 개의 다양한 애플리케이션을 제공하는 안드로이드 생태계
    - iOS 에 비해 개발 진입장벽이 낮음
    - [단점] 오픈소스로 인한 보안상의 취약점
    - [단점] 다수의 하드웨어로 통일성이 떨어짐, 안정성 확보 어려움
- 바다(Bada) OS, 마에모(Maemo), 모블린(Moblin), 미고(MeeGo), 리모(LiMo), 타이젠(Tizen)

**6) 스마트 TV**

스마트 TV 란 운영체제를 탑재하고 TV 본연의 기능인 실시간 방송 시청뿐만 아니라 인터넷 접속 기능을 기반으로 웹 검색, VOD, 게임, SNS, 앱스토어
등의 기능이 가능한 TV 를 말합니다.

스마트 TV 는 기본적으로 모바일 기기와 동일한 운영체제를 탑재합니다.

애플은 iOS, 구글은 안드로이드, 삼성전자는 바다OS 혹은 타이젠, LG 전자는 자체 넷캐스트 OS(또는 Web OS)

**7) IVI(In-Vehicle Infotainment)**

IVI 는 ICE(In-Car Entertainment) 라고도 하며, 자동차 내에서 다양한 편의 기능과 오락시설을 제공하는 것이 목적입니다.

- MS 의 Windows Embedded Automotive, QNX, GENIVI, 안드로이드, MeeGo/Tizen IVI

**8) 웹 운영체제**

2000년대 초반의 웹 OS(제1세대형) 는
"인터넷 기반의 운영체제로 인터넷 접속이 가능한 곳이라면 언제 어디서나 자신의 데스크톱을 사용하는 것과 같은 환경을 제공하는 서비스"를 의미했습니다.

따라서 기존의 윈도우나 리눅스 등에서 웹 브라우저를 호출하여 인터넷 접속으로 개인 데스크톱을 활성화합니다.
이곳에 로그인 후 생성한 파일이나 애플리케이션은 유저의 하드웨어가 아닌 웹 서버에 저장됩니다.

최근의 웹 OS(제2세대형) 는 "웹 브라우저를 기반으로 동작하는 가상의 운영체제"의 개념으로 진화했습니다.
사용자는 별도 OS 설치과정 없이 경량화된 최소 크기의 커널 위에서 웹 브라우저를 통해 서비스 제공자 웹 사이트에 접속하여 다양한 서비스를 이용합니다.

최근에는 클라우드 컴퓨팅 서비스와 결합하여 더 강력해졌습니다.
대표적으로 구글의 크롬 OS가 있습니다.

- 어디서나 동일한 작업 환경
- 데이터는 사용자의 하드디스크가 아니라 원격지나 클라우드에 저장
- 네트워크가 지원되는 환경이라면 어디서든지 빠르게 사용
- 크롬 웹 스토어를 통해 사용자가 일부 프로그램을 설치하도록 지원
- 높은 보안성 제공

### 리눅스 기초

**리눅스의 철학**은 다음과 같습니다.

- **상용 유닉스**
    - 기업의 엄격한 통제 및 계획 아래서 진행, 개발자가 임의로 기능 추가 수정할 수 없음
- **리눅스**
    - 엄격한 정책 하에 이루어지지 않고, 인터넷 연결된 전 세계 개발자 그룹들의 기여를 통해 발전하므로
    - 리눅스 시스템을 통합적으로 책임지고 개발하는 어떠한 조직이나 기업체가 존재하지 않음
    - 리눅스 공동체는 다양한 메일링 리스트, 유즈넷 뉴스그룹 등을 통해 소통
    - 리눅스 커널은 최초 개발자인 리누스 토발즈 주도하에 발전됨
- **GNU**
    - 'GNU is Not Unix' 의 재귀적 용법
    - 유닉스와 호환이 되면서도 유닉스와는 다르게 자유 소프트웨어로 만들어졌음
    - 리처드 스톨먼을 주축으로 자유로운 소프트웨어를 희망하던 공동체들이 가장 먼저 운영체제인 유닉스를 모태로 개발을 시작하면서 탄생
    - GNU C 컴파일러인 gcc뿐 아니라 emacs, GNOME, GNU tar, bash, GRUB 등 응용 프로그램 만들어짐
- **FSF(Free Software Foundation) 와 자유 소프트웨어**
    - 자유 소프트웨어 재단은 1985년 리처드 스톨먼이 세운 비영리 조직
    - 무료나 공짜가 아니라 자유(Free), 즉 '구속되지 않는다' > 프로그램의 변경이나 수정의 자유
    - 즉, 규칙을 지키기만 하면 변경, 수정, 추가 배포 등이 자유로움
- **카피레프트(Copyleft)와 GNU GPL(General Public License)**
    - 카피레프트는 저작권을 뜻하는 카피라이트(Copyright)의 반대 의미
    - 개작된 프로그램에 대한 배포상의 제한조건이 별도로 없다면 모든 사람에게 허용(사적 소유 > 공적 소유)
    - GNU GPL 은 카피레프트를 실제 구현한 라이선스

> **자유 소프트웨어**
> 1. 목적에 상관없이 프로그램을 실행시킬 수 있는 자유
> 2. 프로그램이 어떻게 동작하는지 학습하고, 필요에 따라서 프로그램을 개작할 수 있는 자유(실제로 소스코드 이용 가능해야 함)
> 3. 무료 또는 유료로 프로그램을 재배포할 수 있는 자유
> 4. 프로그램을 개선시킬 수 있는 자유와 개선된 이점을 공동체 전체가 누릴 수 있도록 발표할 수 있는 자유

**주요 라이선스**는 다음과 같습니다.

- **GPL(General Public License)**
    - FSF 의 창시자인 리처드 스톨먼이 GNU GPL 에서 다섯 가지 의무를 저작권의 한 부분으로 강제
    1. 컴퓨터 프로그램은 어떠한 목적으로든지 사용할 수 있다. 다만 법으로 제한하는 행위는 할 수 없다.
    2. 컴퓨터 프로그램의 실행 복사본은 언제나 프로그램의 소스 코드와 함께 판매하거나 소스 코드를 무료로 배포해야 한다.
    3. 컴퓨터 프로그램의 소스 코드를 용도에 따라 변경할 수 있다.
    4. 변경된 컴퓨터 프로그램 역시 프로그램의 소스 코드를 반드시 공개 배포해야 한다.
    5. 변경된 컴퓨터 프로그램 역시 반드시 똑같은 라이선스인 GPL 라이선스를 적용해야 한다.

> **GPLv1**
> - 1989년 1월 발표, 사람이 이해하기 쉬운 코드를 같이 배포해야 한다는 조건 추가
>
> **GPLv2**
> - 1991년 6월 발표, 특허로 인해 소스코드 공개가 불가능한 경우 실행 바이너리 프로그램까지 배포할 수 없도록 보완
>
> **GPLv3**
> - 2007년 6월 발표, 소프트웨어 특허 대처법, 다른 라이선스와의 호환성, 원시 코드 구성 부분, 디지털 제한 권리 관련 내용 추가

- **LGPL(Library/Lesser General Public License)**
    - 1991년 6월, 리처드 스톨먼에 의해 GPL 라이선스의 강력한 카피레프트 조건과 단순한 사용 허가를 위한 절충안 발표
    - 주로 소프트웨어 라이브러리에 사용되어 자유 소프트웨어뿐 아니라 독점 소프트웨어에서도 사용 가능하도록 됨
    - 하지만 LGPL 적용 소스 코드 수정시 2차적 파생물 저작물에 해당하므로 라이브러리 소스 코드를 반드시 제공해야 함

- **BSD(Berkeley Software Distribution)**
    - 버클리의 캘리포니아 대학에서 배포하는 공개 소프트웨어 라이선스
    - 누구나 개작 가능, 수정본 배포 가능. 의무적 재배포 사항이 없어 원시 소스코드 비공개 허용. 상용 사용 가능

- **아파치(Apache)**
    - 아파치 소프트웨어 재단에서 자체적으로 만든 소프트웨어에 대한 라이선스 규정
    - 누구든 아파치 소프트웨어의 부분 혹은 전체를 개인적, 상업적 목적으로 이용 가능
    - 재배포 시 아파치 라이선스 2.0 소프트웨어임을 명확히 밝히면 수정한 소스 코드를 반드시 포함시키지 않아도 됨
    - 대표적으로 Apache HTTP Server, Hadoop, Hbase, Tomcat 등

- **MPL(Mozilla Public License)**
    - 모질라 재단에서 규정한 라이선스로 BSD 와 GPL 의 혼합적 성격
    - 수정 시 소스 코드 공개는 필수이지만 MPL 소스를 제외한 소스는 공개하지 않아도 됨

- **MIT(Massachusetts Institute of Technology)**
    - 미국 MIT 대학의 BSD 기초한 라이선스
    - 라이선스와 저작권 관련 명시만 지키면 됨
    - X Window System, JQuery, Node.js 등

**리눅스의 역사**는 다음과 같습니다.

1987년 개발된 교육용 유닉스인 미닉스를 토대로 1991년 리누스 토발즈가 POSIX 에 호환되는 운영체제 커널을 만들 목적으로 리눅스 개발했습니다.
리눅스는 0.02 버전을 10월에 공식 발표한 이후로 전 세계 개발자들의 도움으로 발전했습니다.

초기 리눅스는 운영체제의 핵심인 커널(Kernel)을 지칭하였으나,
GNU 프로젝트의 라이브러리와 도구들이 포함되면서 하나의 운영체제로 발전하였습니다. 이러한 운영체제를 GNU/Linux 라고 합니다.

> **커널**
> - 시스템 부팅 시 로드되는 커널은 운영체제의 뇌에 해당
> - 주된 역할은 시스템의 하드웨어의 효율적 제어 (메모리, CPU, 디스크, 단말기, 프린터 등)
> - 활용도를 높이기 위한 스케줄링 및 실행중인 프로그램 관리, 자료관리

또한 **리눅스 배포판**이란, 리눅스 커널 이외의 핵심적인 부분을 GNU 정신을 바탕으로 만들어진 다양한 자유 소프트웨어와 공개 프로그램을
모아서 하나의 운영체제로 만든 것을 말합니다.

- **리눅스 배포판**
    - 최초의 배포판은 피터 맥도널드의 SLS, 패트릭 볼커딩의 슬랙웨어, 이안 머독에 의한 데비안 프로젝트
    - 분류(패키지 관리 기법에 따라 분류됨)
        - **슬랙웨어**: 최상단에서 최대한 수정되어 배포, 새로운 적용 및 수정이 어려움. SuSE, Porteus, Vector Linux, Salix OS 등
        - **데비안**: dpkg 및 apt 도구 사용. Knoppix, Corel, Lindows, Ubuntu, Linux Mint, Elementary OS 등
        - **레드햇**: rpm 및 yum 도구 사용. RHEL, CentOS, Fedora, Oracle Linux, Scientific Linux, Asianux 등
    - 수세와 우분투 리눅스가 각 계파의 리더격임

소프트웨어 패키지 의존성을 자동으로 해결해주지 않는 보수적인 슬랙웨어에 비해 데비안은 패키지 관리 면에서
사용자친화적이기 때문에 쉽게 대중화되었습니다. 레드햇 또한 독자적인 패키지 관리 툴이 존재하여 인기가 많으며,
2003년 배포된 Red Hat Linux 9 까지만 무상 배포되었고 현재 RHEL의 유료 배포판을 지원합니다.
레드햇의 무료 배포판은 현재 fedora 오픈 소스 프로젝트로 관리되며, RHEL 의 복제판인 CentOs 도 2014년 흡수되었습니다.

- **리눅스 동향**
    - 리눅스는 초기부터 주로 서버로 이용됨
    - 자유 소프트웨어의 이점으로 다양한 분야로 진출 (서버, 데스크톱 및 개발, 임베디드)
    - 서버 및 슈퍼컴퓨팅에서 우수, 데스크톱은 우분투가 각광, 모바일 분야 및 스마트 TV, IVI, 자동차 등에서도 활용
    - 나아가 클라우드 컴퓨팅 인프라 구축과 빅데이터 및 사물인터넷 환경에서도 중추적인 역할을 수행할 것으로 사료

- **리눅스 클러스터링(Linux Clustering)**
    - 단말 제어 장치와 그에 접속된 복수의 단말의 총칭. 서버 분야에서는 여러 대의 컴퓨터를 연결하여 하나처럼 활용하는 시스템 지칭
    - **고계산용 클러스터(HPC)**: 주로 과학계산용. 병렬 컴퓨터로 슈퍼컴퓨터의 성능
    - **부하분산 클러스터(LVS)**: 대규모의 서비스 제공 목적. 이용자가 많은 웹 서비스 등에 활용. 부하 분산을 위한 로드밸런서를 둠
    - **고가용성 클러스터(HA)**: 지속적인 서비스 제공 목적. LVS 와 연동하여 많이 사용. Primary Node 와 Backup Node 의 커버링 구성

**임베디드 시스템(Embedded System)**, **클라우드 컴퓨팅(Cloud Computing)**, **빅 데이터(Big Data)**, **사물인터넷(IoT)** 등
리눅스가 활용되는 다양한 분야가 존재합니다.    

### 1-2. 리눅스 시스템의 이해

### 리눅스와 하드웨어

리눅스 설치 시 사용 목적에 따른 적절한 리눅스 배포판과 이에 맞는 하드웨어를 선택해야 합니다.
배포판마다 지원하는 아키텍쳐가 다르기 때문에 시스템에서 사용하는 CPU 를 지원하는 리눅스를 고려해야 합니다.

- **CPU**
    - 인텔의 x86 계열과 AMD 계열이 대표적이며, CPU 가 32비트인지 64비트인지에 따라 지원되는 메모리 양이 다르므로 이것도 고려해야 함
    - 추가적으로 클라우드 인프라 환경에서 사용한다면 가상화 기술 지원 여부도 확인
- **메모리(RAM)**
    - 메모리의 용량은 하드디스크 일부 공간을 램처럼 사용하는 Swap 파티션 설정과 관련이 있으므로 꼭 확인
    - 32비트 리눅스에서는 페이징 기법의 차이로 4GB 이상의 램을 인식할 수 없음
    - 64비트 리눅스에서는 대용량 메모리 지원
- **하드디스크 드라이브**
    - 하드디스크 인터페이스인 IDE(ATA), E-IDE, SCSI, S-ATA 등을 지원
    - 초고속 반도체 메모리를 저장 매체로 사용하는 USB 메모리나 SSD 도 지원
    - 하드디스크 드라이브는 파티션 변경이나 스왑 등 설정할 영역이 존재 (IDE 는 /dev/hdx 형식으로, SCSI 는 /dev/sdx 형식으로 관리)
- **모니터와 비디오 어댑터**
    - X-Window 기반의 GUI 환경에서 고려 대상. 장치에 맞는 정확한 드라이버를 사용해야 함
- **네트워크 인터페이스**
    - 이더넷(Ethernet), 모뎀, ISDN, AX.25, ATM 등의 네트워크 인터페이스 지원
    - 특히 이더넷 카드는 LAN 어댑터 제조사 상관없이 대부분 지원. 무선랜 어댑터도 지원
    - 네트워크 설정을 위해 IP 주소, 넷마스크, 게이트웨이 주소, DNS 주소 등을 잘 설정해야 함
- **키보드 및 마우스**
    - 현존 대부분을 지원. X-Window 환경에서 마우스 휠도 지원
- **CD-ROM 및 DVD-ROM**
    - 하드디스크 인터페이스와 같이 대부분을 파일 형식으로 자동 인식되어 관리됨
- **기타 하드웨어**
    - 사운드카드와 프린터 등 데스크탑 목적 하드웨어도 지원

**RAID(Redundant Array of Independent Disks)** 는 여러 개의 하드디스크가 있을 때 동일한 데이터를 다른 위치에 중복해서 저장하는
방법입니다. 운영체제에서 하나의 RAID 는 논리적으로 하나의 디스크로 인식하여 처리합니다.

- **RAID 의 이용**
    - 초기에는 저용량 하드디스크를 하나의 디스크로 확장하여 사용하는 것이 주류
    - 현재는 백업을 가능하게 하고 안정적인 데이터의 보존과 유지 기능, 속도 향상 등에 사용
    - 소프트웨어적 RAID 는 비용적인 측면에서 유리하나, 성능 면에서는 하드웨어 RAID 가 좋음
- **RAID 에서 사용하는 기술**
    - 스트라이핑(Striping): 연속된 데이터를 여러 개의 디스크에 라운드로빈 방식으로 기록하는 기술. 여러 디스크에 동시적으로 접근시 유리
    - 미러링(Mirroring): 디스크에 에러 발생 시 데이터의 손실을 막기 위해 추가적으로 하나 이상의 장치에 중복 저장하는 기술
- **RAID 의 종류**
    - RAID-0: 스트라이핑 기술을 사용하여 빠른 입출력 속도 제공. 중복이나 패리티 없이 디스크에 분산 기록. 따라서 오류시 복구 불가능
    - RAID-1: 미러링 기술을 사용하여 두 개의 디스크에 데이터를 동일하게 기록.
    동시 읽기가 가능해 읽기 속도는 향상되나 쓰기는 단일 디스크와 같음. 오류시 복구 능력 탁월하지만, 중복 저장으로 디스크 낭비가 50%에 이름
    - RAID-2: 디스크들은 스트라이핑 기술을 사용하고, 에러 감지 및 수정을 위해 ECC(Error Check & Correction) 정보를 활용
    - RAID-3: 스트라이핑 기술을 사용하여 디스크를 구성하고, 패리티 정보를 저장하기 위해 별도로 하나의 디스크 사용.
    입출력 작업이 동시에 모든 디스크에 대해 이루어지므로 입출력을 겹치게 할 수는 없음. 보통 대형 레코드가 많은 시스템에서 사용.
    - RAID-4: 블록 형태의 스트라이핑 기술을 사용하여 디스크 구성하는데, 이는 단일 디스크로부터 레코드를 읽을 수 있고 데이터를
    읽을 때 중첩 입출력의 장점이 있음
    - RAID-5: 패리티 정보를 이용하여 커버하며 최소 3개의 디스크로 구성. 패리티는 각 디스크에 분산 기록됨. RAID-0 의 단점인 결합
    허용을 지원하지 않는 점과 RAID-1 의 저장공간 비효율성을 보완한 레벨로 디스크 개수를 늘릴수록 저장 효율성이 높아짐.
    - RAID-6: RAID-5 에서 디스크에 2차 패리티 구성을 포함하여 매우 높은 고장 대비 능력 발휘. 2개의 디스크 오류에도 데이터 읽기 가능.
    최소 4개의 디스크로 구성해야 하며, RAID-5 에 비해 공간 효율성이 떨어짐
    - RAID-7: 하드웨어 컨트롤러에 내장되어 있는 실시간 운영체제를 사용하여 구성하는 방식으로 속도가 빠른 버스를 이용.
    - RAID 0+1: 디스크 2개를 RAID-0 의 스트라이핑 기술로, 다시 RAID-1 의 미러링으로 구성하는 방식. 최소 4개 필요
    - RAID-10: RAID 0+1 의 반대 개념으로 디스크 2개를 먼저 미러링하고 다시 스트라이핑
    - RAID-53: RAID-3 방식에 별도로 스트라이프 어레이를 구성하는 방식. 보다 높은 성능을 제공하지만 구성 비용이 많이 듬

**LVM(Local Volume Manager)** 이란, 논리적으로 유연하게 파티션을 분할 관리하는 방법입니다.

- **LVM** 은 찰흙과 같은 개념으로 이해하면 좋은데, 고정적인 여러 개의 하드디스크를 논리적으로 원하는 크기와 개수로 파티셔닝 가능하게 함
- 사용중인 파티션의 크기를 줄이거나 늘릴 수 있으며, 파티션 확장은 디스크 추가 이후 간단한 명령만으로 데이터 이전 없이 손쉽게 가능
- **LVM 구성도와 관련 용어**
    - 물리적 볼륨(PV): 실제 디스크에 물리적으로 분할한 파티션. (/dev/sdb1, /dev/sdc1 등)
    - 볼륨 그룹(VG): 물리적 볼륨이 모여서 생성되는 덩어리. PE(Physical Extent)의 큰 덩어리.
    - 논리적 볼륨(LV): 볼륨 그룹에서 사용자가 필요한 만큼 할당하여 만들어지는 공간. 물리적으로는 디스크에서 분할하여 사용하는 파티션.
    - 물리적 확장(PE): 물리적 볼륨에서 나누어 사용하는 일종의 블록 같은 영역. 보통 1PE 가 4MB 정도씩 할당됨

### 리눅스의 구조

**부트 매니저(Boot Manager)** 란 부팅을 도와주는 프로그램으로, 한 컴퓨터에 여러 운영체제가 설치된 경우 선택하여 부팅할 수 있도록 합니다.
부트 매니저는 부트 로더라고도 부릅니다. 이것은 하드디스크의 맨 앞쪽 영역인 MBR(Master Boot Record) 에 설치되며,
MBR 은 0번 섹터에 512 바이트 크기입니다. MBR 에는 부트 매니저가 설치됨과 함께 파티션 정보가 기록됩니다.

리눅스의 대표적인 부트 매니저 프로그램은 다음과 같습니다.

- LILO(Linux Loader): 파일 시스템 구애 없이 플로피 디스크와 하드 디스크를 이용한 부팅 지원
- **GRUB(Grand Unified BootLoader)**
    - GNU 에서 만든 부트로더로 LILO 보다 다양한 파일 시스템을 지원하고 부팅시 커널 인자를 조정하여 동적인 부팅을 지원함
    - 메뉴 인터페이스 방식과 bash 와 같은 명령행 인터페이스 또한 제공 (그래픽 메뉴, 그림 삽입 가능)
    - 레드햇의 경우 /boot/grub/grub.conf 파일에서 설정. 재부팅시 반영
- GRUB 의 부팅 모드
    - 메뉴 화면에서 지정된 키를 입력하여 여러 동작 가능
    - \[a]: grub.conf 에서 커널과 관련된 부분의 매개변수를 추가할 수 있게 해줌
    - \[e]: grub.conf 에 등록된 부팅 목록의 모든 항목을 직접 편집할 수 있도록 해줌. 파일을 변경하진 않고 현재 부팅 시에만 일시적으로 적용
        - e: 커서가 위치한 줄 편집
        - d: 커서가 위치한 줄 삭제
        - o: 명령 줄을 커서가 위치한 줄 아래에 추가
        - O: 명령 줄을 커서가 위치한 줄 위에 추가
        - b: 부팅 시작(최종 편집 후 부팅)
    - \[c]: bash 셸과 유사한 상호대화식 명령행 모드로 진입. TAB, ESC 키 사용 가능하며, 마지막에 'boot' 입력하면 부팅이 됨
- GRUB 의 환경 설정 파일
    - 환경 설정 파일은 /boot/grub/grub.conf 이며, 리눅스와 윈도우 멀티 부팅 환경인 경우 이 파일 내의 title 영역에 각각의 설정이 나타남
    - (교재에서 각 라인에 대한 의미를 확인할 것.)

**디렉토리(Directory)** 란 파일을 보관하는 곳으로써 리눅스에서는 최상위 root(/) 를 중심으로 트리 형식으로 하위 디렉토리 및 파일이
계층적으로 분포됩니다.

- **/**: 최상위 루트 디렉토리
- **/bin**: 실행 파일 모음. 보통 PATH 환경변수 경로에 설정되어 있음 (cp, mkdir, rmdir, mv, rm, cat 등 명령)
- **/boot**: 부팅 이미지 파일이나 커널 등 시스템 부팅 시 필요한 파일 모음. grub 관련 파일도 존재
- **/dev**: 물리적 디바이스 장치들이 파일 형식으로 저장됨
- **/etc**: 시스템 환경 설정 파일 및 부팅과 관련된 여러 스크립트 파일 모음. 이 설정들을 읽어 관련 프로그램들이 실행됨
- **/home**: 개인 사용자들의 홈 디렉토리가 모여 있음
- **/lib**: 각종 라이브러리 모음. 커널 모듈도 들어 있음
- **/lost+found**: fsck 명령어를 이용하여 파일 시스템을 복구할 때 작업하는 디렉토리 RHEL 7 버전부터는 사용되지 않음
- **/mnt**: CD-ROM, 플로피디스크, 하드디스크, 네트워크 파일 시스템 등을 마운트할 때 포인트가 되는 디렉토리.
최근에는 장치별로 /media, /net 등이 추가 제공되기도 함
- **/misc**: 자동 마운트 프로그램인 autofs 에 의해 사용되는 디렉토리
- **/opt**: 응용 프로그램들의 설치를 위해 사용되는 디렉토리
- **/proc**: 가상 파일 시스템으로 시스템에서 운영되고 있는 다양한 프로세스의 상태 정보, 하드웨어 정보, 기타 시스템 정보 등을 담고 있음
- **/root**: 시스템 관리자인 root 의 사용자 홈 디렉토리
- **/sbin**: System Binary 의 약자로 주로 시스템 관리에 대한 명령어들이 들어 있는 디렉토리. 보통 수퍼유저인 root 가 사용.
시스템 종료 명령, 네트워크 인터페이스 설정 명령, 시스템 점검과 복구 등의 명령어
- **/tmp**: 임시 저장 디렉토리로서 각종 프로그램이나 소켓 파일, 프로세스 작업을 할 때 임시로 생성되는 파일을 저장하는 공간
- **/usr**: 시스템 운영에 필요한 명령, 응용 프로그램들이 위치하는 디렉토리. 커널 소스, C 헤더 파일, C 컴파일러와 같은 개발 도구,
apache 나 mysql, php 등 모두 이 디렉토리의 하위에 설치됨. /usr/bin, /usr/sbin 에는 주요 응용프로그램의 명령어들이 존재함.
로컬에서 응용프로그램을 추가로 설치할 때 사용되는 /usr/local 등도 존재
- **/var**: 시스템 운영 로그 파일과 스풀링과 같은 가변적인 데이터를 보관하는 디렉토리. 메일 서버의 경우 수신 메일 보관함 존재
- /media, /selinux, /srv, /sys, /cgroup, /lib64, /run 등 추가로 존재

**부팅(Booting)** 은 하드웨어적 단계와 프로그램 메모리 적재의 소프트웨어적 단계로 나눠집니다.

- 하드디스크에 설치된 운영체제의 부팅 과정
    1. 컴퓨터 전원을 켜면 바이오스는 컴퓨터에 장착된 하드웨어를 점검한다.
    2. 바이오스는 하드웨어 검사가 끝나면 CMOS 에 설정된 첫 번째 부팅 하드디스크를 확인한다.
    3. 첫 번째 하드디스크의 MBR 영역에 있는 부트 매니저 프로그램을 실행한다.
    4. 부트 매니저 프로그램은 관련 환경 설정 파일을 참고하여 운영체제 부팅을 시작한다.
- **리눅스의 부팅**
    - 리눅스의 부팅은 GRUB 의 시작부터 텍스트 기반 콘솔 로그인 화면 혹은 X-Window 가 구동되어 로그인 창이 나타나기까지를 지칭
    - **하드웨어 인식 단계**: 하드웨어를 인식하고, grub 부트 메뉴에서 [a] 혹은 [e] 로 매개변수=값을 추가로 입력
    - **소프트웨어 구동 단계**
        - 부팅 시 커널이 로드되면 커널은 우선 루트 파일 시스템을 읽기 전용 형태로 마운트, 검사 후 쓰기 가능 형태로 다시 마운트
        - 이후 커널은 init 프로세스를 발생시키는데, 리눅스 부팅과 관련된 소프트웨어 구동은 init 프로세스에 위임됨
        - init 은 /etc/init 디렉토리 안의 환경 설정 파일을 읽어 동작

> **init 프로세스 관련 환경 설정 파일**
> - /etc/inittab: 부팅과 관련된 실행레벨(Runlevel) 정의
> - /etc/init/rcS.conf: 시스템 초기화 관련 설정. /etc/rc.d/rc.sysinit 스크립트 실행하여 호스트명 설정, 시스템 점검, RAID 및 LVM
> 장치 활성화, 쿼터 설정 활성화 등 진행
> - /etc/init/rc.conf: 각 레벨별 진행되는 내용 설정 파일. /etc/rc.d/rc 스크립트 실행. 이 스크립트는 런레벨 3인 경우
> /etc/rc.d/rc3.d 디렉토리의 실행 데몬 스크립트 중 S 로 시작되는 것을 찾아 부팅 시 실행함
> - /etc/rc.d/rc.local: 런레벨 2, 3, 5 에서 가장 마지막에 실행되는 파일로써, 보통 사용자가 부팅 시에 필요한 서비스 구동

- **실행 레벨(Runlevel)**
    - init 데몬 프로세스에 의해 수행되어질 내용이나 시스템 초기화 등을 정의해둔 여러 모드. 리눅스는 총 8개
    - 그래픽 환경은 런레벨 5, 텍스트 환경은 런레벨 3 로 부팅
    - **0**: 시스템 중지(종료). 기본값으로 설정해서는 안됨
    - **1**: 단일 사용자 모드. 로그인 없이 root 로 부팅하여 일종의 관리자 모드 역할. root 패스워드 분실 혹은 파일 시스템이나 시스템
    점검 및 복구 시 접근
    - **2**: 네트워크 사용하지 않는 다중 사용자 모드
    - **3**: 네트워크 지원하는 다중 사용자 모드. 가장 보편적 레벨이며, X-Window 사용하지 않아 메모리 효율적 사용 가능
    - **4**: 사용되지 않음. 사용자가 정의하여 사용 가능
    - **5**: X-Window 를 사용하는 다중 사용자 모드. 최근 배포판에서 기본 설정임
    - **6**: 시스템 재부팅 레벨. 기본값으로 설정해서는 안됨

0~6 까지 7개의 런레벨 외에 emergency 모드라 부르는 S 또는 s 모드는 1 과 유사하나 관련 프로세스나 데몬을 최소화하여
유지 보수나 점검에 적합합니다.

- **로그인**
    - 런레벨 3인 경우 CTRL+ALT+F1~F6 으로 6개의 가상 콘솔 통해 로그인
    - getty(mingetty) 프로그램이 터미널이나 콘솔에 로그인 프로그램을 실행. 이때, /etc/issue 의 내용이 상단에 출력됨
    - 런레벨 5인 경우 CTRL+ALT+F7 (배포판에 따라 F1) 에 그래픽하게 나타남
    - /etc/issue 는 로컬, /etc/issue.net 은 텔넷을 통한 네트워크 접속 시 출력되는 메시지 기록
    - /etc/motd 는 로그인 성공 시 보여주는 메시지
- **로그아웃**
    - 자원 효율성 및 보안의 측면에서 로그아웃은 필수 (logout, exit 혹은 메뉴 선택으로)
    - root 사용자가 /etc/profile 의'TMOUT=초' 로 지정하면 지정된 시간동안 작업이 없을 시 해당 사용자를 강제 로그아웃 시킴
    
**시스템 종료(Shutdown)** 를 위해 터미널 환경에서 shutdown, halt, reboot, poweroff, init 등의 명령이 사용됩니다.

- **shutdown**
    - root 권한자만 실행 가능
    - **```# shutdown [option] 시간 [경고메시지]```**
    - 시간은 +m 형식 혹은 hh:mm 형식으로 설정 가능
    - 옵션
        - -r: 재부팅(reboot)
        - -h: 종료(halt)
        - -c: 예약된 shutdown 명령 취소
        - -k: 실제로 shutdown 하지 않고 경고 메시지만 접속 사용자들에게 전송
- **reboot**
    - 시스템 재시작 명령. 로컬 사용자라면 모두 사용 가능
    - **```$ reboot [option]```**
    - 옵션
        - -w: 재부팅 없이 /var/log/wtmp 에 셧다운 기록만 저장
- **halt**
    - 시스템 종료 명령. 로컬 사용자라면 모두 사용 가능
    - **```$ halt [option]```**
    - 옵션
        - -p: 시스템 종료 후 전원까지 끄는 경우 사용(--poweroff)
- **poweroff**
    - 시스템 종료 및 전원을 끄는 명령
- **init, telinit**
    - 모든 프로세스의 조상인 init 프로세스에 직접 요청하여 런레벨을 변경하는 명령
    - 빠르게 실행되지만, 실행중인 프로세스를 무조건적으로 종료하므로 권장되지 않음
    - **```$ init [실행 레벨]```**
    - ```init 0``` 은 시스템 즉시 종료, ```init 6``` 은 시스템 즉시 재부팅

**파일 시스템(File System)** 이란, 운영체제가 파티션이나 디스크에 데이터를 저장하고, 읽고, 쓰고, 찾기 위해 구성하는 일련의 체계를
의미하는데, 운영체제가 사용자에게 제공하는 가장 직접적인 서비스 형태 중 하나입니다.

파일 시스템의 구성은 운영체제 설치 시에 일어나며, 파티션 분할 작업 후 포맷(Format)을 가장 먼저 하게 되는데,
이것은 파일을 저장하기 위해 디스크를 일정한 크기로 분할하고 주소를 설정하는 작업이라고 할 수 있습니다.
각각의 운영체제들은 포맷이라는 작업을 통해 고유한 파일 시스템을 구축하게 되고, 다양한 규칙들을 설정하게 됩니다.

대부분의 운영체제들은 파일이라는 단위로 저장하고, 파일에 이름을 부여한 뒤에 디렉토리에 저장합니다. 이 과정에서 파일명의 길이를 제한하기도
하고, 어떤 문자들이 사용될 수 있는지를 정하기도 합니다. 파일명에 확장자를 쓰도록 지정하기도 하며, 확장자의 길이도 제한할 수 있습니다.
또한 파일 시스템은 지원하는 파티션의 개수, 크기, 파일 크기 등에도 직접적인 관계가 있으며, 파일 복구와 같은 기능을 부여하기도 합니다.

따라서 파일 시스템의 성능은 운영체제의 성능에도 밀접한 관계가 있다고 볼 수 있습니다.

- **파일 시스템의 기능**
    1. 사용자가 파일을 생성, 수정, 삭제할 수 있도록 제공
    2. 사용자가 파일을 사용하기 적합한 형태의 구조로 구성하고, 다양한 추가 정보 제공
    3. 다른 사용자와의 파일을 공동으로 사용할 수 있는 적절한 제어 방법 제공
    4. 파일 공유를 위하여 판독 접근, 기록 접근, 수행 접근 등의 다양한 접근 제어 방법 제공
    5. 정보 손실이나 파괴를 방지하기 위하여 백업이나 복구를 위한 기능 준비
    6. 사용자와 장치 간의 독립성을 유지하기 위해, 사용자가 물리적인 장치 이름 대신에 적절한 이름 제공
    7. 정보가 안전하게 보호되고 비밀이 보장될 수 있도록 정보의 암호화 및 복호화 기능 제공
    8. 사용자가 파일이나 디렉토리에 접근하기 쉬운 인터페이스 및 명령어 제공
    
- **리눅스의 파일 시스템**
    - 리눅스는 다양한 파일 시스템 지원 (ext > ext2 > ext3, 저널링 파일 시스템 > ext4)
    - 저널링 파일 시스템: 파일 시스템에 대한 변경사항을 반영하기 전에 저널이라 부르는 로그에 저장하여 추적이 가능하게 함.
    데이터 복구 확률을 높여줌
    - ext2, ext3, ext4, nfs, Reiser FS, XFS, JFS 등 지원

> 각 파일 시스템의 특징을 교재에서 참조할 것
>

- **리눅스 파일 시스템의 구조**
    - 파티션 분할 이후 Format(mkfs) 작업을 통해 파일시스템을 생성
    - 파일 시스템에서 **기본적으로 데이터를 저장하는 단위는 블록(Block)**으로써, 기본 4KB 로 지정됨
    - 파일 시스템은 크게 부트 블록(Boot Block, 또는 부트 섹터)과 여러 개의 블록 그룹(Block Group, N-1개)으로 나뉘어짐
    - 블록 그룹은 그룹내 모든 메타 정보를 담고 있는 **슈퍼 블록(Super Block)**, **그룹 기술자(Group Descriptors)**,
    **블록 비트맵(Block Bitmap)**, **아이노드 비트맵(Inode Bitmap)**, **아이노드 테이블(Inode Table, 또는 아이노드 블록)**,
    **데이터 블록(Data Blocks)** 으로 구성됨
    - 슈퍼 블록과 블록 기술자는 모든 메타정보가 있어 중요하므로 모든 블록에 걸쳐 사본이 백업됨
    - **슈퍼 블록**: 특정 파일 시스템임을 알리는 매직 넘버, 마운트 정보, 전체 아이노드 수 및 남은 수, 전체 블록 수 및 남은 수,
    블록 그룹 번호, 블록 크기, 그룹 당 블록 수 등
    - **그룹 기술자**: 각각의 블록 그룹을 기술하는 자료 구조로서, 저장되는 주요 정보는 블록 비트맵, 아이노드 비트맵,
    아이노드 테이블(또는 아이노드 블록)
    - **블록 비트맵**: 블록의 사용 현황을 bit 로 표현
    - **아이노드 비트맵**: 아이노드 할당 상태를 bit 로 표현
    - **아이노드 테이블**: 아이노드 정보가 들어있는 영역. ls -l 명령 시 나타내는 파일 관련 정보가 저장됨
    - **데이터 블록**: 파일이 보관해야 하는 정보를 저장하는 영역(파일 데이터)
        - 추가 데이터 블록의 포인터가 동적으로 할당되는 간접 블록, 아이노드나 간접 블록 안의 데이터 블록의 주소를 저장하는 홀

> **아이노드(Inode)**
> - 일종의 자료구조로 각각의 파일은 하나의 아이노드를 할당받아 관리
> - 파일 정보 저장 (아이노드 넘버, 접근 모드, 파일 형식, 소유자 정보, 파일 크기, 타임 스탬프 등)
> - 파일 시스템 생성 시 전체의 약 1% 공간을 아이노드에 할당하므로, 생성 가능 파일의 최대 개수도 한정되어 있음

> **저널링 기술과 저널링 파일 시스템**
> - 기존의 fsck 에 걸리는 시간을 단축하기 위해 데이터를 디스크에 쓰기 전에 로그에 남겨 비정상적 종료에도 보다 빠르고 안정적인 복구기능 제공
> - fsck 로 복구시 슈퍼 블록, 비트맵, 아이노드 등을 모두 검사하므로 많은 시간이 걸렸지만,
> - 저널링 파일 시스템은 수정 내역을 블록에 적용 전 로그에 수정된 내용을 저장하므로 복구시 단지 로그만 검사하면 됨
> - 로그 기록 중 중지되었다면 아직 실제 적용 전이므로 문제가 되지 않고, 블록에 적용 중 중지되었다면 로그만 살펴보면 되니 안정성이 높음
> - ext3, ext4, XFS, JFS, ReiserFS 등

### X 윈도

### 셸(Shell)

**셸**은 커널과 사용자간 다리 역할을 하는 것으로 사용자로부터 명령을 받아 그것을 해석하고 프로그램을 실행시키는 역할을 합니다.

여러 개의 셸이 있는데, 사용자가 로그인을 하면 사용자에게 설정된 셸이 부여됩니다. 따라서 사용자에게 셸을 부여하지 않으면
시스템에 로그인 하더라도 명령 수행이 불가능하여 로그인을 막는 효과와 동일하다고 볼 수 있습니다.

현재 가장 많이 사용되는 표준 셸은 ksh 과 csh 의 장점을 결합한 bash 셸입니다.

- 셸 종류: Bourne Shell(sh), bash, csh, tcsh, ksh 등
- 셸 확인: ```$ echo $SHELL``` > ```/bin/bash```, ```$ chsh -l```
- 셸 변경: ```$ chsh``` > 패스워드 입력 후 변경할 셸의 절대 경로 입력
- 사용자의 로그인 셸 정보 확인: /etc/passwd 설정 파일 내 사용자 라인의 7번째 필드에 기록

```
~$ grep daesungra /etc/passwd
daesungra:x:500:500::/home/daesungra:/bin/bash
```

**셸 변수**는 ```변수명=값``` 형태로 지정하며, ```$ echo $[변수명]``` 로 값을 확인합니다.

**환경 변수**는 프롬프트 변경, PATH 변경 등과 같이 셸의 환경을 정의하는 중요한 역할을 수행하는 변수입니다.
환경 변수는 env 명령으로 확인할 수 있습니다.

- HOME: 사용자의 홈 디렉토리
- PATH: 실행 파일을 찾는 디렉토리 경로
- LANG: 셸 사용 시 기본으로 지원되는 언어
- TERM: 로그인한 터미널 종류
- PWD: 사용자의 현재 작업 디렉토리
- SHELL: 사용자의 로그인 셸
- USER: 사용자의 이름
- DISPLAY: X 에서 프로그램 실행 시 출력되는 창
- PS1: 프롬프트(Prompt) 변수
- PS2: 2차 프롬프트 변수
- HISTFILE: 히스토리 파일의 절대 경로
- HISTSIZE: 히스토리 파일에 저장되는 명령어의 개수(줄 기준)
- HISTFILESIZE: 히스토리 파일의 파일 크기
- HOSTNAME: 시스템의 호스트명
- MAIL: 도착한 메일이 저장되는 경로
- TMOUT: 사용자가 로그인한 후 일정 시간 동안 작업을 하지 않을 경우에 로그아웃시키는 시간으로 단위는 초(second)
- UID: 사용자의 UID

환경 변수의 사용 예는 다음과 같습니다.

- ```$ mkdir $HOME/data``` > 홈 디렉토리에 디렉토리 추가
- ```$ echo $LANG```, ```$ LANG=C``` > 기본 언어 변경
- ```$ PS1="[\u@\t \W]\$ "``` > 프롬프트 형식 변경

> 주요 프롬프트 형식
> - \d: '요일 월 일' 형태로 날짜를 표시 (ex. "Wed Jan 15")
> - \h: 호스트 이름 표시
> - \s: 사용중인 셸의 이름 표시
> - \t: 24시 형태의 현재 시간 표시 (HH:MM:SS)
> - \T: 12시 형태의 현재 시간 표시 (HH:MM:SS)
> - \@ 12시 형태의 현재 시간에 AM/PM 을 추가로 표시
> - \u: 현재 사용자의 이름 표시
> - \w: 현재 작업 디렉토리를 절대 경로로 표시
> - \W: 현재 작업 디렉토리의 전체 경로 중 마지막 디렉토리만 표시
> - \!: 현재 명령의 히스토리 넘버 표시
> - \\: \ 표시 (백슬래시)

가장 빈번하게 사용되는 **bash 셸의 주요 기능**을 살펴봅니다.

- **명령행 완성 기능**
    - tab 키를 눌러서 작성 중인 명령 혹은 파일이나 디렉토리명을 자동 완성
    - 여러 개가 존재한다면 tab 키를 한번 더 눌러서 목록 확인
    
- **명령어 history 기능**
    - history 관련 셸 환경 변수에 따라 실행했던 모든 명령들이 히스토리 리스트 버퍼에 스택으로 저장
    - 위/아래 방향키로 목록을 찾을 수 있음
    - 사용자별 히스토리 파일인 '~/.bash_history' 에 기록됨 (기록은 로그아웃 시 메모리에 기억된 명령의 목록을 저장)
    - 'history' 혹은 '!' 명령으로 확인

> **!와 히스토리 명령문**
> - !!: 마지막에 사용한 명령 실행
> - !n, !-n: n번째 사용한 명령 실행, 역으로 n번째 사용한 명령 실행
> - !문자열: 가장 최근에 사용한 명령 중 '문자열'로 시작하는 명령을 찾아서 실행
> - !?문자열?: 가장 최근에 사용한 명령 중 '문자열'을 포함하는 명령을 찾아서 실행
> - ^문자열1^문자열2: 마지막에 사용한 명령문의 '문자열1' 을 '문자열2'로 대체한 후 실행

> **히스토리 관련 환경 변수**
> - HISTSIZE: 히스토리 스택의 크기가 지정되어 있는 변수
> - HISTFILESIZE: 실질적인 히스토리 파일의 크기
> - HISTFILE: 히스토리 파일의 경로
> - HISTCONTROL: 중복되어지는 명령에 대한 기록 유무를 지정하는 변수
>     - ```$ export HISTOCONTROL=ignoreboth``` > 연속적으로 중복된 명령은 저장하지 않음
> - HISTTIMEFORMAT: history 명령 실행 시 출력되는 시간 형식 지정할때 사용

- **alias 기능**
    - 별명 기능. 특정 명령어와 옵션, 파라미터 등의 조합을 별명으로 지정하여 간편하게 사용 가능
    - ```$ alias [별명='명령어']```
    - ```$ unalias 별명```
    - ex. ```$ alias ll='ls -alF```

alias 를 재로그인 혹은 시스템 재부팅 시에도 유지하려면, .bashrc 파일에 설정하면 됩니다.

- **명령행 편집 기능**
    - (교재 참조, p106)
    
- **명령 대체(Command Substitution, 또는 명령 치환) 기능**
    - 특정 명령의 결과를 다른 명령어의 인자값으로 사용하는 것
    - 이를 위해 '`' (backquotes) 나 $() 활용
    - ex. ```$ ls -l `which passwd` ```
    - ex. ```$ ls -l $(which passwd)```

- **그룹 명령 실행**
    - 하나의 명령 행에 여러 개의 명령어 동시 사용
    - ';' 기호로 구분, 순차적으로 처리
    - ;: 한 줄에 여러 명령을 나열. 순차 처리
    - ||: 논리적 OR(Logical-OR). 앞의 명령이 성공이면 결과를 출력하고 그렇지 않으면 뒤의 명령을 실행하여 결과 출력
    - &&: 논리적 AND(Logical-AND). 앞의 명령이 성공이어야 뒤의 명령을 수행
    - ex. ```$ ls; sleep 10; ls```
    - ex. ```$ ls; find / -type d > list.txt```
    - ex. ```$ (ls; find / -type d) > list2.txt```
    - ex. ```$ pwd; (cd /; pwd); pwd``` > 그룹 명령 실행 후 원래 위치로 돌아옴!
    - ex. ```$ grep daesung /etc/passwd || echo 'No daesung''``` >
    'daesung' 계정이 존재하면 해당 행을 출력, 아니라면 문자열 출력

- **표준 입출력 제어 기능**
    - 

### 프로세스

### 1-3. 네트워크의 이해

### 네트워크의 기초

### 네트워크 설정

### 기출 예상문제

<br><br>
## 2. 리눅스 시스템 관리


<br><br>
## 3. 네트워크 및 서비스의 활용


<br><br>
## 4. 기출 및 부록 정리
