---
title:  "[자격증] 리눅스 마스터 1급 준비하기"
created:   2022-02-02 18:08:00 +0900
updated:   2022-02-02 18:08:00 +0900
author: namu
categories: etc
permalink: "/etc/:year/:month/:day/:title"
image: https://media.vlpt.us/images/may_soouu/post/11a98732-df94-4e66-94d4-033634093313/linux.png
image-view: true
image-author: 개벨로그
image-source: https://velog.io/@may_soouu/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0
---

<br>
## 시험 안내

**리눅스 마스터**는 리눅스 기반의 Desktop 활용 및 Server 운영 능력, 리눅스 시스템의 설계 개발 및 관리 능력,
리눅스 기반의 네트워크 및 서버 구축/운영 능력을 검정하는 자격시험입니다.

그 중 1급 시험의 목적은 다음과 같습니다.

- **1급**
    - 지식: 고도의 리눅스 활용능력에 대한 이해도 평가
    - 기능: 리눅스를 안전하고 효율적으로 운영하기 위한 실무 기능 평가

이 시험은 **1차시**에서
**(1) 리눅스 실무의 이해(20%)**, **(2) 리눅스 시스템 관리(40%)**, **(3) 네트워크 및 서비스의 활용(40%)** 비중의 사지선다 필기 100문항,
**2차시**에서 **단답 및 서술식 필기 10문항**, **실기(60%) 5~7문항**으로 구성됩니다.

이번 글은 해당 시험을 너무 깊게 파기보다는 전체적인 이론의 맥락을 짚어보거나 몰랐던 부분을 정리하는 수준에서 작성하고자 합니다.
자격증 시험의 특성상, 이론보다는 기출문제를 통해 공부하는 것이 더 효율적이기 때문입니다.

<br><br>

---

### 목차

1. [리눅스 실무의 이해](#1-리눅스-실무의-이해)
2. [리눅스 시스템 관리](#2-리눅스-시스템-관리)
3. [네트워크 및 서비스의 활용](#3-네트워크-및-서비스의-활용)
4. [기출 및 부록 정리](#4-기출-및-부록-정리)

### 참조

- <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62844304" target="_blank">
리눅스 마스터 1급 정복하기 (2018, 북스홀릭)</a>

---

<br><br>
## 1. 리눅스 실무의 이해

### 1-1. 리눅스의 개요

### 운영체제의 개요

**운영체제**는 **컴퓨터 하드웨어와 컴퓨터 사용자 간의 매개체 역할을 하는 시스템 소프트웨어**입니다.

- 좁은 의미: 하드웨어와 응용 프로그램 간의 다리 역할하는 커널(Kernel)
- 넓은 의미: 커널 포함 미들웨어, 응용 프로그램 실행 환경과 사용자 인터페이스 프레임워크 모두 포괄

- **운영체제의 주목적**: 컴퓨터 시스템을 편리하게 이용하고, CPU, 주기억장치, 입출력장치 등의 컴퓨터 하드웨어를 효율적으로 관리하는 데 있음

초기 운영체제는 사용자 편의성을 고려하지 않았으나(효율적 자원 관리에 치중), 대중화가 진행되며 편리함과 친근함의 형태로 변화되었습니다.
이러한 것이 GUI 기반의 윈도우 OS 입니다.

GUI 기반 윈도우 OS 에서는 명령어 기반이 아닌 아이콘 이미지 클릭 방식을 지원합니다.

하지만 현재는 **유휴 자원의 효율적 활용**을 위해 가상화 기술을 OS 에서 기본적으로 내장하거나 커널 단에서 지원하고 있습니다.

또한 스마트폰이나 태블릿 전용 모바일 운영체제, 웹 브라우저 전용 OS 도 탄생되었습니다.

- **운영체제의 주요 역할**
    - 컴퓨터의 하드웨어 제어
    - 작업의 순서를 정하며, 입출력 연산을 제어
    - 프로그램의 실행 제어, 데이터와 파일의 저장을 관리
    - 사용자들 간의 하드웨어 자원 공유 제공
    - 시스템 자원을 스케줄링하여 효율적으로 활용
    - 입출력을 쉽게 하는 기능 제공
    - 응용 프로그램의 작성과 실행을 편리하게 함
    - 오류의 발생을 막고 복구를 지원
    - 데이터의 조직화, 네트워크 통신 처리 기능 수행
    - 편리한 사용자 인터페이스 제공

- **최근 운영체제의 주요 특징**
    - 다중 사용자 시스템(Multi-User System)
    - 다중 작업 시스템(Multi-Tasking System)
    - 강력한 네트워크 지원
    - 편리한 사용자 인터페이스 지원
    - 계층적 파일 시스템 운영
    - 가상 메모리 지원
    - 고성능의 프로세서에 최적화
    - 개방형 운영체제화
    - 뛰어난 이식성 지원
    - 가상화 기술 지원

- **운영체제의 역사**
    - 40년대: 초기전자식 디지털 컴퓨터
        - 운영체제가 없음
        - 단순한 기계적인 스위치에 의존
    - 50년대: 단순순차처리
        - 한 번에 오직 하나의 작업만 수행
        - 단일 흐름 일괄 처리
    - 60년대: 다중프로그래밍
        - 멀티프로그래밍, 멀티프로세싱 개념 대두
        - 시분할 처리 개념 대두
        - 데이터 통신 지원
    - 70년대: 다중 모드 시분할
        - 일괄처리, 시분할 및 실시간처리의 보편화
        - 범용 시스템 개념 도입
    - 80년대: 분산네트워크
        - 각종 응용 프로그램 개발
        - 데이터베이스 활용 확대
        - 네트워크 기반으로 한 서버/클라이언트 모델 확대
        - 운영체제 기능들이 하드웨어에 포함된 펌웨어(Firmware) 개념 대두
    - 90년대: 병렬계산과 분산계산
        - 중앙집중식이 아닌 분산으로 발전
        - PC용과 서버용 운영체제의 보편화
    - 2000년대 ~ 현재: 모바일 및 임베디드
        - 네트워크 기반의 분산 및 병렬 운영체제의 보편화
        - 스마트폰, 태블릿 등의 모바일 장치와 가전제품을 위한 모바일 및 임베디드 운영체제의 보편화
        - 다양한 기능, 확장성과 호환성 극대화
        - 다양한 통신망의 확대와 개방형 시스템 발달
        
다음은 리눅스의 특징입니다.

- **리눅스의 특징**
    - 1) 다중 사용자 및 다중 처리 시스템(Multi-User and Multi-Tasking)
    - 2) 완전히 공개된 시스템
        - 커널 및 대부분의 응용 프로그램 소스가 공개됨
    - 3) 뛰어난 네트워크 환경
        - 이더넷(Ethernet), SLIP, PPP, ATM 등의 환경
        - TCP/IP, IPX, AppleTalk 등 프로토콜 지원
    - 4) 다양한 파일 시스템 지원
        - 프로그램과 자료를 저장하기 위해 리눅스 고유 파일 시스템인 ext2, ext3, ext4 등 사용
        - 고유 파일 시스템뿐 아니라 다른 파일 시스템도 지원 > FAT, FAT32, NTFS, ISO 9660, HPFS, SCO 제닉스 등
        - 시스템 다운 시 즉시 복구할 수 있는 저널링 파일 시스템 지원 > ReiserFS, XFS, JFS 등
        - 네트워크 파일 시스템 지원 > SMB, CIFS, NFS, NCPFS 등
    - 5) 뛰어난 이식성
        - 약간의 어셈블리과 대부분의 C언어
    - 6) 유연성과 확장성
        - 유닉스 표준인 POSIX를 준수
        - 공개용 유닉스 프로그램들은 원시코드 접근이 용이하고 다른 시스템에 이식 및 자유로운 배포 가능
    - 7) 뛰어난 안정성과 보안성
        - 공개된 리눅스 커널은 폐쇄된 Windows 에 비해 보안상의 취약점 노출 가능성은 높지만
        - 수많은 전문가들에 의해 빠르게 오류 수정 및 보안 패치가 발표되고 있음
    - 8) 우수한 가격대 성능비
        - PC급 서버에서도 엔터프라이즈급의 성능 발휘
    - 9) 다양한 응용 프로그램의 제공
        - 커널을 비롯, 셸과 기본 명령어, X Window 시스템(Xorg, KDE, GNOME 등의 GUI), vi 등의 편집기(emacs), 웹, 메일, FTP 등
        - 개발 도구 지원(C, C++, Java, Python), 보안 도구(nmap, tcpdump), 게임 등
    - 10) 다양한 배포판의 존재
        - 서버, 개발용, PC용 등 다양한 목적의 배포판
        - RedHat, Debian, Ubuntu, SUSE, 한컴리눅스, SULinux 등
        - 상용 및 무료 배포판

- **리눅스의 단점**
    - 1) 기술지원의 부족
        - 대부분 비상업적 제품들이라 전세계 개발자들이 일일히 기술지원이 불가
    - 2) 특정 하드웨어에 대한 지원 부족
    - 3) 사용자의 숙련된 기술 요구됨
        - 아직 중요한 설정은 명령어를 입력하거나 관련 환경 설정 파일을 편집기를 사용해 수정해야 함

- **리눅스의 기술적인 특징**
    - 1) 계층적인 파일 구조
        - /(root) 기준으로 하위로 가지를 뻗어나가는 트리 구조(usr, var, bin 등)
    - 2) 장치의 파일화
        - 하드디스크, 키보드, 프린터, 화면출력장치 등의 디바이스까지도 모두 파일화하여 사용
        - 해당하는 장치 (실행 혹은 설정) 파일에 명령을 내리는 방식
    - 3) **가상메모리 사용**
        - Virtual Memory 란 하드디스크의 일부를 메모리처럼 사용하는 것을 말함
        - 이곳에는 임시 데이터가 저장되고, RAM 은 작업공간으로 사용
        - RAM 부족 시 큰 프로그램은 실행할 수 없는데, 이를 극복하는 데 가상메모리가 사용됨
        - 이러한 영역을 **스왑(SWAP)** 이라고 함
    - 4) 동적 라이브러리 지원
        - 프로그램 특정 기능을 하는 루틴들을 모아 놓은 것을 라이브러리라 함
        - 개발 시 라이브러리 중 필요한 루틴들을 받아서 링크(Link) 시킴
        - 컴파일 시 프로그램에 들어가는 정적 라이브러리에 비해, 동적 공유 라이브러리는 실행 파일에 들어가지 않고 프로그램 실행 시
        가져다 사용하므로 메모리 효율성이 아주 높음
    - 5) 가상 콘솔
        - Virtual Console 은 하나의 모니터를 장착한 시스템에 여러 개의 가상 화면을 제공
        - 기본 6개의 가상 콘솔 제공 > CTRL + ALT + F1~F6
    - 6) 파이프(Pipe, '|')
        - 프로세스의 통신을 위해 도입
        - 어떤 프로세스의 표준 출력이 다른 프로세스의 표준 입력으로 쓰이게 함
    - 7) 리디렉션(Redirection)
        - 어떤 프로세스의 입/출력을 표준 입출력이 아닌 다른 입출력으로 변경할 때 사용됨
        - 출력 결과를 파일로 저장하거나 파일의 내용을 프로세스의 입력으로 사용

> **스와핑(Swapping)**
> - 메모리에 프로그램들이 많이 올라와 공간이 꽉 찼다고 하더라도 가상메모리를 설정하면 추가로 새로운 프로그램을 실행시킬 수 있게 됩니다.
> 이것은 메모리에 올라와 있지만 사용하지 않고 있는 프로그램을 하드디스크에 설정된 가상메모리 공간으로 보내고 그 빈 공간에 새로운 프로그램을
> 로딩하기 때문입니다. 또한 가상메모리에 있는 내용을 사용하려면 다시 메모리로 올리고, 그 대신에 메모리에 있던 다른 내용이 하드디스크에 저장됩니다.
> 이처럼 메모리와 하드디스크 사이의 데이터 교환을 스와핑이라고 합니다.
>
> **스왑의 확인**
> - 설치 후 스왑 용량의 확인은 메모리 확인 명령어린 free 를 사용합니다. 기본 블록 단위로 출력되므로 -m 옵션을 사용하면 MB 단위로 확인합니다.
> ```text
> ~$ free -m
>         total   used    free    shared  buffers cached
> Mem:    1006    715     291     0       6       326
> Swap:   2047    0       2047
> ```

다음으로 **운영체제의 종류**에 대해 살펴봅시다.

현재 운영체제는 사용 환경에 따라 크게 **서버, 데스크톱, 모바일 및 임베디드, 기타 분야**로 분류할 수 있습니다.

특히 **모바일 운영체제**인 안드로이드나 iOS는 휴대폰, PDA, 스마트폰, 태블릿 뿐만아니라 스마트 TV, 가전제품,
자동차에 내장되는 IVI(In-Vehicle Infotainment)까지 영역을 확대하고 있어 임베디드 운영체제 영역과의 경계가 모호해지고 있습니다.

**기타 분야**에서 웹 기반 운영체제(Web-based Operation System, 이하 Web OS)로써 구글의 크롬 OS가 등장했습니다.

주요 서버 및 데스크톱 운영체제는 다음과 같습니다.

**1) 유닉스(UNIX)**

유닉스의 특징으로는 **다중 사용자(Multi-User) 및 다중 작업(Multi-Tasking)** 지원, 강력한 네트워크 지원, 뛰어난 이식성 및 확장성,
계층적 파일 구조, 가상 메모리 및 공유 라이브러리 지원 등이 있습니다.

- 1969년 미국 AT&T 사의 벨(Bell) 연구소의 연구원 켄 톰슨(Ken Tompson) 및 데니스 리치(Dennis Ritchie)에 의해 만들어짐
- 이후 AT&T는 무료로 여러 연구소 및 대학교에 OS와 소스를 보급하여 여러 버전의 유닉스 등장
- 대표적으로 **System V 계열**과 **BSD 계열**
    - System V 계열: (주로 상업적) IBM, HP, Sun Microsystem, SGI
    - BSD 계열: (주로 오픈소스) NetBSD, FreeBSD, OpenBSD, SunOS, NextStep, Mac OS X, GNU/Linux

**2) 윈도(Windows)**

- 1975년 빌 게이츠(Bill Gates)와 폴 앨런(Paul Allen)이 설립한 마이크로소프트(Microsoft)
- 1982년 MS-DOS 는 IBM PC 호환기종용으로 출시됨
- 1994년 MS-DOS 6.2 버전까지 출시
- 1995년 본격적인 GUI 기반 운영체제인 Windows 95, 이후 Windows 98, Windows ME
- Windows XP 부터는 MS-DOS 가 사라짐

**3) Mac OS X**

...

- Mac OS X 은 Mac OS 의 열 번째 버전이라는 의미였지만, OS X 가 하나의 상품명으로 자리잡음
- BSD 유닉스 기반으로 만든 '넥스트스텝' 을 확장하여 만든 것으로, 결국 유닉스 기반 운영체제라고 볼 수 있음

**4) 모바일 운영체제**

모바일 운영체제는 기본적으로 데스크톱용 윈도우, 맥, 리눅스와 같은 운영체제와 비슷하나 모바일 장치 및 환경적 특성에 적합하도록 설계되었습니다.

- 배터리 사용 최적화
- PC에 비해 상대적으로 낮은 사양
- 무선 기반 광대역 및 지역 연결 특화
- 다양한 멀티미디어 지원
- 커널, 하드웨어 드라이버, 미들웨어, 응용 프로그램 실행 환경, 사용자 인터페이스 프레임워크 등 제공

모바일 운영체제는 TV나 자동차 영역까지 확대되었습니다.

**5) 리눅스 기반 모바일 운영체제**

리눅스는 BSD 계열의 유닉스 수정본입니다.

- **구글의 안드로이드(Android)**
    - 리눅스 커널 위에서 동작하는 대표적인 운영체제
    - 다양한 C/C++ 라이브러리 포함
    - 자바 언어로 작성된 응용 프로그램 구동 > 달빅(Dalvik) 가상 머신으로 프로그램을 별도의 프로세스로 실행
    - 2005년 구글이 안드로이드사를 인수하면서 대세가 됨
    - 50여만 개의 다양한 애플리케이션을 제공하는 안드로이드 생태계
    - iOS 에 비해 개발 진입장벽이 낮음
    - [단점] 오픈소스로 인한 보안상의 취약점
    - [단점] 다수의 하드웨어로 통일성이 떨어짐, 안정성 확보 어려움
- 바다(Bada) OS, 마에모(Maemo), 모블린(Moblin), 미고(MeeGo), 리모(LiMo), 타이젠(Tizen)

**6) 스마트 TV**

스마트 TV 란 운영체제를 탑재하고 TV 본연의 기능인 실시간 방송 시청뿐만 아니라 인터넷 접속 기능을 기반으로 웹 검색, VOD, 게임, SNS, 앱스토어
등의 기능이 가능한 TV 를 말합니다.

스마트 TV 는 기본적으로 모바일 기기와 동일한 운영체제를 탑재합니다.

애플은 iOS, 구글은 안드로이드, 삼성전자는 바다OS 혹은 타이젠, LG 전자는 자체 넷캐스트 OS(또는 Web OS)

**7) IVI(In-Vehicle Infotainment)**

IVI 는 ICE(In-Car Entertainment) 라고도 하며, 자동차 내에서 다양한 편의 기능과 오락시설을 제공하는 것이 목적입니다.

- MS 의 Windows Embedded Automotive, QNX, GENIVI, 안드로이드, MeeGo/Tizen IVI

**8) 웹 운영체제**

2000년대 초반의 웹 OS(제1세대형) 는
"인터넷 기반의 운영체제로 인터넷 접속이 가능한 곳이라면 언제 어디서나 자신의 데스크톱을 사용하는 것과 같은 환경을 제공하는 서비스"를 의미했습니다.

따라서 기존의 윈도우나 리눅스 등에서 웹 브라우저를 호출하여 인터넷 접속으로 개인 데스크톱을 활성화합니다.
이곳에 로그인 후 생성한 파일이나 애플리케이션은 유저의 하드웨어가 아닌 웹 서버에 저장됩니다.

최근의 웹 OS(제2세대형) 는 "웹 브라우저를 기반으로 동작하는 가상의 운영체제"의 개념으로 진화했습니다.
사용자는 별도 OS 설치과정 없이 경량화된 최소 크기의 커널 위에서 웹 브라우저를 통해 서비스 제공자 웹 사이트에 접속하여 다양한 서비스를 이용합니다.

최근에는 클라우드 컴퓨팅 서비스와 결합하여 더 강력해졌습니다.
대표적으로 구글의 크롬 OS가 있습니다.

- 어디서나 동일한 작업 환경
- 데이터는 사용자의 하드디스크가 아니라 원격지나 클라우드에 저장
- 네트워크가 지원되는 환경이라면 어디서든지 빠르게 사용
- 크롬 웹 스토어를 통해 사용자가 일부 프로그램을 설치하도록 지원
- 높은 보안성 제공

### 리눅스 기초

**리눅스의 철학**은 다음과 같습니다.

- **상용 유닉스**
    - 기업의 엄격한 통제 및 계획 아래서 진행, 개발자가 임의로 기능 추가 수정할 수 없음
- **리눅스**
    - 엄격한 정책 하에 이루어지지 않고, 인터넷 연결된 전 세계 개발자 그룹들의 기여를 통해 발전하므로
    - 리눅스 시스템을 통합적으로 책임지고 개발하는 어떠한 조직이나 기업체가 존재하지 않음
    - 리눅스 공동체는 다양한 메일링 리스트, 유즈넷 뉴스그룹 등을 통해 소통
    - 리눅스 커널은 최초 개발자인 리누스 토발즈 주도하에 발전됨
- **GNU**
    - 'GNU is Not Unix' 의 재귀적 용법
    - 유닉스와 호환이 되면서도 유닉스와는 다르게 자유 소프트웨어로 만들어졌음
    - 리처드 스톨먼을 주축으로 자유로운 소프트웨어를 희망하던 공동체들이 가장 먼저 운영체제인 유닉스를 모태로 개발을 시작하면서 탄생
    - GNU C 컴파일러인 gcc뿐 아니라 emacs, GNOME, GNU tar, bash, GRUB 등 응용 프로그램 만들어짐
- **FSF(Free Software Foundation) 와 자유 소프트웨어**
    - 자유 소프트웨어 재단은 1985년 리처드 스톨먼이 세운 비영리 조직
    - 무료나 공짜가 아니라 자유(Free), 즉 '구속되지 않는다' > 프로그램의 변경이나 수정의 자유
    - 즉, 규칙을 지키기만 하면 변경, 수정, 추가 배포 등이 자유로움
- **카피레프트(Copyleft)와 GNU GPL(General Public License)**
    - 카피레프트는 저작권을 뜻하는 카피라이트(Copyright)의 반대 의미
    - 개작된 프로그램에 대한 배포상의 제한조건이 별도로 없다면 모든 사람에게 허용(사적 소유 > 공적 소유)
    - GNU GPL 은 카피레프트를 실제 구현한 라이선스

> **자유 소프트웨어**
> 1. 목적에 상관없이 프로그램을 실행시킬 수 있는 자유
> 2. 프로그램이 어떻게 동작하는지 학습하고, 필요에 따라서 프로그램을 개작할 수 있는 자유(실제로 소스코드 이용 가능해야 함)
> 3. 무료 또는 유료로 프로그램을 재배포할 수 있는 자유
> 4. 프로그램을 개선시킬 수 있는 자유와 개선된 이점을 공동체 전체가 누릴 수 있도록 발표할 수 있는 자유

**주요 라이선스**는 다음과 같습니다.

- **GPL(General Public License)**
    - FSF 의 창시자인 리처드 스톨먼이 GNU GPL 에서 다섯 가지 의무를 저작권의 한 부분으로 강제
    1. 컴퓨터 프로그램은 어떠한 목적으로든지 사용할 수 있다. 다만 법으로 제한하는 행위는 할 수 없다.
    2. 컴퓨터 프로그램의 실행 복사본은 언제나 프로그램의 소스 코드와 함께 판매하거나 소스 코드를 무료로 배포해야 한다.
    3. 컴퓨터 프로그램의 소스 코드를 용도에 따라 변경할 수 있다.
    4. 변경된 컴퓨터 프로그램 역시 프로그램의 소스 코드를 반드시 공개 배포해야 한다.
    5. 변경된 컴퓨터 프로그램 역시 반드시 똑같은 라이선스인 GPL 라이선스를 적용해야 한다.

> **GPLv1**
> - 1989년 1월 발표, 사람이 이해하기 쉬운 코드를 같이 배포해야 한다는 조건 추가
>
> **GPLv2**
> - 1991년 6월 발표, 특허로 인해 소스코드 공개가 불가능한 경우 실행 바이너리 프로그램까지 배포할 수 없도록 보완
>
> **GPLv3**
> - 2007년 6월 발표, 소프트웨어 특허 대처법, 다른 라이선스와의 호환성, 원시 코드 구성 부분, 디지털 제한 권리 관련 내용 추가

- **LGPL(Library/Lesser General Public License)**
    - 1991년 6월, 리처드 스톨먼에 의해 GPL 라이선스의 강력한 카피레프트 조건과 단순한 사용 허가를 위한 절충안 발표
    - 주로 소프트웨어 라이브러리에 사용되어 자유 소프트웨어뿐 아니라 독점 소프트웨어에서도 사용 가능하도록 됨
    - 하지만 LGPL 적용 소스 코드 수정시 2차적 파생물 저작물에 해당하므로 라이브러리 소스 코드를 반드시 제공해야 함

- **BSD(Berkeley Software Distribution)**
    - 버클리의 캘리포니아 대학에서 배포하는 공개 소프트웨어 라이선스
    - 누구나 개작 가능, 수정본 배포 가능. 의무적 재배포 사항이 없어 원시 소스코드 비공개 허용. 상용 사용 가능

- **아파치(Apache)**
    - 아파치 소프트웨어 재단에서 자체적으로 만든 소프트웨어에 대한 라이선스 규정
    - 누구든 아파치 소프트웨어의 부분 혹은 전체를 개인적, 상업적 목적으로 이용 가능
    - 재배포 시 아파치 라이선스 2.0 소프트웨어임을 명확히 밝히면 수정한 소스 코드를 반드시 포함시키지 않아도 됨
    - 대표적으로 Apache HTTP Server, Hadoop, Hbase, Tomcat 등

- **MPL(Mozilla Public License)**
    - 모질라 재단에서 규정한 라이선스로 BSD 와 GPL 의 혼합적 성격
    - 수정 시 소스 코드 공개는 필수이지만 MPL 소스를 제외한 소스는 공개하지 않아도 됨

- **MIT(Massachusetts Institute of Technology)**
    - 미국 MIT 대학의 BSD 기초한 라이선스
    - 라이선스와 저작권 관련 명시만 지키면 됨
    - X Window System, JQuery, Node.js 등

**리눅스의 역사**는 다음과 같습니다.

1987년 개발된 교육용 유닉스인 미닉스를 토대로 1991년 리누스 토발즈가 POSIX 에 호환되는 운영체제 커널을 만들 목적으로 리눅스 개발했습니다.
리눅스는 0.02 버전을 10월에 공식 발표한 이후로 전 세계 개발자들의 도움으로 발전했습니다.

초기 리눅스는 운영체제의 핵심인 커널(Kernel)을 지칭하였으나,
GNU 프로젝트의 라이브러리와 도구들이 포함되면서 하나의 운영체제로 발전하였습니다. 이러한 운영체제를 GNU/Linux 라고 합니다.

> **커널**
> - 시스템 부팅 시 로드되는 커널은 운영체제의 뇌에 해당
> - 주된 역할은 시스템의 하드웨어의 효율적 제어 (메모리, CPU, 디스크, 단말기, 프린터 등)
> - 활용도를 높이기 위한 스케줄링 및 실행중인 프로그램 관리, 자료관리

또한 **리눅스 배포판**이란, 리눅스 커널 이외의 핵심적인 부분을 GNU 정신을 바탕으로 만들어진 다양한 자유 소프트웨어와 공개 프로그램을
모아서 하나의 운영체제로 만든 것을 말합니다.

- **리눅스 배포판**
    - 최초의 배포판은 피터 맥도널드의 SLS, 패트릭 볼커딩의 슬랙웨어, 이안 머독에 의한 데비안 프로젝트
    - 분류(패키지 관리 기법에 따라 분류됨)
        - **슬랙웨어**: 최상단에서 최대한 수정되어 배포, 새로운 적용 및 수정이 어려움. SuSE, Porteus, Vector Linux, Salix OS 등
        - **데비안**: dpkg 및 apt 도구 사용. Knoppix, Corel, Lindows, Ubuntu, Linux Mint, Elementary OS 등
        - **레드햇**: rpm 및 yum 도구 사용. RHEL, CentOS, Fedora, Oracle Linux, Scientific Linux, Asianux 등
    - 수세와 우분투 리눅스가 각 계파의 리더격임

소프트웨어 패키지 의존성을 자동으로 해결해주지 않는 보수적인 슬랙웨어에 비해 데비안은 패키지 관리 면에서
사용자친화적이기 때문에 쉽게 대중화되었습니다. 레드햇 또한 독자적인 패키지 관리 툴이 존재하여 인기가 많으며,
2003년 배포된 Red Hat Linux 9 까지만 무상 배포되었고 현재 RHEL의 유료 배포판을 지원합니다.
레드햇의 무료 배포판은 현재 fedora 오픈 소스 프로젝트로 관리되며, RHEL 의 복제판인 CentOs 도 2014년 흡수되었습니다.

- **리눅스 동향**
    - 리눅스는 초기부터 주로 서버로 이용됨
    - 자유 소프트웨어의 이점으로 다양한 분야로 진출 (서버, 데스크톱 및 개발, 임베디드)
    - 서버 및 슈퍼컴퓨팅에서 우수, 데스크톱은 우분투가 각광, 모바일 분야 및 스마트 TV, IVI, 자동차 등에서도 활용
    - 나아가 클라우드 컴퓨팅 인프라 구축과 빅데이터 및 사물인터넷 환경에서도 중추적인 역할을 수행할 것으로 사료

- **리눅스 클러스터링(Linux Clustering)**
    - 단말 제어 장치와 그에 접속된 복수의 단말의 총칭. 서버 분야에서는 여러 대의 컴퓨터를 연결하여 하나처럼 활용하는 시스템 지칭
    - **고계산용 클러스터(HPC)**: 주로 과학계산용. 병렬 컴퓨터로 슈퍼컴퓨터의 성능
    - **부하분산 클러스터(LVS)**: 대규모의 서비스 제공 목적. 이용자가 많은 웹 서비스 등에 활용. 부하 분산을 위한 로드밸런서를 둠
    - **고가용성 클러스터(HA)**: 지속적인 서비스 제공 목적. LVS 와 연동하여 많이 사용. Primary Node 와 Backup Node 의 커버링 구성

**임베디드 시스템(Embedded System)**, **클라우드 컴퓨팅(Cloud Computing)**, **빅 데이터(Big Data)**, **사물인터넷(IoT)** 등
리눅스가 활용되는 다양한 분야가 존재합니다.    

### 1-2. 리눅스 시스템의 이해

### 리눅스와 하드웨어

리눅스 설치 시 사용 목적에 따른 적절한 리눅스 배포판과 이에 맞는 하드웨어를 선택해야 합니다.
배포판마다 지원하는 아키텍쳐가 다르기 때문에 시스템에서 사용하는 CPU 를 지원하는 리눅스를 고려해야 합니다.

- **CPU**
    - 인텔의 x86 계열과 AMD 계열이 대표적이며, CPU 가 32비트인지 64비트인지에 따라 지원되는 메모리 양이 다르므로 이것도 고려해야 함
    - 추가적으로 클라우드 인프라 환경에서 사용한다면 가상화 기술 지원 여부도 확인
- **메모리(RAM)**
    - 메모리의 용량은 하드디스크 일부 공간을 램처럼 사용하는 Swap 파티션 설정과 관련이 있으므로 꼭 확인
    - 32비트 리눅스에서는 페이징 기법의 차이로 4GB 이상의 램을 인식할 수 없음
    - 64비트 리눅스에서는 대용량 메모리 지원
- **하드디스크 드라이브**
    - 하드디스크 인터페이스인 IDE(ATA), E-IDE, SCSI, S-ATA 등을 지원
    - 초고속 반도체 메모리를 저장 매체로 사용하는 USB 메모리나 SSD 도 지원
    - 하드디스크 드라이브는 파티션 변경이나 스왑 등 설정할 영역이 존재 (IDE 는 /dev/hdx 형식으로, SCSI 는 /dev/sdx 형식으로 관리)
- **모니터와 비디오 어댑터**
    - X-Window 기반의 GUI 환경에서 고려 대상. 장치에 맞는 정확한 드라이버를 사용해야 함
- **네트워크 인터페이스**
    - 이더넷(Ethernet), 모뎀, ISDN, AX.25, ATM 등의 네트워크 인터페이스 지원
    - 특히 이더넷 카드는 LAN 어댑터 제조사 상관없이 대부분 지원. 무선랜 어댑터도 지원
    - 네트워크 설정을 위해 IP 주소, 넷마스크, 게이트웨이 주소, DNS 주소 등을 잘 설정해야 함
- **키보드 및 마우스**
    - 현존 대부분을 지원. X-Window 환경에서 마우스 휠도 지원
- **CD-ROM 및 DVD-ROM**
    - 하드디스크 인터페이스와 같이 대부분을 파일 형식으로 자동 인식되어 관리됨
- **기타 하드웨어**
    - 사운드카드와 프린터 등 데스크탑 목적 하드웨어도 지원

**RAID(Redundant Array of Independent Disks)** 는 여러 개의 하드디스크가 있을 때 동일한 데이터를 다른 위치에 중복해서 저장하는
방법입니다. 운영체제에서 하나의 RAID 는 논리적으로 하나의 디스크로 인식하여 처리합니다.

- **RAID 의 이용**
    - 초기에는 저용량 하드디스크를 하나의 디스크로 확장하여 사용하는 것이 주류
    - 현재는 백업을 가능하게 하고 안정적인 데이터의 보존과 유지 기능, 속도 향상 등에 사용
    - 소프트웨어적 RAID 는 비용적인 측면에서 유리하나, 성능 면에서는 하드웨어 RAID 가 좋음
- **RAID 에서 사용하는 기술**
    - 스트라이핑(Striping): 연속된 데이터를 여러 개의 디스크에 라운드로빈 방식으로 기록하는 기술. 여러 디스크에 동시적으로 접근시 유리
    - 미러링(Mirroring): 디스크에 에러 발생 시 데이터의 손실을 막기 위해 추가적으로 하나 이상의 장치에 중복 저장하는 기술
- **RAID 의 종류**
    - RAID-0: 스트라이핑 기술을 사용하여 빠른 입출력 속도 제공. 중복이나 패리티 없이 디스크에 분산 기록. 따라서 오류시 복구 불가능
    - RAID-1: 미러링 기술을 사용하여 두 개의 디스크에 데이터를 동일하게 기록.
    동시 읽기가 가능해 읽기 속도는 향상되나 쓰기는 단일 디스크와 같음. 오류시 복구 능력 탁월하지만, 중복 저장으로 디스크 낭비가 50%에 이름
    - RAID-2: 디스크들은 스트라이핑 기술을 사용하고, 에러 감지 및 수정을 위해 ECC(Error Check & Correction) 정보를 활용
    - RAID-3: 스트라이핑 기술을 사용하여 디스크를 구성하고, 패리티 정보를 저장하기 위해 별도로 하나의 디스크 사용.
    입출력 작업이 동시에 모든 디스크에 대해 이루어지므로 입출력을 겹치게 할 수는 없음. 보통 대형 레코드가 많은 시스템에서 사용.
    - RAID-4: 블록 형태의 스트라이핑 기술을 사용하여 디스크 구성하는데, 이는 단일 디스크로부터 레코드를 읽을 수 있고 데이터를
    읽을 때 중첩 입출력의 장점이 있음
    - RAID-5: 패리티 정보를 이용하여 커버하며 최소 3개의 디스크로 구성. 패리티는 각 디스크에 분산 기록됨. RAID-0 의 단점인 결합
    허용을 지원하지 않는 점과 RAID-1 의 저장공간 비효율성을 보완한 레벨로 디스크 개수를 늘릴수록 저장 효율성이 높아짐.
    - RAID-6: RAID-5 에서 디스크에 2차 패리티 구성을 포함하여 매우 높은 고장 대비 능력 발휘. 2개의 디스크 오류에도 데이터 읽기 가능.
    최소 4개의 디스크로 구성해야 하며, RAID-5 에 비해 공간 효율성이 떨어짐
    - RAID-7: 하드웨어 컨트롤러에 내장되어 있는 실시간 운영체제를 사용하여 구성하는 방식으로 속도가 빠른 버스를 이용.
    - RAID 0+1: 디스크 2개를 RAID-0 의 스트라이핑 기술로, 다시 RAID-1 의 미러링으로 구성하는 방식. 최소 4개 필요
    - RAID-10: RAID 0+1 의 반대 개념으로 디스크 2개를 먼저 미러링하고 다시 스트라이핑
    - RAID-53: RAID-3 방식에 별도로 스트라이프 어레이를 구성하는 방식. 보다 높은 성능을 제공하지만 구성 비용이 많이 듬

**LVM(Local Volume Manager)** 이란, 논리적으로 유연하게 파티션을 분할 관리하는 방법입니다.

- **LVM** 은 찰흙과 같은 개념으로 이해하면 좋은데, 고정적인 여러 개의 하드디스크를 논리적으로 원하는 크기와 개수로 파티셔닝 가능하게 함
- 사용중인 파티션의 크기를 줄이거나 늘릴 수 있으며, 파티션 확장은 디스크 추가 이후 간단한 명령만으로 데이터 이전 없이 손쉽게 가능
- **LVM 구성도와 관련 용어**
    - 물리적 볼륨(PV): 실제 디스크에 물리적으로 분할한 파티션. (/dev/sdb1, /dev/sdc1 등)
    - 볼륨 그룹(VG): 물리적 볼륨이 모여서 생성되는 덩어리. PE(Physical Extent)의 큰 덩어리.
    - 논리적 볼륨(LV): 볼륨 그룹에서 사용자가 필요한 만큼 할당하여 만들어지는 공간. 물리적으로는 디스크에서 분할하여 사용하는 파티션.
    - 물리적 확장(PE): 물리적 볼륨에서 나누어 사용하는 일종의 블록 같은 영역. 보통 1PE 가 4MB 정도씩 할당됨

### 리눅스의 구조

**부트 매니저(Boot Manager)** 란 부팅을 도와주는 프로그램으로, 한 컴퓨터에 여러 운영체제가 설치된 경우 선택하여 부팅할 수 있도록 합니다.
부트 매니저는 부트 로더라고도 부릅니다. 이것은 하드디스크의 맨 앞쪽 영역인 MBR(Master Boot Record) 에 설치되며,
MBR 은 0번 섹터에 512 바이트 크기입니다. MBR 에는 부트 매니저가 설치됨과 함께 파티션 정보가 기록됩니다.

리눅스의 대표적인 부트 매니저 프로그램은 다음과 같습니다.

- LILO(Linux Loader): 파일 시스템 구애 없이 플로피 디스크와 하드 디스크를 이용한 부팅 지원
- **GRUB(Grand Unified BootLoader)**
    - GNU 에서 만든 부트로더로 LILO 보다 다양한 파일 시스템을 지원하고 부팅시 커널 인자를 조정하여 동적인 부팅을 지원함
    - 메뉴 인터페이스 방식과 bash 와 같은 명령행 인터페이스 또한 제공 (그래픽 메뉴, 그림 삽입 가능)
    - 레드햇의 경우 /boot/grub/grub.conf 파일에서 설정. 재부팅시 반영
- GRUB 의 부팅 모드
    - 메뉴 화면에서 지정된 키를 입력하여 여러 동작 가능
    - \[a]: grub.conf 에서 커널과 관련된 부분의 매개변수를 추가할 수 있게 해줌
    - \[e]: grub.conf 에 등록된 부팅 목록의 모든 항목을 직접 편집할 수 있도록 해줌. 파일을 변경하진 않고 현재 부팅 시에만 일시적으로 적용
        - e: 커서가 위치한 줄 편집
        - d: 커서가 위치한 줄 삭제
        - o: 명령 줄을 커서가 위치한 줄 아래에 추가
        - O: 명령 줄을 커서가 위치한 줄 위에 추가
        - b: 부팅 시작(최종 편집 후 부팅)
    - \[c]: bash 셸과 유사한 상호대화식 명령행 모드로 진입. TAB, ESC 키 사용 가능하며, 마지막에 'boot' 입력하면 부팅이 됨
- GRUB 의 환경 설정 파일
    - 환경 설정 파일은 /boot/grub/grub.conf 이며, 리눅스와 윈도우 멀티 부팅 환경인 경우 이 파일 내의 title 영역에 각각의 설정이 나타남
    - (교재에서 각 라인에 대한 의미를 확인할 것.)

**디렉토리(Directory)** 란 파일을 보관하는 곳으로써 리눅스에서는 최상위 root(/) 를 중심으로 트리 형식으로 하위 디렉토리 및 파일이
계층적으로 분포됩니다.

- **/**: 최상위 루트 디렉토리
- **/bin**: 실행 파일 모음. 보통 PATH 환경변수 경로에 설정되어 있음 (cp, mkdir, rmdir, mv, rm, cat 등 명령)
- **/boot**: 부팅 이미지 파일이나 커널 등 시스템 부팅 시 필요한 파일 모음. grub 관련 파일도 존재
- **/dev**: 물리적 디바이스 장치들이 파일 형식으로 저장됨
- **/etc**: 시스템 환경 설정 파일 및 부팅과 관련된 여러 스크립트 파일 모음. 이 설정들을 읽어 관련 프로그램들이 실행됨
- **/home**: 개인 사용자들의 홈 디렉토리가 모여 있음
- **/lib**: 각종 라이브러리 모음. 커널 모듈도 들어 있음
- **/lost+found**: fsck 명령어를 이용하여 파일 시스템을 복구할 때 작업하는 디렉토리 RHEL 7 버전부터는 사용되지 않음
- **/mnt**: CD-ROM, 플로피디스크, 하드디스크, 네트워크 파일 시스템 등을 마운트할 때 포인트가 되는 디렉토리.
최근에는 장치별로 /media, /net 등이 추가 제공되기도 함
- **/misc**: 자동 마운트 프로그램인 autofs 에 의해 사용되는 디렉토리
- **/opt**: 응용 프로그램들의 설치를 위해 사용되는 디렉토리
- **/proc**: 가상 파일 시스템으로 시스템에서 운영되고 있는 다양한 프로세스의 상태 정보, 하드웨어 정보, 기타 시스템 정보 등을 담고 있음
- **/root**: 시스템 관리자인 root 의 사용자 홈 디렉토리
- **/sbin**: System Binary 의 약자로 주로 시스템 관리에 대한 명령어들이 들어 있는 디렉토리. 보통 수퍼유저인 root 가 사용.
시스템 종료 명령, 네트워크 인터페이스 설정 명령, 시스템 점검과 복구 등의 명령어
- **/tmp**: 임시 저장 디렉토리로서 각종 프로그램이나 소켓 파일, 프로세스 작업을 할 때 임시로 생성되는 파일을 저장하는 공간
- **/usr**: 시스템 운영에 필요한 명령, 응용 프로그램들이 위치하는 디렉토리. 커널 소스, C 헤더 파일, C 컴파일러와 같은 개발 도구,
apache 나 mysql, php 등 모두 이 디렉토리의 하위에 설치됨. /usr/bin, /usr/sbin 에는 주요 응용프로그램의 명령어들이 존재함.
로컬에서 응용프로그램을 추가로 설치할 때 사용되는 /usr/local 등도 존재
- **/var**: 시스템 운영 로그 파일과 스풀링과 같은 가변적인 데이터를 보관하는 디렉토리. 메일 서버의 경우 수신 메일 보관함 존재
- /media, /selinux, /srv, /sys, /cgroup, /lib64, /run 등 추가로 존재

**부팅(Booting)** 은 하드웨어적 단계와 프로그램 메모리 적재의 소프트웨어적 단계로 나눠집니다.

- 하드디스크에 설치된 운영체제의 부팅 과정
    1. 컴퓨터 전원을 켜면 바이오스는 컴퓨터에 장착된 하드웨어를 점검한다.
    2. 바이오스는 하드웨어 검사가 끝나면 CMOS 에 설정된 첫 번째 부팅 하드디스크를 확인한다.
    3. 첫 번째 하드디스크의 MBR 영역에 있는 부트 매니저 프로그램을 실행한다.
    4. 부트 매니저 프로그램은 관련 환경 설정 파일을 참고하여 운영체제 부팅을 시작한다.
- **리눅스의 부팅**
    - 리눅스의 부팅은 GRUB 의 시작부터 텍스트 기반 콘솔 로그인 화면 혹은 X-Window 가 구동되어 로그인 창이 나타나기까지를 지칭
    - **하드웨어 인식 단계**: 하드웨어를 인식하고, grub 부트 메뉴에서 [a] 혹은 [e] 로 매개변수=값을 추가로 입력
    - **소프트웨어 구동 단계**
        - 부팅 시 커널이 로드되면 커널은 우선 루트 파일 시스템을 읽기 전용 형태로 마운트, 검사 후 쓰기 가능 형태로 다시 마운트
        - 이후 커널은 init 프로세스를 발생시키는데, 리눅스 부팅과 관련된 소프트웨어 구동은 init 프로세스에 위임됨
        - init 은 /etc/init 디렉토리 안의 환경 설정 파일을 읽어 동작

> **init 프로세스 관련 환경 설정 파일**
> - /etc/inittab: 부팅과 관련된 실행레벨(Runlevel) 정의
> - /etc/init/rcS.conf: 시스템 초기화 관련 설정. /etc/rc.d/rc.sysinit 스크립트 실행하여 호스트명 설정, 시스템 점검, RAID 및 LVM
> 장치 활성화, 쿼터 설정 활성화 등 진행
> - /etc/init/rc.conf: 각 레벨별 진행되는 내용 설정 파일. /etc/rc.d/rc 스크립트 실행. 이 스크립트는 런레벨 3인 경우
> /etc/rc.d/rc3.d 디렉토리의 실행 데몬 스크립트 중 S 로 시작되는 것을 찾아 부팅 시 실행함
> - /etc/rc.d/rc.local: 런레벨 2, 3, 5 에서 가장 마지막에 실행되는 파일로써, 보통 사용자가 부팅 시에 필요한 서비스 구동

- **실행 레벨(Runlevel)**
    - init 데몬 프로세스에 의해 수행되어질 내용이나 시스템 초기화 등을 정의해둔 여러 모드. 리눅스는 총 8개
    - 그래픽 환경은 런레벨 5, 텍스트 환경은 런레벨 3 로 부팅
    - **0**: 시스템 중지(종료). 기본값으로 설정해서는 안됨
    - **1**: 단일 사용자 모드. 로그인 없이 root 로 부팅하여 일종의 관리자 모드 역할. root 패스워드 분실 혹은 파일 시스템이나 시스템
    점검 및 복구 시 접근
    - **2**: 네트워크 사용하지 않는 다중 사용자 모드
    - **3**: 네트워크 지원하는 다중 사용자 모드. 가장 보편적 레벨이며, X-Window 사용하지 않아 메모리 효율적 사용 가능
    - **4**: 사용되지 않음. 사용자가 정의하여 사용 가능
    - **5**: X-Window 를 사용하는 다중 사용자 모드. 최근 배포판에서 기본 설정임
    - **6**: 시스템 재부팅 레벨. 기본값으로 설정해서는 안됨

0~6 까지 7개의 런레벨 외에 emergency 모드라 부르는 S 또는 s 모드는 1 과 유사하나 관련 프로세스나 데몬을 최소화하여
유지 보수나 점검에 적합합니다.

- **로그인**
    - 런레벨 3인 경우 CTRL+ALT+F1~F6 으로 6개의 가상 콘솔 통해 로그인
    - getty(mingetty) 프로그램이 터미널이나 콘솔에 로그인 프로그램을 실행. 이때, /etc/issue 의 내용이 상단에 출력됨
    - 런레벨 5인 경우 CTRL+ALT+F7 (배포판에 따라 F1) 에 그래픽하게 나타남
    - /etc/issue 는 로컬, /etc/issue.net 은 텔넷을 통한 네트워크 접속 시 출력되는 메시지 기록
    - /etc/motd 는 로그인 성공 시 보여주는 메시지
- **로그아웃**
    - 자원 효율성 및 보안의 측면에서 로그아웃은 필수 (logout, exit 혹은 메뉴 선택으로)
    - root 사용자가 /etc/profile 의'TMOUT=초' 로 지정하면 지정된 시간동안 작업이 없을 시 해당 사용자를 강제 로그아웃 시킴
    
**시스템 종료(Shutdown)** 를 위해 터미널 환경에서 shutdown, halt, reboot, poweroff, init 등의 명령이 사용됩니다.

- **shutdown**
    - root 권한자만 실행 가능
    - **```# shutdown [option] 시간 [경고메시지]```**
    - 시간은 +m 형식 혹은 hh:mm 형식으로 설정 가능
    - 옵션
        - -r: 재부팅(reboot)
        - -h: 종료(halt)
        - -c: 예약된 shutdown 명령 취소
        - -k: 실제로 shutdown 하지 않고 경고 메시지만 접속 사용자들에게 전송
- **reboot**
    - 시스템 재시작 명령. 로컬 사용자라면 모두 사용 가능
    - **```$ reboot [option]```**
    - 옵션
        - -w: 재부팅 없이 /var/log/wtmp 에 셧다운 기록만 저장
- **halt**
    - 시스템 종료 명령. 로컬 사용자라면 모두 사용 가능
    - **```$ halt [option]```**
    - 옵션
        - -p: 시스템 종료 후 전원까지 끄는 경우 사용(--poweroff)
- **poweroff**
    - 시스템 종료 및 전원을 끄는 명령
- **init, telinit**
    - 모든 프로세스의 조상인 init 프로세스에 직접 요청하여 런레벨을 변경하는 명령
    - 빠르게 실행되지만, 실행중인 프로세스를 무조건적으로 종료하므로 권장되지 않음
    - **```$ init [실행 레벨]```**
    - ```init 0``` 은 시스템 즉시 종료, ```init 6``` 은 시스템 즉시 재부팅

**파일 시스템(File System)** 이란, 운영체제가 파티션이나 디스크에 데이터를 저장하고, 읽고, 쓰고, 찾기 위해 구성하는 일련의 체계를
의미하는데, 운영체제가 사용자에게 제공하는 가장 직접적인 서비스 형태 중 하나입니다.

파일 시스템의 구성은 운영체제 설치 시에 일어나며, 파티션 분할 작업 후 포맷(Format)을 가장 먼저 하게 되는데,
이것은 파일을 저장하기 위해 디스크를 일정한 크기로 분할하고 주소를 설정하는 작업이라고 할 수 있습니다.
각각의 운영체제들은 포맷이라는 작업을 통해 고유한 파일 시스템을 구축하게 되고, 다양한 규칙들을 설정하게 됩니다.

대부분의 운영체제들은 파일이라는 단위로 저장하고, 파일에 이름을 부여한 뒤에 디렉토리에 저장합니다. 이 과정에서 파일명의 길이를 제한하기도
하고, 어떤 문자들이 사용될 수 있는지를 정하기도 합니다. 파일명에 확장자를 쓰도록 지정하기도 하며, 확장자의 길이도 제한할 수 있습니다.
또한 파일 시스템은 지원하는 파티션의 개수, 크기, 파일 크기 등에도 직접적인 관계가 있으며, 파일 복구와 같은 기능을 부여하기도 합니다.

따라서 파일 시스템의 성능은 운영체제의 성능에도 밀접한 관계가 있다고 볼 수 있습니다.

- **파일 시스템의 기능**
    1. 사용자가 파일을 생성, 수정, 삭제할 수 있도록 제공
    2. 사용자가 파일을 사용하기 적합한 형태의 구조로 구성하고, 다양한 추가 정보 제공
    3. 다른 사용자와의 파일을 공동으로 사용할 수 있는 적절한 제어 방법 제공
    4. 파일 공유를 위하여 판독 접근, 기록 접근, 수행 접근 등의 다양한 접근 제어 방법 제공
    5. 정보 손실이나 파괴를 방지하기 위하여 백업이나 복구를 위한 기능 준비
    6. 사용자와 장치 간의 독립성을 유지하기 위해, 사용자가 물리적인 장치 이름 대신에 적절한 이름 제공
    7. 정보가 안전하게 보호되고 비밀이 보장될 수 있도록 정보의 암호화 및 복호화 기능 제공
    8. 사용자가 파일이나 디렉토리에 접근하기 쉬운 인터페이스 및 명령어 제공
    
- **리눅스의 파일 시스템**
    - 리눅스는 다양한 파일 시스템 지원 (ext > ext2 > ext3, 저널링 파일 시스템 > ext4)
    - 저널링 파일 시스템: 파일 시스템에 대한 변경사항을 반영하기 전에 저널이라 부르는 로그에 저장하여 추적이 가능하게 함.
    데이터 복구 확률을 높여줌
    - ext2, ext3, ext4, nfs, Reiser FS, XFS, JFS 등 지원

> 각 파일 시스템의 특징을 교재에서 참조할 것
>

- **리눅스 파일 시스템의 구조**
    - 파티션 분할 이후 Format(mkfs) 작업을 통해 파일시스템을 생성
    - 파일 시스템에서 **기본적으로 데이터를 저장하는 단위는 블록(Block)**으로써, 기본 4KB 로 지정됨
    - 파일 시스템은 크게 부트 블록(Boot Block, 또는 부트 섹터)과 여러 개의 블록 그룹(Block Group, N-1개)으로 나뉘어짐
    - 블록 그룹은 그룹내 모든 메타 정보를 담고 있는 **슈퍼 블록(Super Block)**, **그룹 기술자(Group Descriptors)**,
    **블록 비트맵(Block Bitmap)**, **아이노드 비트맵(Inode Bitmap)**, **아이노드 테이블(Inode Table, 또는 아이노드 블록)**,
    **데이터 블록(Data Blocks)** 으로 구성됨
    - 슈퍼 블록과 블록 기술자는 모든 메타정보가 있어 중요하므로 모든 블록에 걸쳐 사본이 백업됨
    - **슈퍼 블록**: 특정 파일 시스템임을 알리는 매직 넘버, 마운트 정보, 전체 아이노드 수 및 남은 수, 전체 블록 수 및 남은 수,
    블록 그룹 번호, 블록 크기, 그룹 당 블록 수 등
    - **그룹 기술자**: 각각의 블록 그룹을 기술하는 자료 구조로서, 저장되는 주요 정보는 블록 비트맵, 아이노드 비트맵,
    아이노드 테이블(또는 아이노드 블록)
    - **블록 비트맵**: 블록의 사용 현황을 bit 로 표현
    - **아이노드 비트맵**: 아이노드 할당 상태를 bit 로 표현
    - **아이노드 테이블**: 아이노드 정보가 들어있는 영역. ls -l 명령 시 나타내는 파일 관련 정보가 저장됨
    - **데이터 블록**: 파일이 보관해야 하는 정보를 저장하는 영역(파일 데이터)
        - 추가 데이터 블록의 포인터가 동적으로 할당되는 간접 블록, 아이노드나 간접 블록 안의 데이터 블록의 주소를 저장하는 홀

> **아이노드(Inode)**
> - 일종의 자료구조로 각각의 파일은 하나의 아이노드를 할당받아 관리
> - 파일 정보 저장 (아이노드 넘버, 접근 모드, 파일 형식, 소유자 정보, 파일 크기, 타임 스탬프 등)
> - 파일 시스템 생성 시 전체의 약 1% 공간을 아이노드에 할당하므로, 생성 가능 파일의 최대 개수도 한정되어 있음

> **저널링 기술과 저널링 파일 시스템**
> - 기존의 fsck 에 걸리는 시간을 단축하기 위해 데이터를 디스크에 쓰기 전에 로그에 남겨 비정상적 종료에도 보다 빠르고 안정적인 복구기능 제공
> - fsck 로 복구시 슈퍼 블록, 비트맵, 아이노드 등을 모두 검사하므로 많은 시간이 걸렸지만,
> - 저널링 파일 시스템은 수정 내역을 블록에 적용 전 로그에 수정된 내용을 저장하므로 복구시 단지 로그만 검사하면 됨
> - 로그 기록 중 중지되었다면 아직 실제 적용 전이므로 문제가 되지 않고, 블록에 적용 중 중지되었다면 로그만 살펴보면 되니 안정성이 높음
> - ext3, ext4, XFS, JFS, ReiserFS 등

### X 윈도

(생략)

### 셸(Shell)

**셸**은 커널과 사용자간 다리 역할을 하는 것으로 사용자로부터 명령을 받아 그것을 해석하고 프로그램을 실행시키는 역할을 합니다.

여러 개의 셸이 있는데, 사용자가 로그인을 하면 사용자에게 설정된 셸이 부여됩니다. 따라서 사용자에게 셸을 부여하지 않으면
시스템에 로그인 하더라도 명령 수행이 불가능하여 로그인을 막는 효과와 동일하다고 볼 수 있습니다.

현재 가장 많이 사용되는 표준 셸은 ksh 과 csh 의 장점을 결합한 bash 셸입니다.

- 셸 종류: Bourne Shell(sh), bash, csh, tcsh, ksh 등
- 셸 확인: ```$ echo $SHELL``` > ```/bin/bash```, ```$ chsh -l```
- 셸 변경: ```$ chsh``` > 패스워드 입력 후 변경할 셸의 절대 경로 입력
- 사용자의 로그인 셸 정보 확인: /etc/passwd 설정 파일 내 사용자 라인의 7번째 필드에 기록

```
~$ grep daesungra /etc/passwd
daesungra:x:500:500::/home/daesungra:/bin/bash
```

**셸 변수**는 ```변수명=값``` 형태로 지정하며, ```$ echo $[변수명]``` 로 값을 확인합니다.

**환경 변수**는 프롬프트 변경, PATH 변경 등과 같이 셸의 환경을 정의하는 중요한 역할을 수행하는 변수입니다.
환경 변수는 env 명령으로 확인할 수 있습니다.

- HOME: 사용자의 홈 디렉토리
- PATH: 실행 파일을 찾는 디렉토리 경로
- LANG: 셸 사용 시 기본으로 지원되는 언어
- TERM: 로그인한 터미널 종류
- PWD: 사용자의 현재 작업 디렉토리
- SHELL: 사용자의 로그인 셸
- USER: 사용자의 이름
- DISPLAY: X 에서 프로그램 실행 시 출력되는 창
- PS1: 프롬프트(Prompt) 변수
- PS2: 2차 프롬프트 변수
- HISTFILE: 히스토리 파일의 절대 경로
- HISTSIZE: 히스토리 파일에 저장되는 명령어의 개수(줄 기준)
- HISTFILESIZE: 히스토리 파일의 파일 크기
- HOSTNAME: 시스템의 호스트명
- MAIL: 도착한 메일이 저장되는 경로
- TMOUT: 사용자가 로그인한 후 일정 시간 동안 작업을 하지 않을 경우에 로그아웃시키는 시간으로 단위는 초(second)
- UID: 사용자의 UID

환경 변수의 사용 예는 다음과 같습니다.

- ```$ mkdir $HOME/data``` > 홈 디렉토리에 디렉토리 추가
- ```$ echo $LANG```, ```$ LANG=C``` > 기본 언어 변경
- ```$ PS1="[\u@\t \W]\$ "``` > 프롬프트 형식 변경

> 주요 프롬프트 형식
> - \d: '요일 월 일' 형태로 날짜를 표시 (ex. "Wed Jan 15")
> - \h: 호스트 이름 표시
> - \s: 사용중인 셸의 이름 표시
> - \t: 24시 형태의 현재 시간 표시 (HH:MM:SS)
> - \T: 12시 형태의 현재 시간 표시 (HH:MM:SS)
> - \@ 12시 형태의 현재 시간에 AM/PM 을 추가로 표시
> - \u: 현재 사용자의 이름 표시
> - \w: 현재 작업 디렉토리를 절대 경로로 표시
> - \W: 현재 작업 디렉토리의 전체 경로 중 마지막 디렉토리만 표시
> - \!: 현재 명령의 히스토리 넘버 표시
> - \\: \ 표시 (백슬래시)

가장 빈번하게 사용되는 **bash 셸의 주요 기능**을 살펴봅니다.

- (1) **명령행 완성 기능**
    - tab 키를 눌러서 작성 중인 명령 혹은 파일이나 디렉토리명을 자동 완성
    - 여러 개가 존재한다면 tab 키를 한번 더 눌러서 목록 확인
    
- (2) **명령어 history 기능**
    - history 관련 셸 환경 변수에 따라 실행했던 모든 명령들이 히스토리 리스트 버퍼에 스택으로 저장
    - 위/아래 방향키로 목록을 찾을 수 있음
    - 사용자별 히스토리 파일인 '~/.bash_history' 에 기록됨 (기록은 로그아웃 시 메모리에 기억된 명령의 목록을 저장)
    - 'history' 혹은 '!' 명령으로 확인

> **!와 히스토리 명령문**
> - !!: 마지막에 사용한 명령 실행
> - !n, !-n: n번째 사용한 명령 실행, 역으로 n번째 사용한 명령 실행
> - !문자열: 가장 최근에 사용한 명령 중 '문자열'로 시작하는 명령을 찾아서 실행
> - !?문자열?: 가장 최근에 사용한 명령 중 '문자열'을 포함하는 명령을 찾아서 실행
> - ^문자열1^문자열2: 마지막에 사용한 명령문의 '문자열1' 을 '문자열2'로 대체한 후 실행

> **히스토리 관련 환경 변수**
> - HISTSIZE: 히스토리 스택의 크기가 지정되어 있는 변수
> - HISTFILESIZE: 실질적인 히스토리 파일의 크기
> - HISTFILE: 히스토리 파일의 경로
> - HISTCONTROL: 중복되어지는 명령에 대한 기록 유무를 지정하는 변수
>     - ```$ export HISTOCONTROL=ignoreboth``` > 연속적으로 중복된 명령은 저장하지 않음
> - HISTTIMEFORMAT: history 명령 실행 시 출력되는 시간 형식 지정할때 사용

- (3) **alias 기능**
    - 별명 기능. 특정 명령어와 옵션, 파라미터 등의 조합을 별명으로 지정하여 간편하게 사용 가능
    - ```$ alias [별명='명령어']```
    - ```$ unalias 별명```
    - ex. ```$ alias ll='ls -alF```

alias 를 재로그인 혹은 시스템 재부팅 시에도 유지하려면, .bashrc 파일에 설정하면 됩니다.

- (4) **명령행 편집 기능**
    - (교재 참조, p106)
    
- (5) **명령 대체(Command Substitution, 또는 명령 치환) 기능**
    - 특정 명령의 결과를 다른 명령어의 인자값으로 사용하는 것
    - 이를 위해 '`' (backquotes) 나 $() 활용
    - ex. ```$ ls -l `which passwd` ```
    - ex. ```$ ls -l $(which passwd)```

- (6) **그룹 명령 실행**
    - 하나의 명령 행에 여러 개의 명령어 동시 사용
    - ';' 기호로 구분, 순차적으로 처리
    - ;: 한 줄에 여러 명령을 나열. 순차 처리
    - ||: 논리적 OR(Logical-OR). 앞의 명령이 성공이면 결과를 출력하고 그렇지 않으면 뒤의 명령을 실행하여 결과 출력
    - &&: 논리적 AND(Logical-AND). 앞의 명령이 성공이어야 뒤의 명령을 수행
    - ex. ```$ ls; sleep 10; ls```
    - ex. ```$ ls; find / -type d > list.txt```
    - ex. ```$ (ls; find / -type d) > list2.txt```
    - ex. ```$ pwd; (cd /; pwd); pwd``` > 그룹 명령 실행 후 원래 위치로 돌아옴!
    - ex. ```$ grep daesung /etc/passwd || echo 'No daesung''``` >
    'daesung' 계정이 존재하면 해당 행을 출력, 아니라면 문자열 출력

- (7) **표준 입출력 제어 기능**
    - 표준 입력은 사용자가 키보드를 이용해 입력하는 값, 표준 출력은 화면에 나타나는 결과
    - 표준 입력(Standard Input, stdin): 입력을 담당하는 키보드.
    - 표준 출력(Standard Output, stdout): 결과값이 보여지는 화면. 셸에서는 숫자값 1로 표기되며, 일반적으로 셸 상태에서 숫자값 1은
    생략해서 사용할 수 있음
    - 표준 에러(Standard Error, stderr): 에러 값이 보여지는 화면. 셸에서는 숫자값 2로 표기
    - ```$ abc 2>/dev/null```

- (8) **리다이렉션(Redirection)**
    - 어떤 프로세스의 입/출력을 표준 입출력이 아닌 다른 입출력으로 변경할 때 사용
    - \>: 프로세스의 출력을 표준 출력에서 다른 출력으로 변경
    - \>>: 프로세스의 출력을 지정한 출력(보통은 파일)에 추가
    - <: 프로세스의 입력을 표준 입력에서 다른 입력으로 변경
    - <<: 기호 뒤에 지정한 문자열을 입력으로 받아 해당 문자열이 나오기 전까지를 표준 입력을 삼아 해당 내용을 출력
    - ```$ cat >> tmp.txt```
    - ```$ mail daesungra < abc.txt```
    - ```$ cat << end```, end 라는 문자열이 입력되기 전까지를 표준 입력으로 삼아 화면에 출력

> **리다이렉션 응용 예**
> - ```$ find / -name '*.txt'```: 결과값, 에러 모두 표준 출력
> - ```$ find / -name '*.txt' 2>/dev/null```: 에러는 버림
> - ```$ find / -name '*.txt' >list.txt```: 결과값(1)은 파일에 저장, 에러는 화면에 출력
> - ```$ find / -name '*.txt' 2>/dev/null > list.txt```: 결과값 파일 저장, 에러는 버림
> - ```$ find / -name '*.txt' 2>error.txt```: 결과값 화면 출력, 에러는 파일에 저장
> - ```$ find / -name '*.txt' 2>error.txt > result.txt```: 결과와 에러 각각 파일에 저장
> - ```$ find / -name '*.txt' > data.txt 2>&1```: 결과값과 에러값을 모두 data.txt 파일에 저장.
> ```$ find / -name '*.txt' &> data.txt``` 와 같음
> - ```$ find / -name '*.bak' 2>>error.txt```: 결과값은 화면에 출력, 에러는 파일에 추가하여 저장

- (9) **파이프(Pipe, '\|')**
    - 프로세스 간 통신을 위해 도입. 어떤 프로세스의 표준 출력이 다른 프로세스의 표준 입력으로 쓰이게 하는 것
    - 여러 개를 사용하여 파이프 라인을 만들 수 있음
    - ex. ```$ ls -alF | more```: ls 의 출력이 more 라는 filter 의 입력으로 사용되어 결과가 한 화면씩 출력
    - ex. ```$ ls | sort | more```, ls 의 출력이 정렬되어 한 화면씩 출력

> **tee 명령**
> - 파이프 연결 출력을 두 갈래로 나눌 때 사용
> - ```$ tee [option] [파일]```
> - -i: 인터럽트를 무시하도록 한다
> - -a: 지정된 파일로 출력을 덮어쓰지 않고, 파일 내용 뒤에 추가한다
> - ex. ```$ ls -l | tee list.txt | more```: 파일의 목록을 list.txt 에 기록함과 동시에 more 를 사용하여 화면에도 출력
> - ex. ```$ ls -l /etc | tee etc.txt | tee /tmp/etc.txt | more```: /etc 하위 목록을 etc.txt 와
> /tmp/etc.txt 에 저장하고 화면에소 한 페이지씩 출력
> - ex. ```$ ls -l /etc | tee etc.txt | tee /dev/pts/0 | more```: /dev/pts/0 터미널은 해당 사용자가 권한이 있어야 하고
> /dev/ 는 생략 가능하나, 콘솔 창인 /dev/tty2 등은 버전에 따라 생략하면 안될 수도 있음

- (10) **작업 제어 기능**
    - 작업을 백그라운드와 포그라운드에서 실행할 수 있으며, 이 작업을 서로 전환하여 실행할 수 있음 (프로세스 관리)

- (11) **산술 연산 기능**
    - expr 명령을 이용
    - ```$ expr 값 연산자 값```, 인자 간에 반드시 한 칸씩만 띄워야 함
    - 값 대신 미리 지정한 변수 사용 가능
    - 연산자: +, -, *, /, %
    - ex. ```$ expr 3 + 2``` >> 5 출력
    - ex. ```$ expr 3 \* 2``` >> 6 출력, 그냥 특수문자 * 는 모든 것을 의미하므로, 백슬래시가 있어야 함

- (12) **프롬프트 제어 기능**
    - 프롬프트를 변경 지정 가능. 환경 변수인 PS1 값을 이용

- (13) **확장된 내부 명령어**
    - bash 자체적으로 해석하는 set, export 등의 내부 명령어(Built-in Command)

**bash 셸 관련 파일 및 디렉토리**는 해당 설정 파일을 사용하는 사용자의 배시 셸에서 지속적으로 적용됩니다.
일시적인 환경 변수나 alias 는 로그아웃 시 사라집니다.

- /etc/profile: 시스템 전체에 적용되는 환경 변수와 시작 관련 프로그램 설정
- /etc/bashrc: 시스템 전체에 적용되는 alias 와 함수 설정
- ~/.bash_profile: 개인 사용자의 환경 설정과 시작 프로그램 설정 관련정보 존재. 로그인 시 읽어들임.
경로, 환경 변수 등의 설정이 들어있고, 사용자가 PATH 와 같은 환경 변수 수정시 사용
- ~/.bashrc: 개인 사용자가 정의한  alias 와 함수
- ~/.bash_logout: 개인 사용자가 로그아웃할 때 수행하는 설정
- /etc/profile.d: 몇몇 응용 프로그램들이 시작할 때 필요한 스크립트가 위치하는 디렉토리.
보통 /etc/profile 에서 호출. 일반 사용자의 alias 설정 등과 관련된 스크립트도 존재

**셸에서 사용하는 특수문자(메타문자, Meta Character)** 는 다음과 같습니다.

- ~: 틸드. 홈 디렉토리
- .: 현재 디렉토리 혹은 명령행 맨 앞에서 source 의 의미인데, 이는 셸 스크립트 등을 실행시킬 때 사용됨
- ..: 한 단계 위 디렉토리
- **' '**: 작은 따옴표. 모든 문자나 특수문자들을 일반문자로 취급
- **" "**: 큰 따옴표. 이것은 $, `, \ 를 제외한 모든 문자를 일반문자로 취급. !(history) 로 예외로 인정
- **`**: 역따옴표는 명령 대체 기능을 수행하는데, 명령의 결과를 대체해서 사용
- \#: 주석 기호
- **$**: 셸 변수 기호. 뒤에 오는 문자열을 변수로 취급
- &: 특정 명령을 후면 작업(background job)으로 실행
- *: 아무것도 없는 경우를 포함한 모든 문자
- ?: 보통 한 문자를 대체할 때 사용. 또한 return 변수로도 쓰이는데, 셸 상에서 내린 명령의 에러 유무를 확인 가능
- (): 부속 shell(subshell)을 뜻하는 기호. 하나의 셸 단위로 묶어줌
- **\\**: 이스케이프(escape, 탈출) 문자. 바로 다음에 오는 특수문자의 기능을 없앰. alias 를 없애기도 함
또한 긴 명령행 입력 시 라인 줄바꿈으로 연장할 때도 사용
- []: bracket 이라고 부르며, 사이에 선택할 수 있는 문자를 나열하여 '~중의 하나' 라고 표현됨.
    - ex. [abc], [.,;], [-_], [*?], [a-c], [a-z], [!0-9], [^chars], [a-zA-Z]
- {}: 사이에 제시된 문자열 중 하나로 대치
    - ex. b{ed,olt,ar}s, b{ar{d,n,k},ed}s
- <: 입력 재지정
- \>: 출력 재지정
- /: 경로명 디렉토리 분리자
- !: 명령문 history

대망의 **셸 프로그래밍(Shell Programming)** 입니다.<br>
셸 프로그래밍이란 셸에서 사용되는 여러 명령어들을 모아 하나의 파일로 만드는 과정을 말하며, 그 결과 만들어지는 파일 또는 프로그램을
**셸 스크립트(Shell Script)** 라고 합니다.

셸은 조건문, 반복문, 변수, 함수 등 기본적인 언어적 특성을 가지고 있어 프로그래밍이 가능합니다.

- **셸 스크립트를 작성하는 방법**
    1. vi 편집기로 파일 생성
    2. 첫줄은 ```#!/bin/bash``` 로 bash 셸을 사용할 것을 명시
    3. 두번째 줄부터 원하는 명령 구문 입력
    4. 스크립트를 실행 가능한 파일로 만들기 (보통 755 권한)
    5. 실행

> **셸 스크립트 실행 시..**
> 1. 해당 스크립트 파일의 절대 혹은 상대 경로를 포함하지 않으면 PATH 변수에서 찾으므로,
> './' 혹은 절대경로가 아닌 자유롭게 사용하고자 한다면 파일이 위치한 경로를 PATH 에 등록해 두어야 합니다.
> 2. 실행 권한을 부여하지 않고 실행하려면,
>     - 앞부분에 sh 명령 붙이기
>     - 앞부분에 source 명령 붙이기
>     - 앞부분에 . 붙이기 (source 와 동일)

- **셸 프로그래밍 문법**
    1. **주석**: # 를 라인 앞에 붙이면 주석 처리됨
    2. **변수**: 셸 프로그래밍에서 변수는 변수형 선언이 필요 없음. 값 할당시 공백이 있으면 안됨
        - **변수명=값**
        - ${변수명}: 변수 값으로 치환
        - ${변수명:=값}: 변수명의 값이 null 이면 지정한 값을 할당하여 저장하고, 아니라면 이미 저장된 값 사용
        - ${변수명:+값}: 기존 변수명에 값이 null 이 아니라면(이미 사용되고 있다면) 지정한 값을 사용, 하지만 저장하지는 않음 (1회 사용)
        - ${변수명:-값}: 기존 변수명에 값이 null 이 아니라면(이미 사용되고 있다면) 그 값을 사용, 아니라면 지정한 값을 대입.
        지정한 값을 저장하지는 않음
        - ${변수명:?값}: 기존에 값이 있으면 그것을 기본값으로 하고, 아니라면 error 를 내면서 지정한 값을 보여줌
        - ${#변수명}: 변수명의 문자열 길이를 반환
        - ${변수명:offset}: 변수명 값에서 offset 만큼 삭제한 후 값을 반환
        - ${변수명:offset:length}: 변수명 값에서 offset 만큼 삭제한 후 length 만큼 센 뒤 값을 반환
        - 관련 환경 변수 **'$IFS'**: 입력 필드 구분자. 보통 스페이스, 탭, 개행 문자를 사용
        - 셸 변수의 출력과 제거
            - set: 현재 정의되어 있는 모든 변수와 그 값을 출력
            - env: export 된 변수의 값만 출력
            - export: 특정 변수의 범위를 환경 데이터 공간으로 전송하여 자식 프로세스에서도 사용 가능하게 함
            - unset: 선언된 변수를 제거
        - **Argument 변수**
            - $0: 실행된 셸 스크립트명
            - $1, $2: 입력된 첫 번째와 두 번째 인자
            - $#: 입력된 인자의 개수
            - $$: 셸 스크립트의 PID
            - $*: 입력된 전체 인자를 하나의 문자열로 변수에 저장 시 사용. 구분자는 $IFS 변수의 첫 번째 문자
            - $@: $* 와 동일하나 IFS 환경 변수를 사용하지 않음 (보통 스페이스)
            - $?: 실행한 뒤의 return 값. 참이면 0, 거짓이면 1 반환
            - $-: 현재 셸이 호출될 때 사용한 옵션들
        - ex. ```$ vim test.sh```
        ```
        #!/bin/bash
        num=2
        echo "This is the ${num}nd"  # This is the 2nd 
        ```
        - ex. ```$ vim ./main```
        ```
        #!/bin/bash
        echo Shell Programming
        name=test
        city=seoul
        echo name is $name
        echo city is $city
        export name
        ./sub
        echo stop main
        ```
        ```$ vim ./sub```
        ```
        #!/bin/bash
        echo start sub
        echo name is $name
        echo city is $city
        echo stop sub
        ```
        ```$ ./main```
        ```
        # 출력 결과~
        Shell Programming
        name is test
        city is seoul
        start sub
        name is test
        city is
        stop sub
        stop main
        ```
    3. **echo 문과 escape 문자**: echo 는 라인을 제어하는 명령해석기이며, -e 옵션과 함께 \\ 로 시작하는 escape 특수문자 사용 가능
        - \\f: 폼피드(Formfeed). 앞 문자열만큼 열을 밀어서 이동시킴
        - \\n: New line 줄바꿈
        - \\r: 캐리지 리턴(Carriage Return). 앞 문자열의 앞부분부터 뒷 문자열만큼 대체하고 반환
        - \\t: 탭만큼 띄움
        - \\: \\ 표기
        - ex. ```$ echo -e "yuloje\ralin"``` > ```alinje``` 뒷 문자열만큼 치환되어 반환됨
    4. **간단한 조건식**
        - 명령행에서 ```$ test 표현식``` 형태로 간단히 비교 가능
        - 셸 스크립트에서는 if 문처럼 조건식이 사용됨. 여기서는 test 명령어 생략하고 [] 이용
        - \[ 와 ] 사이에는 반드시 조건식 외 공백문자가 들어가야 함
        - **\[ 문자열 ]**: 문자열이 빈 문자열이 아니라면 참
        - **\[ 문자열1 = 문자열2 ]**: 같다면 참
        - **\[ 문자열1 != 문자열2 ]**: 다르다면 참
        - **\[ -n 문자열 ]**: 문자열이 null(빈 문자열) 이 아니라면 참
        - **\[ -z 문자열 ]**: 문자열이 null(빈 문자열) 이라면 참
        - **\[ expr1 -eq expr2 ]**: Equal. 두 산술표현식 결과가 같다면 참
        - **\[ expr1 -ne expr2 ]**: Not Equal. 두 산술표현식 결과가 다르다면 참
        - **\[ expr1 -gt expr2 ]**: Greater Then. > 관계라면 참
        - **\[ expr1 -ge expr2 ]**: Greater Equal. >= 관계라면 참
        - **\[ expr1 -lt expr2 ]**: Less Then. < 관계라면 참
        - **\[ expr1 -le expr2 ]**: Less Equal. <= 관계라면 참
        - **\[ ! expr ]**: 결과가 참이면 거짓, 거짓이면 참
        - **\[ expr1 -a expr2 ]**: AND 연산. 둘 다 참이어야 참
        - **\[ expr1 -o expr2 ]**: OR 연산. 둘 중 하나라도 참이면 참
        - **\[ -b FILE ]**: 파일이 블록 디바이스면 참
        - **\[ -c FILE ]**: 파일이 문자 디바이스면 참
        - **\[ -d FILE ]**: 파일이 디렉토리면 참
        - **\[ -e FILE ]**: 파일이 존재하면 참
        - **\[ -f FILE ]**: 파일이 존재하고 정규 파일이면 참 (호환성 문제로 주로 -e 보다 -f 사용)
        - **\[ -g FILE ]**: 파일에 SGID 가 있으면 참
        - **\[ -k FILE ]**: 파일에 Sticky bit 가 있으면 참
        - **\[ -L FILE ]**: 파일이 심볼릭 링크면 참
        - **\[ -p FILE ]**: 파일이 Named pipe 면 참
        - **\[ -r FILE ]**: 현재 사용자가 읽을 수 있는 파일이면 참
        - **\[ -s FILE ]**: 파일이 비어있지 않으면 참
        - **\[ -S FILE ]**: 소켓 디바이스면 참
        - **\[ -t FILE ]**: File Descriptor 가 열려진 터미널이면 참
        - **\[ -u FILE ]**: 파일에 SUID 가 있으면 참
        - **\[ -w FILE ]**: Writable file. 현재 사용자가 쓸 수 있는 파일이면 참
        - **\[ -x FILE ]**: Execute file. 현재 사용자가 실행할 수 있는 파일이면 참
        - **\[ -O FILE ]**: 파일의 소유자가 현재 사용자이면 참
        - **\[ -G FILE ]**: 파일의 그룹이 현재 사용자의 그룹과 같으면 참
        - **\[ FILE1 -nt FILE2 ]**: FILE1 이 보다 새로운 파일(최근 파일)이면 참
        - **\[ FILE1 -ot FILE2 ]**: FILE1 이 보다 오래된 파일이면 참
        - **\[ FILE1 -ef FILE2 ]**: FILE1 이 FILE2 의 하드 링크, 즉 Inode 값이 같으면 참
        - ex. ```$ vim ./ex.sh```
        ```
        #!/bin/bash
        [ "$LOGNAME" = "yuloje" ]  # 로그인한 사용자가 "yuloje" 인지 확인
        echo $?
        ```
        ```$ source ./ex.sh```
        ```
        1
        ```

- **조건문**
    1. **if 문**
        - 형식1: 단일 if 문
        ```
        if [ 조건 ]
        then
            실행문장
        fi
        ```
        - 형식2: if ~ else 문
        ```
        if [ 조건 ]
        then
            실행문장1
        else
            실행문장2
        fi
        ```
        - 형식3: if ~ elif 문 (elif 는 여러 번 사용 가능)
        ```
        if [ 조건1 ]
        then
            실행문장1
        elif [ 조건 ]
        then
            실행문장2
        else
            실행문장3
        fi
        ```
        - ex. ```$ vim ./test.sh```
        ```
        #!/bin/bash
        if [ "$SHELL" - "/bin/bash" ]
        then
            echo "Your login shell is the bash (bourne again shell)"
        else
            echo "Your login shell is not bash but $SHELL"
        fi
        ```
    2. **case 문**
        - case 구문은 오른쪽 괄호와 세미콜론은 반드시 사용해야 하고, esac 로 끝내야 함
        ```
        case 문자열
        in
            정규식1) 명령어1;;
            정규식2) 명령어2;;
        ...
        esac
        ```
        - ex. ```$ vim ./ca1```
        ```
        #!/bin/bash
        echo "1. who 2. date 3. pwd 4. ls -l
        echo "******************************"
        echo "수행하고자 하는 명령어는? (번호를 입력하시오)"
        read number;
        case $number in
            1) who;;
            2) date;;
            3) pwd;;
            4) ls -l;;
            *) echo "없는 번호입니다."
        esac
        ```
    3. **select 문**
        - select 구문은 다른 셸에는 없고 Korn Shell 및 Bash 에만 존재하는 구문으로 간단히 나열할 때 사용
        - in 다음에 나오는 값들이 항목으로 된 메뉴로 생성됨. 생략되면 "$@" 가 됨
        - 형식은 번호를 선택하게 되어 있으며, 사용자에게 번호를 표시해줌
        - "변수" 에 선택된 내용을 저장하고 선택된 번호는 내장 변수인 REPLAY 에 저장하고 "실행문장" 이 실행됨
        ```
        select 변수 in 값1, 값2, ...
            do
                실행문장
            done
        ```
        - ex. ```$ vim ./sele1```
        ```
        #!/bin/bash
        echo "What is your favorite OS?"
        select var in "Linux", "Free BSD", "Windows", "Solaris", "Other"
            do
                echo "You have selected $var."
                break
            done
        ```
        - ```$ ./sele1```
        ```
        What is your favorite OS?
        1) Linux
        2) Free BSD
        3) Windows
        4) Solaris
        5) Other
        #? 1
        You have selected Linux.
        ```

- **반복문**
    1. **for 문**
        -  in 다음에 지정된 범주나 값들이 순차적으로 "변수" 에 담겨 do 이하의 문장 수행
        ```
        for 변수 in 값1, 값2, ...
            do
                실행문장
            done
        ```
        - ex. ```$ vim ./tt4```
        ```
        #!/bin/bash
        for flower in Rose Tulip Lily
            do
                echo $flower
            done
        ```
        - ```$ ./tt4```
        ```
        Rose
        Tulip
        Lily
        ```
    2. **while 문**
        - "조건문" 동안 do 이하의 문장이 실행됨
        ```
        while 조건문
            do
                실행문장
            done
        ```
        - ex. ```$ vim ./tt7```
        ```
        #!/bin/bash
        var=1
        while [ "$var" -le 5 ]
            do
                echo $var
                var=`expr $var + 1`
            done
        ```
        - ```$ ./tt7```
        ```
        1
        2
        3
        4
        5
        ```
    3. **until 문**
        - until 문은 while 문과 동일한 효과이지만 조건이 반대임. 즉, 조건이 거짓일 동안 루프 수행
        ```
        until 조건문
            do
                실행문장
            done
        ```
        - ex. ```$ vim ./tt9```
        ```
        #!/bin/bash
        COUNTER=20
        until [ $COUNTER -lt 10 ]
            do
                echo COUNTER is $COUNTER
                COUNTER=`expr $COUNTER - 1`
            done
        ```
        - ```$ ./tt9```
        ```
        COUNTER is 20
        COUNTER is 19
        COUNTER is 18
        COUNTER is 17
        ...
        COUNTER is 11
        COUNTER is 10
        ```

- **함수**
    - 명령어 그룹을 메모리 내에 정의하여 수행 속도를 향상시킴
    ```
    함수 이름()
    {
        command
    }
    ```
    ```
    function 함수 이름
    {
        command
    }
    ```
    - ex. ```$ vim ./fun```
    ```
    #!/bin/bash
    user_print()
    {
        echo "shell programming"
    }
    echo "start user_print""
    user_print
    echo "end user_print"
    ```
    - ```$ ./fun```
    ```
    start user_print
    shell programming
    end user_print
    ```

- **패턴과 패턴 비교**
    - 일종의 문자열 연산. 특정 패턴을 놓고 변수의 문자열 값이 일부분이라도 일치하는지 검사할 때 사용
    - 이 패턴에는 와일드카드 문자(*, ?, \[, ] 를 포함한 문자 세트)를 포함해도 됨
    - 종류
        - **${변수#패턴}**: 처음부터 패턴과 맞는 변수 부분을 찾아 이 중 가장 작은 부분을 제거하고 나머지 반환
        - **${변수##패턴}**: 처음부터 패턴과 맞는 변수 부분을 찾아 가장 큰 부분을 제거하고 나머지 반환
        - **${변수%패턴}**: 끝에서부터 패턴과 일치하는 변수의 최소 부분을 제거하고 나머지 반환
        - **${변수%%패턴}**: 끝에서부터 패턴과 일치하는 변수의 최대 부분을 제거하고 나머지 반환
    - ex. ```$ vim ./ex3```
    ```
    #!/bin/bash
    unset var1
    echo ${var1:-string2}  # var1 이 null 이기 때문에 string2 출력
    var1=string1
    echo ${var1:-string2}  # var1 이 null 이 아니기 때문에 할당된 string1 출력
    var1=/etc/sysconfig/network
    echo ${var1#*/}  # 패턴(*/)과 맞는 부분을 찾아 가장 작은 부분을 제거하고 출력 > etc/sysconfig/network
    echo ${var1##*/}  # 패턴(*/)과 맞는 부분을 찾아 가장 큰 부분을 제거하고 출력 > network
    var2=/etc/sysconfig/network-scripts/sysconfig/ifcfg-lo
    echo ${var2%sysconfig*}  # 뒤에서부터 패턴(sysconfig*)과 맞는 부분을 찾아 최소 부분을 제거하고 출력 > /etc/sysconfig/network-scripts/
    echo ${var2%%sysconfig*}  # 뒤에서부터 패턴(sysconfig*)과 맞는 부분을 찾아 최대 부분을 제거하고 출력 > /etc/
    exit 0
    ```
    - ```$ ./ex3```
    ```
    string2
    string1
    etc/sysconfig/network
    network
    /etc/sysconfig/network-scripts/
    /etc/
    ```

### 프로세스

이번 파트에서는 **프로세스**에 대해 살펴보고, **프로세스 시그널**, **데몬** 및 **런레벨 별 데몬 실행**에 대해 정리합니다.

- **프로세스(Process)의 정의**
    - 하드디스크에 설치된 프로그램들을 실행하면 메모리(RAM)에 적재됨
    - 이렇게 실행 중인 프로그램을 프로세스라 하며, 아이디가 부여됨 (PID, Process ID)
    - 백그라운드 프로세스와 포그라운드 프로세스가 있음

- **프로세스의 생성**
    - **fork** 는 새로운 프로세스를 위해 메모리를 할당받아 복사본 형태의 프로세스를 실행하는 형태. 기존의 프로세스는 그대로 실행되어 있음
    - **exec** 는 원래의 프로세스를 새로운 프로세스로 대체하는 형태. 기존 프로세스의 메모리에 새 프로세스의 코드를 덮어씌움

리눅스가 부팅을 시작하면 커널이 init 이란 최초의 프로세스를 발생시키고 PID 1번을 할당받습니다.
이후 시스템 운영에 필요한 데몬을 비롯한 다른 프로세스들은 자식 프로세스 **fork** 방식으로 생성됩니다.

```pstree``` 명령으로 확인해 보면 부모-자식 구조로 나타납니다.

보통 명령어는 **fork** 형태로 수행됩니다.
사용자가 로그인하면 bash 프로세스가 할당되고, 명령어를 내리면 **fork** 형태로 수행됩니다.

반면 명령어 앞에 **exec** 를 붙이면 기본 프로세스가 교체되면서 새 프로세스가 할당됩니다.

- **프로세스의 종류**
    - foregroud
        - 셸에서 명령을 실행하면 해당 프로세스가 종료될 때까지 기다림
        - 보통 완료되면 프롬프트가 다시 나타남
    - background
        - 실행된 프로세스의 종료를 기다리지 않고 다른 작업 가능. 백단에서 수행됨
        - 명령 구문 맨 뒤에 **'&'** 를 추가하여 실행

- **멀티태스킹(Multi-tasking)과 작업 전환**
    - 여러 백그라운드 프로세스와 하나의 포그라운드 프로세스를 다중 실행 가능
    - 모든 프로세스는 중간에 중지 가능
    - 백 <-> 포 간 전환 가능

> **포그라운드 프로세스와 백그라운드 프로세스 간 전환하기**
> - ```CTRL + z``` 로 메모리에 적재된 포그라운드 프로세스를 대기(suspend)시킨 후,
> - ```bg``` 명령을 입력하여 백그라운드 프로세스로 전환!
> - ```jobs``` 명령으로 현재 상태 확인 가능 (Stopped, Running, ...)
> - 이와 유사한 방식으로 백그라운드를 포그라운드로 전환하기 위해서는, 먼저 ```jobs``` 로 작업 번호를 확인하고, ```fg %작업번호```
> 명령을 입력!
> - ```jobs``` 확인시 '+' 표시가 붙어있는 프로세스가 주로 처리되는 프로세스, 보통은 마지막에 실행한 프로세스인데, 작업번호 없이
> ```fg``` 명령을 입력하면 이 작업이 포그라운드로 전환됨
> - '-' 가 붙은 작업은 '+' 다음 우선순위 작업임

- **시그널(Signal)**
    - 프로세스끼리 통신할 때 사용됨. 특정 프로세스가 다른 프로세스로 신호를 보낼 때
    - 각 시그널에는 이름이 있고, 번호로 관리됨. ```kill -l``` 로 목록을 확인
    - 종류
        - **SIGHUP(HUP)**: 1번. Hangup 의 약어. 로그아웃 등 터미널 접속이 끊길 시 보내지는 시그널. 데몬 관련 환경설정파일을 변경하고
        변화된 내용을 적용하기 위해 재시작시 사용됨
        - **SIGINT(INT)**: 2번. 키보드로부터 오는 인터럽트 시그널. 실행을 중지시킴 (CTRL + c)
        - **SIGQUIT(QUIT)**: 3번. 키보드로부터 오는 실행 중지 시그널 (CTRL + \)
        - **SIGKILL(KILL)**: 9번. 무조건 종료. 프로세스 강제 종료
        - **SIGTERM(TERM)**: 15번. Terminate 의 약자로 가능한 정상 종료. ```kill``` 커맨드릐 기본 시그널임
        - **SIGCONT(CONT)**: 18번. Continue 의 약자로 **STOP** 시그널로 정지된 프로세스를 다시 실행시킬 때 사용
        - **SIGSTOP(STOP)**: 19번. 터미널에서 입력된 정지 시그널
        - **SIGTSTP(TSTP)**: 20번. 실행 정지 후 다시 실행을 계속하기 위해 대기시키는 시그널 (CTRL + z)

**데몬(Daemon)** 이란 주기적이고 지속적인 서비스 요청을 처리하기 위한 프로세스로, 백그라운드로 실행됩니다.
리눅스에서는 보통 서버 역할을 하는 프로그램들이 이에 해당합니다. (이름 뒤에 'd' 를 붙임. httpd, systemd 등등)

이러한 데몬 프로세스를 실행하는 방법에는 **standalone** 방식과 **inet** 방식이 있습니다.

- 데몬 프로세스 실행
    - **standalone** 방식: 부팅 시 실행되어 메모리에 계속 상주. 웹, 메일 등 빈번한 요청 처리 프로세스
    - **inet** 방식: 메모리에 항상 상주하는 것이 아니라 클라이언트 요청에 따라 관련 프로세스를 실행시켰다가 접속 종료 후 종료.
    자주 사용되지 않는 서비스에 대한 효율적 메모리 관리에 유용
    - 리눅스 커널 2.2 버전까지는 inetd 데몬이 이러한 서비스를 관리, 2.4 버전부터는 xinetd 데몬이 수행함

데몬 프로세스는 System V 계열에서 사용하는 각 실행 레벨(런레벨)에 따른 제어 방식을 사용합니다.
부팅 관련 정보는 **/etc/rc.d** 디렉토리에 모아두고, 관련 데몬들은 **/etc/rc.d/init.d** 디렉토리와 **rc0.d ~ rc6.d**
디렉토리를 이용하여 데몬의 실행을 조절합니다.

- **/etc/rc.d/init.d 디렉토리**
    - 시스템에서 제공되는 서비스 관련 스크립트를 포함
    - 기본 형식으로 **start** 와 **stop**, **restart**, **status**, **reload** 등의 인자 중 하나만 이용하여 서비스 동작을 제어
    - ex. **/etc/rc.d/init.d/httpd** 는 웹서버 데몬을 안전하게 시작하거나 중지하는 스크립트임
    - **restart** 는 중지 후 시작, **reload** 는 중지하지 않고 환경 설정만 다시 읽어들임

- **rc0.d ~ rc6.d 디렉토리**
    - 숫자는 **런레벨**을 의미함
    - init 프로세스가 n 레벨을 시작하면 rcn.d 디렉토리에 존재하는 모든 심볼릭 링크를 점검, 부팅 시 필요한 서비스를 확인하여 데몬 실행
    - 예를 들어 런레벨 5인 경우, **S** 로 시작되는 모든 링크들은 start 인자를 이용해 실행된 후 나머지 부팅 절차로 넘어감
    - 디렉토리 내 데몬 프로세스명 기본 형식: **[K \| S][번호][이름]**
        - **K**: Kill 을 의미. 실행되지 않을 서비스를 지칭
        - **S**: Start 를 의미. 해당 런레벨에서 실행되어야 하는 서비스 지칭
        - **번호**: 순차적인 번호. 정수 2자리이며(필요한 경우 앞에 0 포함) 시작이나 중지 순서를 나타내는 상대 번호.
        동일 번호시 대부분 알파벳순
        - **이름**: init.d_이름. 관습에 따라 링크가 되는 스크립트명을 사용. 이해가 쉽게 스크립트명을 붙여도 무방

> 데몬 실행 관련 명령어: **service**
> - **/etc/rc.d/init.d** 디렉토리에 존재하는 스크립트를 쉽게 시작/중지시키는 명령
> - 프로그램의 절대 경로 대신 간단히 서비스명과 인자값을 지정해서 실행 가능
> - ex. ```# service sendmail start```

> **경로 단축을 위한 심볼릭 링크 설정**
> - **/etc/rc.d** 디렉토리 하위의 부팅 관련 프로그램에 **/etc** 바로 하위로 심볼릭 링크를 지정
> - 따라서 절대 경로 입력시 중간의 **rc.d** 디렉토리명 생략 가능
> - ex. ```# /etc/init.d/https start```

**데몬 관련 유틸리티**는 다음과 같습니다.

1. **ntsysv**
    - 부팅 중 자동으로 실행되는 서비스를 설정하는 유틸리티
    - 텍스트 환경에서 커서로 이동하여 스페이스로 선택
    - 명령행에서 **ntsysv** 실행시 현 런레벨 설정 가능
    - 혹은 **setup** 커맨드 후 나타나는 메뉴 항목에서 'System services' 를 선택하는 방식으로도 가능
    - ```# ntsysv [option]```
        - **--level 실행레벨**: 특정 실행레벨을 편집

2. **chkconfig**
    - cli 명령형 프로그램으로 런레벨에 따른 서비스의 on/off 설정 리스트를 출력하거나 설정함
    - ```# chkconfig [option] [service]```
        - **--list**: 각 런레벨에서의 서비스 설정 상태 목록
        - **--add [service]**: 서비스 추가
        - **--del [service]**: 서비스 삭제
        - **--level [level] [service] [on/off/reset]**: 해당 런레벨에서 서비스 상태를 설정
    - ex.
        - ```# chkconfig --list```: 레벨별 목록 출력
        - ```# chkconfig named```: named 서비스의 상태 체크
        - ```# chkconfig --level 35 named on```: 3, 5 런레벨에서 named 서비스 on
        - ```# chkconfig --level 5 --del adsl```: 5 런레벨에서 adsl 서비스 삭제
        - ```# chkconfig sendmail off```: sendmail 서비스를 부팅 시 시작하지 않도록 함.
        런레벨 지정이 없으므로, 2, 3, 4, 5 레벨에서 적용됨
        - ```# chkconfig telnet on```: telnet 서비스를 on. telnet 은 xinetd 기반으로 동작하기 때문에
        /etc/xinetd.d/telnet 파일 항목의 disable 값을 no 로 설정함
        - ```# chkconfig --list telnet```: xinetd 기반 서비스는 레벨을 보여주지 않고 사용 가능 여부만 확인할 수 있음.
        따라서 런레벨별 telnet 실행 여부는 ```# chkconfig --list xinetd``` 로 확인해야 함

### 1-3. 네트워크의 이해

### 네트워크의 기초

이번 파트에서는 **OSI 7 계층**을 살펴보고, **네트워크 장비의 종류**와 **이더넷/LAN 통신망**, **TCP/IP 프로토콜**에 대해 정리합니다.

먼저 **OSI 7 계층**을 살펴봅니다.

- **OSI 7-Layer**: 컴퓨터 네트워크 프로토콜 디자인과 통신을 7계층으로 나누어 정의한 모델
    - 각 계층은 자신의 하위 계층의 기능만을 이용하여 상위 계층에서 기능을 제공함
    - **물 > 데 > 네 > 전 > 세 > 표 > 응**
    - 전송 계층까지 전달 기능을 담당하며, 세표응은 통신 기능 담당

1. **물리 계층(Physical Layer)**: 허브(Hub)나 리피터(Repeater)
    - 실제 장치 간 연결을 위한 케이블 및 연결장치
    - 그러한 기계적인 항목과 전압, 신호 방식 등의 전기적인 항목에 대한 특성 규정
    - **역할**: 상위 계층에서 전송된 데이터를 물리적인 전송 매체를 통해 비트(bit) 형태로 전송.
    통신 채널을 통해 전송되는 사용자 장치의 디지털 데이터를 이에 상응하는 신호로 변환하는 역할
2. **데이터링크 계층(Data Link Layer)**: 브릿지(Bridge)나 스위치(Switch)
    - 상위 계층인 네트워크 계층에서 받은 데이터를 **프레임(Frame)** 이라는 논리적 단위로 구성
    - 제어에 필요한 여러 정보를 덧붙여 물리 계층으로 전달
    - **역할(제어)**
        - **MAC 주소** 포함
        - **전송 제어**: 데이터의 정확한 송수신을 위한 규정이나 통신회선 접속의 확인 등
        - **오류 제어**: 물리 계층에서 발생할 수 있는 오류를 검출 및 복구
        - **순서 제어**: 전송 단위의 순서 제어
        - **에러 제어** 기능
        - **흐름 제어**: 송신측과 수신측의 처리 속도 차이로 인한 데이터 손실을 막기 위해 데이터량 조절

3. **네트워크 계층(Network Layer)**: 라우터(Router)
    - 데이터를 **패킷(Packet)** 단위로 분할하여 전송
    - 데이터 전송과 경로 선택에 관한 서비스 제공
    - 데이터링크 계층이 인접한 두 시스템 간의 전송을 담당한다면, 네트워크 계층은 패킷을 최종 수신측까지 정확하게 전송하도록 **경로를 담당**함
    - 인접한 두 시스템 외에 목적지까지 여러 노드가 존재하기 때문에 올바른 경로 설정이 중요
    - **역할**
        - 라우팅, 혼잡 제어(Congestion Control, 트래픽 제어), 패킷의 분할(Segmentation), 병합(Desegmentation, Reassembly),
        인터네트워킹(Internetworking) 등

4. **전송 계층(Transport Layer)**
    - 데이터 전송에 관한 서비스를 제공하는 계층
    - 송수신측 간 실제적인 연결 설정 및 유지, 오류 복구와 흐름 제어 > 투명하고 신뢰성 있는 통신 가능
    - 네트워크에서 패킷을 담당한다면, 전송 계층에서는 **전체 메시지의 전송을 책임짐**
    - 데이터 교환 주체는 호스트가 아닌 실행 프로세스, 송수신 프로세스 간의 연결(Connection)기능 제공
    - 안전한 데이터 전송을 지원

5. **세션 계층(Session Layer)**
    - 응용 프로그램 간의 통신을 관리하기 위한 방법과 동기화를 유지하는 서비스 제공
    - 응용 프로그램 간의 접속설정 및 유지, 종료에 관한 세션 관리, 데이터의 전송순서 및 동기점의 위치 제공
    - 데이터 전송 중 오류가 발생할 경우 재전송하거나 데이터를 복구

6. **표현 계층(Presentation Layer)**
    - 전송하는 데이터의 표현 방식에 관한 서비스 제공
    - 예를 들어, EBCDIC 로 인코딩된 문서 파일은 ASCII 로 인코딩된 파일로 바꿔주는 역할 수행
    - 데이터의 암호화 및 해독, 압축, 압축 해제 등을 수행

7. **응용 계층(Application Layer)**
    - 응용 프로그램과 연계하여 사용자에게 편리한 환경을 제공
    - 일반적인 서비스들이 응용 계층에 속함 > SMTP, HTTP, FTP, TELNET 등

> **OSI 모델의 전송단위 및 역할, 프로토콜**
> - **응용 계층**
>     - 전송 단위: data
>     - 역할: 사용자에게 직접 제공하는 서비스 및 응용 프로그램 간의 정보 교환
>     - 프로토콜: HTTP, SMTP, POP3, IMAP, DNS, NFS, FTP, TELNET, SSH 등
> - **표현 계층**
>     - 전송 단위: data
>     - 역할: 송수신할 정보의 표현에 차이가 있는 응용 프로그램들에게 연결 제공
>     - 프로토콜: SMB, AFP, ASN.1 등
> - **세션 계층**
>     - 전송 단위: data
>     - 역할: 응용 프로그램 간의 통신을 관리하기 위한 방법과 동기화를 유지하는 서비스 제공
>     - 프로토콜: SSL, TLS, NetBIOS 등
> - **전송 계층**
>     - 전송 단위: segments
>     - 역할: 정보의 신뢰성 있고 투명한 데이터 전송에 관한 서비스 제공
>     - 프로토콜: TCP, UDP, RTP 등
> - **네트워크 계층**
>     - 전송 단위: packets
>     - 역할: 정보의 전송을 위한 경로 선택
>     - 프로토콜: IP, ICMP, ARP, RARP, IGMP, BGP, RIP, IPX 등
> - **데이터링크 계층**
>     - 전송 단위: frames
>     - 역할: 물리적인 링크를 통하여 신뢰성 있는 정보의 전송을 위한 통신로 설정
>     - 프로토콜: 이더넷(Ethernet), 토큰 링(Token Ring), FDDI, ATM 등
> - **물리 계층**
>     - 전송 단위: bits
>     - 역할: 전송 매체를 통해 전송
>     - 프로토콜: RS-232, 10BASE-T, 100BASE-TX, DSL 등

**네트워크 장비**를 살펴봅니다.

- **LAN 구성 장비**
    1. **네트워크 카드(Network Card)**
        - 컴퓨터 단말에 위치하는 통신 하드웨어
        - 네트워크 어댑터, 네트워크 인터페이스 카드, 이더넷 카드, 랜카드 등으로 불림
        - 고유한 맥(MAC)주소가 할당됨
        - OSI 모델에서 **물리 계층**, **데이터링크 계층**의 장치를 사용
    2. **케이블**
        - 신호 전송을 위한 물리적인 전송 매체
        - BNC(동축, 단일 선 연결), UTP(허브 중계, 가지치기), 광섬유 케이블
    3. **허브(HUB)**
        - UTP 케이블이나 UF45 등을 사용하는 이더넷 네트워크에서 여러 대의 컴퓨터 및 네트워크 장비를 연결하는 장치
        - 허브에 라우터나 L3 스위치를 연결하면 WAS 과 MAN 을 비롯하여 인터넷망과 연결 가능
        - 최근에는 이더넷 스위치(Switching Hub)를 사용해 필요한 단말기에 데이터를 전송함

- **인터네트워킹(Internetworking) 장비**: 네트워크 간의 연결을 지칭, 게이트웨이(Gateway)
    1. **리피터(Repeater)**
        - 감쇄되는 물리적 신호를 증폭하여 중계하는 장치
        - OSI 1계층인 물리 계층에서 동작
    2. **브리지(Bridge)**
        - 특정 네트워크로부터 오는 통신을 조정하여 트래픽을 관리(리피터나 허브의 기능 동시 수행)
        - OSI 2계층인 데이터링크 계층에 있는 여러 개의 네트워크 세그먼트 연결
    3. **라우터(Router)**
        - 네트워크 계층에 대한 경로선택 기능 제공
        - 임의의 네트워크에 들어온 데이터를 어느 네트워크로 전달할지 판단
        - 이를 위해 라우터는 **자신과 연결된 네트워크 및 호스트 정보를 유지하고 관리**해야 함
        - 더 최적화된 경로를 판단해야 함 > **라우팅 테이블(Routing Table)**
        - 물리, 데이터링크, 네트워크 계층의 기능을 지원하는 장치

> **게이트웨이(Gateway)**
> - 서로 다른 통신망과 프로토콜을 사용하는 네트워크 간에 통신 기능을 가능하게 해주는 장치(리피터, 브리지, 라우터 등)

**Ethernet/LAN** 의 기본 이해입니다.
통신망의 종류는 규모에 따라 분류됩니다.

- **근거리 통신망(LAN)**: 근거리 통신망. 집, 사무실, 학교 등 (스타형, 버스형, 링형, 망형)
    - **스타(Star)형**: 중앙의 제어기(허브, 교환기)를 중심으로 point-to-point 방식 연결
    - **버스(Bus)형**: 하나의 버스(통신회선)에 여러 컴퓨터 연결. 모든 장치는 동등 조건으로 경쟁(CSMA/CD, 토큰패싱 방식)
    - **링(Ring)형**: 원형의 통신회선에 컴퓨터와 단말기를 연결하는 형태로 연결. 앞의 컴퓨터로부터 수신한 내용을
    다음 컴퓨터에 재전송하는 방법으로 동작 (토큰 패싱 방식)
    - **망(Mesh)형**: 스타형과 링형의 혼합된 형태. 라우터-LAN 의 그물 관계. 신뢰성 높지만 설치비용이 많이 듬
    
- **LAN 전송 방식**
    - **이더넷**: MAC 주소를 기반으로 상호간에 데이터를 주고받을 수 있도록 함(허브, 스위치, 리피터 등으로 구성)
    - **CSMA/CD**: 단말기가 전송로의 신호유무를 조사하고, 다른 단말기가 신호를 송출하고 있는지 확인하는 통신방식. 토큰 링에 비해
    효율성을 떨어지나 가격이 저렴
    - **토큰링(Token Ring)**: IEEE 802.5 표준. 링형 구조로 토큰이라는 일종의 사용권을 획득하여 환형 네트워크 내
    데이터 전송을 위한 네트워크 채널 사용
    - **FDDI(Fiber Distributed Data Interface)**: 광섬유 케이블로 구성된 링 구조의 통신망. 한 빌딩 내의 간선 LAN 으로 사용되거나
    컴퓨터 사이를 고속으로 접속하는데 주로 사용됨. (다중 모드 회선: 2Km 까지, 단일 모드 회선: 40~200Km 까지 지원)

> **이더넷 매체 종류와 배선 방식**
> - **```[전송속도][Baseband][케이블]```**
> - **10BASE-2**: 10Mbps 전송속도의 동축 케이블, 100M 전송 거리
> - **10BASE-5**: 10Mbps 전송속도의 동축 케이블, 500M 전송 거리
> - **10BASE-T**: 10Mbps 전송속도의 절연된 Twisted 케이블
> - **100BASE-TX**: 100Mbps 전송속도의 UTP-5 또는 STP
> - **100BASE-FX**: 100Mbps 전송속도의 광케이블
> - **1000BASE-T**: 1000Mbps 전송속도의 UTP-5
> - **1000BASE-SX**: 단파장의 광섬유 사용, 220~550M 까지 전송
> - **1000BASE-LX**: 장파장의 광섬유 사용, 다중모드시 550M, 단일 모드시 5KM

- **MAN(Metropolitan Area Network)**
    - 도시권 통신망으로써 LAN 과 WAS 의 중간 형태로 위성 도시 등을 연결한 형태
    - 전화선을 통해 서로 연결된 여러 가지 LAN 을 포함하는 대도시 통신망
    
- **WAN(Wide Area Network)**
    - 원거리 혹은 광역 통신망으로써 국가, 대륙 등 넓은 지역을 연결하는 네트워크
    - 거리상의 제약은 없지만 LAN 에 비해 속도가 느리고 전송 에러율도 높은 편
    - 전용 회선(통신사업자 중계)과 교환 회선(PSTN 혹은 PSDN) 방식
    - 교환 회선 방식에는 회선 교환, 패킷 교환, 셀 릴레이 방식이 있음
    - **회선 교환 방식**: 대표적으로 전화. 송수신 호스트 간 연결 경로를 설정하여 일종의 물리적 전용선을 연결하는 방식
    - **패킷 교환 방식**: 패킷이라는 정보 블록을 이용해서 전송하는 방식
        - **현재 컴퓨터 네트워크에서 사용하는 방식**으로, 패킷별 우선순위 부여 가능
        - 전송 대역폭을 동적으로 공유하기 때문에 전송 선로 이용 효율 극대화
        - 단점 > 회선 교환에 비해 더 많은 지연 발생 가능. 각 패킷마다 오버헤드 비트 존재

> **패킷(Packet)**: 전달하고자 하는 정보를 일정 크기로 분할하고 각각에 송수신 주소를 비롯한 관련 정보를 추가하여 만든 데이터 블록
> - **데이터그램 방식(Datagram)**
>     - 비연결형 서비스를 지원. 패킷들이 독립적으로 전송되며 연결을 설정하기 위한 과정이 없음
>     - 경로를 미리 할당하지 않으므로 목적지 도착 순서를 예측할 수 없음
>     - **전송 정보의 양이 적거나, 상대적으로 신뢰성이 중요하지 않은 환경에서 사용**
> - **가상 회선 방식(Virtual Circuit)**
>     - 연결형 서비스를 지원. 송수신 호스트 사이의 가상 단일 파이프를 통해 패킷을 주고받음
>     - 패킷이 도착하는 순서는 전송한 순서와 같음
>     - **회선 교환 방식**을 이용하나 데이터 단위가 패킷이라는 차이가 존재함

- **X.25**
    - ITU-T 표준화 통신 규약. 패킷망에서 DCE(회선 종단 장치)와 DTE(데이터 단말 장치) 사이에 이루어지는 상호 작용을 규정한 프로토콜
    - 네트워크 계층의 대표적인 프로토콜로 가변 길이 프레임 전송을 지원하는 **프레임 릴레이(Frame Relay)**의 근간을 이룸

- **프레임 릴레이(Frame Relay)**
    - LAN 또는 WAN 상에서 단말 지점간의 효율적인 데이터 전송을 위해 고안됨
    - 패킷 대신 프레임이라 불리는 가변 길이 단위에 데이터를 넣으며, 재전송과 같은 오류 정정 기능은 단말에 맡김
    - **X.25** 방식의 높은 전송 오류와 오버헤드 비트를 줄임
    - **X.25** 방식은 1, 2, 3 계층 처리를 명세하지만 **프레임 릴레이**는 오직 1, 2 계층에서만 동작 > 프로세싱 감소로 성능 향상

- **셀 릴레이(Cell Relay): ATM(Asynchronous Transfer Mode)**
    - ATM 이라고 더 많이 알려져 있음. 셀로 불리는 고정 길이(53Byte) 패킷을 이용하여 순서대로 자료를 전송하는 방식
    - 가상 채널 기반의 연결형 서비스로 프레임 릴레이처럼 양 끝단말 간의 오류 제어와 흐름 제어를 함
    - 결과적으로 망의 오버헤드가 적어서 고속화 가능
    - **실시간 및 비실시간 서비스 제공**, **음성 및 압축 비디오 신호 처리** 가능

**TCP/IP 프로토콜**에 대해 살펴봅니다.

> **프로토콜(Protocol)**
> - 컴퓨터 간 통신을 위해 미리 정해놓은 특별한 규칙, 통신 규약 (대표적으로 **TCP/IP**)
> - 규약에서는 접속이나 전달 방식, 주고받을 자료의 형식, 오류 검출 방식, 코드 변환 방식, 전송속도 등을 정함

- **프로토콜의 기본 구성요소**
    - **구문(Syntax)**: 데이터의 구조나 형식을 말함. 부호화, 신호 레벨 등을 규정
    - **의미(Semantics)**: 전송의 조작이나 오류 제어를 위한 제어 정보에 대한 규정
    - **순서(Timing)**: 접속되어 있는 개체 간 통신 속도의 조정이나 메시지 순서 제어

- **프로토콜의 기능**
    1. **주소 지정(Addressing)**: 데이터 전송 시 출발지와 목적지의 주소
    2. **순서 지정(Sequencing)**: 데이터의 전송 순서 명시. 특히 연결지향형 프로토콜에서 흐름 제어 및 오류 제어시 사용됨
    3. **단편화와 재조합(Fragmentation and Reassembly)**: 대용량 데이터 전송의 경우 블록을 분할 전송하고 수신측에서 재조합
    4. **흐름 제어(Flow Control)**: 핵심은 송신 속도가 수신측의 데이터 처리 능력을 초과하지 않도록 하는 것!
    (> Stop an Wait, Sliding Window)
    5. **오류 제어(Error Control)**: 데이터 교환 시 오류 발견. 체크섬 기능이 대표적
    6. **연결 제어(Connection Control)**: 프로토콜 연결 설정에서 **구문, 의미, 시간**을 제어하는 것
    7. **동기화(Synchronization)**: 데이터 전송 시 타이머 값, 윈도우 크기 등의 인자값을 일치시키는 것
    8. **멀티플렉싱(Multiplexing)**: 하나의 통신 선로에서 다중 시스템이 동시에 통신할 수 있는 기법
    9. **전송 서비스(Transmission Service)**: 우선순위 결정, 서비스 등급과 보안 요구 등의 제어 서비스
    10. **캡슣롸(Encapsulation)**: 송신자와 수신자의 주소, 오류 검출 코드, 프로토콜 제어 정보를 덧붙이는 것

- **프로토콜 제정 기관**
    - ISO(국제적 표준화기구), IEEE(전기전자공학 최대 기술 조직), ANSI(미국산업표준, ISO 가입), EIA(미국전자산업협회),
    ITU-T(국제전기통신연합 전기통신 표준화 부문)

- **TCP/IP**
    - 컴퓨터 기종에 관계없이 정보 교환이 가능하도록 해주는 통신 프로토콜
    - TCP(Transmission Control Protocol) + IP(Internet Protocol)
    - TCP 는 IP 프로토콜에 의해 만들어진 패킷들(패킷으로 쪼개 목적지 주소 등 지정)의 전송 흐름 부분을 담당함
    - 패킷이 목적지 주소에 올바른 순서로 도달하도록 제어하는 한편 중간에 유실되지 않도록 함

- **TCP/IP 의 구조**
    - 총 4개의 계층으로 나눠짐 (**네트워크 인터페이스 계층**, **인터넷 계층**, **전송 계층**, **응용 계층** << OSI 7 Layer 와 비교!)
    - **응용(Application)**: HTTP, SMTP, POP3, IMAP, DNS, NFS, NIS, FTP, TELNET, SSH 등
        - 네트워크로 연결된 프로세스 간의 통신 접속을 위해 설계된 통신 프로토콜
        - 추상적으로 사용자 프로그램에서 구현됨
        - 전송 계층 프로토콜로 연결된 호스트 간의 연결 확립
    - **전송(Transport)**: TCP, UDP 등
        - 상위에서 받은 데이터를 세그먼트(Segment) 형태로 만들어 네트워크를 통해 수신자에게 전달
        - 연결 지향 데이터스트림 지원, 신뢰성, 흐름 제어, 다중화 등 서비스 제공
    - **인터넷(Internet)**: IP(v4, v6), ICMP, ARP 등
        - 상위에서 받은 패킷을 목적지까지 효율적으로 전달하는 역할
        - 패킷이 제대로 도착했는지, 데이터 손상 여부 등은 상위에서 처리
    - **네트워크 인터페이스(Network Interface)**: Ethernet, Token Ring, FDDI 등
        - 이더넷 카드 등으로 연결된 물리적인 네트워크 의미
        - 프레임을 물리적 회선에 올리거나(프레임화) 내려받는(패킷화) 역할

> **전송 계층 프로토콜**
> - **TCP(Transmission Control Protocol)**
>     - 연결지향 전송 프로토콜. 세그먼트가 수신자에게 제대로 전달되었는지 응답(Ack)을 주고받음으로써 점검
>     - 즉, IP 에 의해 전달되는 패킷의 오류를 검사하고 재전송을 요구하는 등 보다 정교한 제어를 담당
>     - 두 지점의 네트워크 상 최단 경로를 찾아 1:1로 직접 연결하므로 전송과 오류 수정의 신뢰도가 높음 > 대용량 데이터 전송에 이용됨
>     - 다만 상대적으로 많은 전송 시간이 필요함
> - **UDP(User Datagram Protocol)**
>     - 비연결 전송 프로토콜로 세그먼트를 보내기만 하고 응답(Ack)을 주고받지 않음
>     - 따라서 제대로 전달되었는지 확인하지 않으며 오류 수정도 없음
>     - 속도가 빠르고 직접 연결에 따른 네트워크 부하를 줄일 수 있음
>     - 시스템 내부 메시지 및 데이터 전달, 소규모 데이터 전송, DNS 에 이용됨

> **인터넷 계층 프로토콜**
> - **IP(Internet Protocol)**
>     - OSI 의 네트워크 계층에서 호스트의 주소 지정과 패킷 분할 및 조립 기능 담당
>     - 데이터 세그먼트를 패킷으로 만들어 전송하는 역할 수행
>     - 비신뢰성, 비연결형
> - **ICMP(Internet Control Message Protocol)**
>     - 메시지에 대한 오류 보고와 이에 대한 피드백을 원래 호스트에 보고하는 역할 수행
>     - ICMP 제어 메시지는 IP 패킷의 형태로 전달되고, ping 명령이 사용하는 프로토콜
> - **ARP(Address Resolution Protocol)**
>     - IP 프로토콜은 MAC 주소와 논리적인 할당에 의한 IP 주소를 가짐
>     - 실제의 데이터 전달은 하드웨어 주소를 알아야 함
>     - 동적으로 특정 프로토콜에 의해서 필요할 때마다 목적지 호스트의 하드웨어 주소를 찾는 역할 수행

- **프로토콜 번호(Protocol Number)**
    - 전송되는 정보의 데이터를 처리하기 위해서는 전송 프로토콜에 대한 인식이 필요함
    - 프로토콜 정보는 번호를 사용하여 데이터그램 헤더 안에 기록되어 보내짐
    - 프로토콜 번호는 **/etc/protocols** 에서 확인 가능
    - 또한 전송 프로토콜은 응용 프로그램을 구분하기 위해 **포트 번호**를 사용

- **포트 번호(Port Number)**
    - 인터넷 계층 프로토콜인 IP 프로토콜에 의해 전달된 데이터는 전송 계층 프로토콜인 TCP 및 UDP 등에서 서비스 다중화를 위해 포트로 관리됨
    - 각 응용 프로그램은 할당된 포트를 이용해 통신할 데이터를 주고받음
    - 포트 번호의 범주는 **0 ~ 65535** 번까지
    - 0 ~ 1023 까지는 잘 알려진 포트(Well-Known Port) > HTTP, SMTP, TELNET, SSH 등
    - **/etc/services** 파일에서 주요 포트번호 확인

> **포트 번호와 주요 프로토콜**
> - 20번: FTP 전송
> - 21번: FTP 제어
> - 22번: SSH(Secure Shell)
> - 23번: TELNET
> - 25번: SMTP(Simple Mail Transfer Protocol)
> - 53번: DNS(Domain Name System)
> - 80번: WWW(World Wide Web) 프로토콜인 HTTP
> - 110번: POP3(Post Office Protocol 3)
> - 143번: IMAP(Internet Mail Access Protocol)
> - 161번: SNMP(Simple Network Management Protocol)
> - 443번: HTTPS(HTTP protocol over TLS/SSL)

- **소켓(Socket)**
    - 네트워크로 연결되어 있는 컴퓨터에서 상호간 통신을 위한 접점
    - 네트워크 관련 프로그램들은 데이터 통신을 위해 소켓을 생성하고, 이를 통해 데이터 교환
    - 소켓은 인터넷 프로토콜(TCP, UDP 등), 로컬 시스템의 IP 주소 및 포트 번호, 원격 시스템의 IP 주소 및 포트 번호로 구성됨

- **IP 주소(Internet Protocol Address)**
    - IP 주소는 32비트의 이진 숫자로, 8비트씩 4부분으로 나뉘어 십진수(0 ~ 255 총 256개씩)로 표현함
    - 0.0.0.0 ~ 255.255.255.255 범주
    - 첫 8비트 영역의 값에 따라 A~E 클래스로 나뉨
    - 그 중 일반 목적으로 사용되는 클래스 A~C 범주는 **네트워크 식별자(Network ID)** 영역과 **호스트 식별자(Host ID)** 영역으로 구분됨
    - **A 클래스(N.H.H.H)**: 주소의 첫 1bit 가 0 이며, NetID 는 0 ~ 127까지 총 128개
    - **B 클래스(N.N.H.H)**: 주소의 첫 2bit 가 10 이며, NetID 는 128.0 ~ 191.255까지 총 16,384개
    - **C 클래스(N.N.N.H)**: 주소의 첫 3bit 가 110 이며, NetID 는 192.0.0 ~ 223.255.255까지 총 2,097,152개
    - **D 클래스(특수목적)**: 주소의 첫 4bit 가 1110 이며, 다중방송통신(Multicast) 용도로 예약됨
    - **E 클래스(특수목적)**: 주소의 첫 4bit 가 1111 이며, 연구 및 미래용으로 예약됨. 일반적으로 사용되지 않기에 D 클래스로 통칭하기도 함

> **클래스별 IP 주소 범위와 호스트 개수**
> - **A 클래스**: 0.0.0.0 ~ 127.255.255.255 / 128개 네트워크, 각 16,777,216개 호스트
> - **B 클래스**: 128.0.0.0 ~ 191.255.255.255 / 16,384개 네트워크, 각 65,536개 호스트
> - **C 클래스**: 192.0.0.0 ~ 223.255.255.255 / 2,097,152개 네트워크, 각 256개 호스트
> - **D 클래스**: 224.0.0.0 ~ 239.255.255.255
> - **E 클래스**: 240.0.0.0 ~ 255.255.255.255

> **특수 목적 IP 주소**
> - A~C 클래스 중에서 인터넷 연결을 위한 일반 목적이 아닌 특수 목적으로 사용되는 주소가 있음
> - **루프백 IP 주소(Loopback IP Address)**: 자기 자신을 가리킴. A 클래스의 **127 대역(127.0.0.0 ~ 127.255.255.255)** 사용
> - **사설 IP 주소(Private IP Address)**: 내부 네트워크 구축용. 퍼블릭이 아니기 때문에 각 호스트마다 중복으로 존재 가능
>     - **A 클래스**: 10.0.0.0 ~ 10.255.255.255 로, A 클래스 영역 10 의 1개 네트워크 대역 할당
>     - **B 클래스**: 172.16.0.0 ~ 172.31.255.255 로, B 클래스 영역 172.16 ~ 172.31 의 16개 네트워크 대역 할당
>     - **C 클래스**: 192.168.0.0 ~ 192.168.255.255 로, C 클래스 영역 192.168.0 ~ 192.168.255 의 총 256개 네트워크 대역 할당

- **도메인 네임 시스템(Domain Name System)**
    - 숫자로 표현된 IP 주소를 알기쉽게 영문으로 표기한 것으로 2~5개 영역으로 나누어짐 ('컴퓨터명.기관명.기관종류.국가명')
    - 현재 도메인 네임은 국제인터넷 주소자원 관리기관인 ICANN(구 IANA)에서 관리하며, 영어 외 한글 중국어 등 다양한 언어 지원
    - **DNS** 는 인터넷 상에서 주소 매핑 서비스를 제공함
        - 87년 DNS 소개 이전까지는 주로 **hosts 파일(/etc/hosts)**을 FTP 로 다운받아 친숙한 컴퓨터의 이름을 IP 주소에 매핑했음
        - 이는 각 호스트마다 주기적인 hosts 복사본 업데이트(버전으로 관리)가 필요
        - 인터넷 내 컴퓨터 개수가 늘어남에 따라 한 기관이 중앙에서 모든 호스트를 단일 hosts 파일로 관리하기 어려워 **DNS 체계**로 넘어옴

- **도메인 체계**
    - 루트(Root, '.' 으로 표기) 하위 역트리(Inverted Tree) 형태의 계층적 구조로 구성됨
    - **1단계 최상위 도메인**: TLD(Top-Level Domain). 일반 최상위 도메인(gTLD)와 국가코드 최상위 도메인(ccTLD)이 존재
        - gTLD: com, net, org, edu, gov, mil, int 등
        - ccTLD: kr, cn, us 등 두 자리 영문약자
    - **2단계 도메인**: SLD(Second Level Domain). 기관 이름이나 기관 종류. 이하 3단계, 4단계 도메인 형태
    - ICANN 은 신청을 받아 심사를 통해 최상위 도메인 추가 및 관리함

> **주요 최상위 도메인**
> - **com**: 영리 목적의 기업이나 회사
> - **net**: 네트워크와 관련된 기관
> - **org**: 비영리 목적 기관이나 단체
> - **edu**: 학위를 수여하는 교육기관
> - **gov**: 미국 연방정부기관
> - **mil**: 미국 연방군사기관
> - **int**: 유엔 등과 같은 국제기관

> **IPv6(Internet Protocol version 6)**
> - IPv4 주소 고갈 문제를 해결하기 위해 제안된 차세대 인터넷 프로토콜
> - 주소 범위는 128bit 이고, 주소 표현은 16bit 단위로 하여 8개 영역으로 나타내며 각 자리는 콜론(:)으로 구분함. 숫자는 16진수로 표현
> - **특징**
>     - IP 주소의 확장: 거의 무한에 가까운 주소 제공
>     - 패킷 크기의 확장: 기존 64KB 로 제한된 패킷에서 IPv6 의 점보그램 옵션을 사용하면 특정 호스트 사이의 임의의 큰 패킷 구성 가능
>     - 호스트 주소 자동설정: IPv6 네트워크에 접속하는 순간 자동적으로 네트워크 주소를 할당받음
>     - 헤더 구조 단순화: 불필요 필드가 제외되거나 확장 헤더로 변경되어 과도한 오류 제어와 같은 오버헤드를 줄여 전송 효율 증대
>     - 흐름 제어기능 지원: 흐름 제어 지원 가능한 필드인 Flow Label 을 도입, 특정 트래픽은 실시간 통신 등 특별 처리하여 품질
>     높은 서비스 제공
>     - 인증 및 보안 기능: 패킷 출처 인증, 데이터 무결성 및 비밀 보장 기능을 IPv6 확장 헤더를 통해 적용 가능
>     - 이동성: IPv6 호스트는 네트워크의 물리적 위치에 제한받지 않고 같은 주소를 유지하면서 자유롭게 이동 가능
> - **IPv4 와 비교**
>     - 32bit vs 128bit > 약 42억 9천만 개 vs 약 340간 2823구 ... 6337경 4607조 ...

### 네트워크 설정

**리눅스에서의 네트워크 환경 설정**을 위해 네트워크 하드웨어를 설치해야 하고, 다음으로 네트워크 프로토콜, 네트워크 서비스 프로그램 순으로 설치
해야 합니다.

> **네트워크 하드웨어**: 이더넷 카드, 모뎀, ISDN, AX.25, ATM 등 (+ Xen, KVM, VirtualBox, docker 등 가상화 기술도 지원)
> - lo: 로컬 루프백. 127.0.0.1 주소가 설정되고 자체적인 PING 테스트 등 네트워크 디버깅에 사용
> - ethx: 이더넷 카드 인터페이스 장치(eth0, eth1 등)

- **설치 과정**
    - 하드웨어 설치: 위에서 언급한것 중 필요한 네트워크 하드웨어 설치
    - 프로토콜 설치: SLIP, PPP, TCP/IP 등. 네트워크 기반 OS인 리눅스는 대부분의 프로토콜을 기본적으로 제공함(**/etc/protocols**)
    - 서비스 프로그램 설치: 웹 서비스를 위한 웹 서버, 메일 서버, FTP 서버 등

**인터넷 접속** 위해서 IP 주소 관련설정이 필요합니다.

- **IP 주소 설정**
    - DHCP 서버에 의해 자동으로 할당받거나, 서버로 사용하거나 고정 IP가 할당된 경우 정확한 정보설정 필요
    - **넷마스크(Netmask)**: 특정 범주의 네트워크를 구성하거나 식별하기 위한 도구(서브넷마스크라고도 함) or NetID 와 HostID 식별 도구
        - 주소의 32bit 자리 중 네트워크 식별자(NetID) 부분을 이진수 1로 처리하고 나머지 호스트 식별자(HostID) 부분을 0으로 처리하여
        실제 IP 주소와 이진수 AND 연산시 **해당 주소의 네트워크를 알 수 있도록** 함
        - 대표적으로 **A 클래스의 넷마스크**는 십진수 255.0.0.0(이진수로는 11111111.00000000.00000000.00000000)로, 해당 네트워크 내
        어떤 IP 주소와 매핑해도 A 클래스임을 알 수 있음 (이것을 넷마스크라 함)
        - 네트워크 대역에서 2개의 주소는 일반 컴퓨터 주소로 사용할 수 없음. 최하 0번 주소는 네트워크 주소, 마지막 주소는 브로드캐스트 주소로
        할당됨
    - **게이트웨이(Gateway)**: 서로 다른 통신망 혹은 프로토콜을 사용하는 네트워크 간 통신이 가능하게 하는 컴퓨터나 소프트웨어의 통칭.
    일반적으로 통로의 역할이며, IP 주소는 해당 네트워크 대역에서 1번 혹은 254번으로 할당됨

> **넷마스크와 서브넷마스크**
> - A, B, C 클래스의 네트워크를 나누는 8bit, 16bit, 24bit 짜리 마스크를 **넷마스크**라 함
> - 이보다 잘게 쪼개지는 마스크를 **서브넷마스크**라 함
> - 하지만 오늘날 **CIDR 표기법**을 사용하면서 사실상 구분이 무의미하게 됨
> - 예를 들어, 255.255.255.0 의 C 클래스 넷마스크를 가진 네트워크의 192.168.1.1 호스트의 주소는 **192.168.1.1/24** 로 표현 가능하고,
> 절반으로 쪼개진 255.255.255.128 서브넷의 동일 호스트 주소는 **192.168.1.1/25** 로써 표현되어 사실상 넷마스크와 서브넷마스크 간의 구분이
> 의미가 없게됨 (그냥 CIDR 로 쓰면됨)
> - **이러한 서브넷마스크 개념은 서브네팅(Subnetting)에 사용됨**

> **서브네팅(Subnetting)**: C 클래스 기준으로 설명
> - **네트워크를 보다 잘게 쪼개는 것**을 서브네팅이라고 함
> - C 클래스의 네트워크는 총 256개의 호스트를 가지며, 이를 두 개의 네트워크로 서브네팅하면 각각 128개의 호스트를 가지는 서브넷으로 나뉨

다음으로 리눅스 환경에서 **네트워크 인터페이스 설정 방법**을 알아보겠습니다.

- **GUI 기반 네트워크 설정(CentOS 6.4 기준)**
    1. X 윈도 패널의 **[시스템]** > **[기본 설정]** > **[네트워크 연결]** 선택하면 네트워크 인터페이스 설정 창이 나타남(명령행으로는
    **```$ nm-connection-editor```** 입력)
    2. 설정하려는 네트워크 인터페이스 장치 선택하고 **[변경]** > **[IPv4 설정]** 선택
    3. 자동 할당 ID 는 '**자동(DHCP)**' 선택하고, 수동으로 할당하려면 '**수동**' 선택 후 적절한 IP 주소 값을 입력

- **텍스트 기반 유틸리티 사용**
    - 간단하므로 책 참조(p. 176)

- **네트워크 관련 파일 이용**
    - 리눅스에서 네트워크 관련 정보는 **/etc/sysconfig/network**, **/etc/sysconfig/network-scripts/ifcfg-eth0**,
    **/etc/resolv.conf** 등의 파일에 저장
    - 이러한 파일을 vi 편집기로 수정하여 직접 변경 가능 (변경 후 네트워크 데몬 재시작 > ```$ service network restart```)

리눅스에서 사용되는 **네트워크 관련 명령어**입니다.

- **ifconfig(interface config)**
    - 네트워크 인터페이스를 설정하거나 확인하는 명령 (IP 주소, 넷마스크, MAC 주소 등)
    - **```$ ifconfig [interface] [address] [option]```**
    - 조회시 나타나는 항목 설명
        - **Link encap**: 네트워크 인터페이스의 형식을 나타냄(ex. Ethernet)
        - **Hwaddr**: 이더넷 카드에 설정되어 있는 48bit 형식의 고유한 하드웨어 주소로, 보통 MAC(Media Address Control) 주소라 부름
        (ex. 08:00:27:01:DB:E0)
        - **inet addr**: IPv4 주소
        - **Bcast**: 브로드캐스트 주소
        - **Mask**: 넷마스크 주소
        - **inet6 addr**: IPv6 주소
        - **UP**: 해당 네트워크 인터페이스가 활성화되어 있음 (ex. UP BROADCAST RUNNING MULTICAST)
        - **BROADCAST**: 브로드캐스트 사용
        - **RUNNING**: 동작중임
        - **MULTICAST**: 멀티캐스트 사용
        - **MTU**: Maximum Transmission Unit. 한 번에 전송할 수 있는 최대 패킷의 크기 (ex. 1500)
        - **Metric**: 라우팅 시 참조되는 거리로, 로컬의 경우 1 (ex. 1)
        - **RX/TX**: 수신 패킷 수와 전송 패킷 관련 수 (ex. RX packets:158 ..., TX packets:213 ...)
        - **collisions**: 충돌이 발생한 패킷 수 (ex. 0)
    - ex.
        - **```$ ifconfig eth0 down```**: eth0 카드 작동 중지(ifdown eth0)
        - **```$ ifconfig eth0 up```**: eth0 카드 작동 활성화(ifup eth0)
        - **```$ ifconfig eth0 192.168.0.2 netmask 255.255.255.0 broadcast 192.168.0.255 up```**:
        eth0 카드 네트워크 환경 설정

- **route**
    - 라우팅 테이블의 정보를 출력하거나 관리하는 명령. 네트워크 주소, 게이트웨이 주소 확인하거나 설정
    - **```$ route [add|del] [-destination] [netmask 값] [gw 값] [dev 인터페이스]```**
    - 조회시 나타나는 항목 설명
        - **Destination**: 목적지의 네트워크 주소(NetID). default 인 행은 목적지로 등록되지 않은 모든 네트워크 주소를 처리하는 설정.
        - **Gateway**: 목적지 주소로 보내기 위한 게이트웨이 주소
        - **Genmask**: 목적지의 네트워크 주소(NetID)를 알아내기 위한 넷마스크
        - **Flags**: 목적지 네트워크와의 연결 상태
            - **U**: 인터페이스가 사용되고 있음
            - **G**: 라우트가 게이트웨이로 사용되고 있음
            - **H**: 오직 단독 호스트만이 라우트를 거쳐서 접근할 수 있음. 이 경우 루프백 엔트리는 127.0.0.1
            - **D**: 테이블 엔트리가 설정된 경우, ICMP 리다이렉트 메시지로 운영됨
            - **M**: 테이블 엔트리가 설정된 경우, ICMP 리다이렉트 메시지에 의해 수정되고 있음을 나타냄
        - **Metric**: 목적지 네트워크와의 거리(Hop count). 직접 연결되어 있으면 0 이며, 라우터 하나 거칠때마다 1씩 증가
        - **Ref**: 다른 라우터가 목적지로 가기 위해 참조한 횟수
        - **Use**: 다른 라우터가 목적지로 가기 위해 사용한 횟수
        - **Iface**: 목적지 네트워크와 연결된 인터페이스 (장치)를 나타냄
    - ex.
        - **```$ route del -net 192.168.3.0 netmask 255.255.255.0```**: 설정되어 있던 네트워크 주소 삭제
        - **```$ route add -net 192.168.3.128 netmask 255.255.255.192 dev eth0```**: eth0 에 주소 설정. 카드가 하나인 경우 생략가능
        - **```$ route del default gw 192.168.3.1```**: 게이트웨이 주소 삭제
        - **```$ route add default gw 192.168.3.254 eth0```**: 게이트웨이 주소 설정. 카드 하나시 생략가능

- **netstat**
    - 네트워크 연결 상태를 출력하는 명령. 또한 라우팅 테이블 정보, 네트워크 인터페이스 상태, 매스커레이드(masquerade) 연결 상태,
    멀티캐스트 멤버 등의 정보 출력
    - **```$ netstat [option] [address_family_option]```**
    - 주요 옵션
        - **-a**: 모든 소켓 정보 출력
        - **-n**: 기호화된 호스트명이나 포트켱 대신 숫자값 표시 (ex. www 대신 80 출력)
        - **-p**: 소켓에 대한 PID 와 프로그램명 출력
        - **-r**: 라우팅 테이블 정보 출력
        - **-l**: 대기하고 있는 포트인 리슨(Listen) 포트 출력
        - **-i**: 네트워크 인터페이스 테이블 정보 출력
        - **-s**: 네트워크 프로토콜에 대한 통계 정보 출력
        - **-c**: 네트워크 정보를 계속적으로 출력
        - **-t**: TCP 프로토콜 기반으로 접속한 목록 출력
        - **-u**: UDP 프로토콜 기반으로 접속한 목록 출력
        - **-g**: 멀티캐스트 그룹 멤버의 정보 출력
        - **[address family option]**
            - **--protocol=값**: inet, unix, ipx, ax25 등 특정 프로토콜과 연관된 정보를 출력
            - **--inet, --ip**: IP 주소 기반으로 연결된 정보 출력 ('--protocol=inet' 과 같은 결과)
            - **--unix**: UNIX Domain Socket 정보 출력. 이 소켓은 운영체제에서 실행되는 프로세스 간의 데이터 교환을 하기 위해 사용되는
            통신 연결 포인트라 할 수 있음 ('--protocol=unix' 와 같은 결과)
    - **netstat 의 State 결과**
        - **LISTEN**: 서버에서 클라이언트로부터 들어오는 패킷을 위해 소켓을 열고 기다리는 상태
        - **SYS-SENT**: 로컬 시스템의 클라이언트 애플리케이션이 원격 호스트에 연결을 요청한 상태
        - **SYN-RECEIVED**: 서버 시스템이 원격 클라이언트로부터 접속 요구를 받아 클라이언트에게 응답을 했지만,
        아직 클라이언트에게 확인 메시지는 받지 않은 상태
        - **ESTABLISHED**: 3Way-Handshaking 이 완료된 후 서버와 클라이언트가 서로 연결된 상태
        - **FIN-WAIT1**: 소켓이 닫히고 연결이 종료되는 상태
        - **FIN-WAIT2**: 연결은 종료된 상태이고, 소켓이 원격 호스트로부터 종료되었다는 정보를 기다리고 있는 상태
        - **CLOSE-WAIT**: 원격 호스트는 종료된 상태이고 소켓을 종료하기 위해 기다리는 상태
        - **CLOSING**: 흔하지 않지만 주로 확인 메시지가 전송 도중 분실된 상태
        - **TIME-WAIT**: 패킷 처리가 끝났지만 분실되었을지 모를 느린 세그먼트를 위해 당분간 소켓을 열어놓은 상태
        - **CLOSED**: 소켓 연결이 종료된 상태
        - **LAST-ACK**: 원격 호스트가 종료되고 소켓도 닫힌 상태에서 마지막 ACK 패킷을 기다리는 상태
        - **UNKNOWN**: 소켓 상태를 확인할 수 없는 상태
    - ex.
        - **```$ netstat -anp```**: 모든 소켓 PID 및 프로그램명을 출력하되, 호스트명, 포트명 등은 숫자값으로 출력
        - **```$ netstat --inet```**: IP 기반 접속 목록 출력

- **arp(Address Resolution Protocol**
    - **ARP Cache** 를 관리하는 명령. ARP Cache 란, 현재 접속되어 있는 32bit IP 주소를 하드웨어 주로(MAC)로 바꿔서 기억하는 곳
    - 이것을 보면 현재 들어와 있는 호스트에 대한 정보를 알아낼 수 있음 (15분 정도 미사용된 캐시는 제거됨)
    - **```$ arp [option]```**
    - 주요 옵션
        - **-a**: ARP 캐시에 기록된 정보 중 특정 호스트에 대한 정보를 출력
        - **-d**: ARP 캐시에서 해당 호스트 정보를 제거
        - **-n**: 출력시 도메인 주소 대신에 IP 주소로 출력
        - **-v**: 자세히 출력
    - ex.
        - **```$ arp```**, **```$ arp -n```**: Address 부분은 도메인 주소로 출력되었다가, IP 주소로 출력됨

- **ping(Packet Internet Groper)**
    - 인터넷 제어 메시지 프로토콜인 **ICMP(Internet Control Message Protocol)** 을 이용하여 네트워크 연결을 확인하는 연결
    - 원격의 호스트와 연결되어 있는지 확인하고, 패킷을 보내고 받는 시간을 나타내 네트워크 장애 여부도 판단 가능
    - 최근에는 라우터나 방화벽에서 ICMP 프로토콜을 차단하여 ping 이나 traceroute 같은 명령을 제한하는 곳이 많아짐
    - **```$ ping [option] [Hostname] 또는 [IP Address]```**
    - 주요 옵션
        - **-c [개수]**: 몇 개의 패킷을 보낼지 설정. 기본적으로 무한 개 전송
        - **-i [초]**: 몇초 간격으로 패킷을 보낼 것인지 설정. 기본적으로 1초
        - **-s [패킷 크기]**: 전송하는 패킷 크기를 byte 단위로 설정. 기본값은 56byte
        (56byte + ICMP 헤더 데이터인 8byte, 총 64byte).
        만약 1024byte 크기로 보내려면 '-s 1016' 으로 설정
        - **-w [초]**: 패킷을 보내고 몇초 후에 실행을 멈출 것인지 설정. -c 옵션과 같이 사용시 둘 중 먼저 끝나는 값을 반영
    - ex.
        - **```$ ping -c 4 localhost```**: 기본 64byte 패킷 메시지 4개 전송

- **traceroute**
    - 패킷이 특정 호스트까지 라우팅되는 과정을 출력하는 명령. 중간에 발생한 장애의 위치 파악 가능
    - **```$ traceroute [Hostname] or [IP Addreaa]```**
    - ex.
        - **```$ traceroute www.ihd.or.kr```**

> **traceroute 동작 원리**
> - 출발지에서는 순차적으로 TTL=1, TTL=2, TTL=3, ... TTL=n 인 **ICMP echo request** 를 보내고,
>TTL=0 이 되는 노드의 네트워크 장비가
> **ICMP time exceed** 를 발생시키고 되돌려보내 n번째 장비까지의 delay 를 알아내는 방식으로 동작
> - 종종 중간 단계 장비에서 timeout 현상(*로 표기)이 나타나는 경우가 있는데, 이는 ICMP time exceed 를 생성하여 되돌려보내지 않도록
> 설계되거나 설정된 경우일 수 있음. 또는 ICMP 프로토콜 자체를 차단하기도 함

- **nslookup**
    - DNS 를 이용하여 도메인이나 IP 를 조회하는 명령
    - 셸 커맨드 방식으로 한 번도 가능하지만, 대화식(> )으로 여러 설정과 도메인 조회 가능
    - **```$ nslookup [option] [Hostname] 또는 [IP Address]```**
    - 주요 옵션
        - **-type=[서버타입]**: mx(메일 서버), ns(네임 서버) 등의 서버타입 조회
    - ex.
        - **```$ nslookup exam.ihd.or.kr```**: 네임 서버 정보와 함께 타겟 도메인의 IP 주소 출력
        - **```$ nslookup -type=mx naver.com```**: 네이버의 메일 서버 설정 정보 출력

- **dig**
    - 도메인명(FQDN: Fully Qualified Domain Name)으로 조회
    - **```$ dig [option] [도메인명] [type]```** (MX, A, ANY 등 DNS 서버 type 설정)
    - 주요 옵션
        - **-t**: 질의 타입 지정. 기본값인 A 는 IP 조회. MX, NS, ANY 등 지정 가능(대소문자 구분하지 않음)
    - ex.
        - **```$ dig www.ihd.or.kr```**: IP 주소 조회
        - **```$ dig ihd.or.kr Mx```**: 메일 서버 정보 출력
        - **```$ dig -t ns ihd.or.kr```**: 네임 서버 정보 출력

- **host**
    - 도메인명으로 조회
    - **```$ host [option] [도메인명]```**
    - 주요 옵션
        - **-t**: dig 와 동일하게 질의 타입 지정
        - **-v**: 지정한 도메인에 대한 자세한 정보 출력
        - **-a**: -v 와 같지만 MX, NS 등의 타입값 위주로 출력
    - ex.
        - **```$ host ihd.or.kr```**
        - **```$ host -v ihd.or.kr```**

- **hostname**
    - 시스템에 설정된 호스트명을 출력하거나 설정하는 명령
    - **```$ hostname [option] [Hostname]```**
    - 주요 옵션
        - **-v**: 자세한 호스트명 정보 출력
        - **-d**: 도메인명만 출력 (ex. ihd.or.kr)
        - **-f**: 완전한 호스트명(FQDN) 출력 (ex. www.ihd.or.kr)
        - **-a**: 호스트명의 Alias 출력
        - **-i**: 호스트명에 설정된 IP 주소 출력
    - ex.
        - **```$ hostname -f```**: FQDN 출력
        - **```# hostname www.ihd.or.kr```**: 호스트명 지정

- **mii-tool(Media Independent Interface Tool)**
    - 네트워크 인터페이스의 상태를 점검하고 설정하는 유틸리티
    - **```# mii-tool [option] [Interface]```**
    - 주요 옵션
        - **-r**: 네트워크 인터페이스 자동 인식을 위해 재시작 (--restart)
        - **-F**: 강제로 설정 (--force)
        - **-v**: 관련정보 자세히 출력
    - ex.
        - **```# mii-tool -v --force 100baseTX-FD eth1```**: eth1 강제 설정
        - **```# mii-tool -r```**: 네트워크 인터페이스 자동 인식

- **ethtool**
    - 이더넷 카드 정보를 출력하거나 변경하는 명령
    - **```# ethtool ethx```**
    - 주요 옵션
        - **-s**: 이더넷 카드 설정 변경 (--change)
    - ex.
        - **```# ethtool -s eth0 speed 1000 duplex full autoneg off```**: eth0 장치의 설정 변경

- **ip**
    - 이더넷 장치, IP 주소, 라우팅 정보 등의 설정정보를 출력하거나 변경하는 명령
    - **```# ip [option] [대상] [command]```**
    - ex.
        - **```# ip addr show```**: IP 주소정보 출력
        - **```# ip addr del 192.168.5.13/24 dev eth1```**: IP 주소정보 삭제
        - **```# ip addr add 192.168.5.13/24 dev eth1```**: IP 주소 지정
        - **```# ip link set eth1 up```**: 네트워크 인터페이스 활성화
        - **```# ip link set eth1 down```**: 네트워크 인터페이스 비활성화
        - **```# ip link set eth0 address aa:bb:cc:dd:ee:ff```**: eth0 의 MAC 주소를 aa:bb:cc:dd:ee:ff 로 설정
        - **```# ip route show```**: 라우팅 테이블 정보 출력
        - **```# ip route add default via 192.168.5.1```**: 게이트웨이 주소 값을 설정
        - **```# ip route del default via 192.168.5.1```**: 게이트웨이 주소 값을 삭제
        - **```# ip route add 10.10.12.0/24 via 192.168.5.1 dev eth0```**: 정적 라우팅 정보 설정
        - **```# ip route del 10.10.12.0/24```**: 정적 라우팅 정보 삭제

> **정적 라우팅 파일 등록**
> - **```# vim /etc/sysconfig/network-scripts/route-eth0```
> - > **10.10.12.0/24 via 192.168.5.1 dev eth0**

- **ss(Socket Statistics)**
    - 소켓 상태를 출력하는 명령으로 netstat 과 유사함
    - 다른 도구에 비해 TCP 및 더욱 많은 상태정보를 제공
    - **```# ss [option] [필터]```** (필터는 'state TCP-상태값 표현식' 형태로 사용 가능)
    - 주요 옵션
        - **-a**: --all
        - **-n**: 서비스명으로 resolving 하지 않고 숫자값으로 출력 (--numeric)
        - **-r**: 숫자값 형태의 주소나 포트정보를 호스트명이나 서비스명으로 resolving 해서 출력 (--resolve)
        - **-l**: 서비스 연결을 위해 대기중인 소켓정보 출력 (--listening)
        - **-o**: 시간(timer) 관련 정보를 출력 (--options)
        - **-e**: 소켓정보를 확장해서 자세히 출력 (--extend)
        - **-p**: 소켓을 사용중인 프로세스 정보 출력 (--processes)
        - **-i**: 시스템 내부의 TCP 정보 출력 (--info)
        - **-s**: 소켓 관련 상태정보를 요약해서 출력 (--summary)
        - **-4**: IPv4 관련 정보만 출력 (--ipv4)
        - **-6**: IPv6 관련 정보만 출력 (--ipv6)
        - **-0**: PACKET 소켓 정보 출력 (--packet)
        - **-t**: TCP 관련 소켓 정보만 출력 (--tcp)
        - **-u**: UDP 관련 소켓 정보만 출력 (--udp)
        - **-x**: 유닉스 도메인 소켓 정보만 출력 (--unix)
        - **-f [패밀리명]**: 소켓의 특정 타입을 지정해서 출력. 지원되는 패밀리명에는 unit, inet, inet6, link, netlink 가 있음
        (--family=[패밀리명])
    - ex.
        - **```# ss```**: 소켓에 연결된(**ESTABLISHED**) 정보만 출력
        - **```# ss -n```**: resolving 된 서비스명 대신 숫자값을 출력 (ex. 포트 정보 출력시 http 대신 80 출력)
        - **```# ss state established '( dport = :ssh or sport = :ssh )' -t'```**: TCP 기반의 ssh 포트를 사용하는
        소켓 정보만 출력

마지막으로 **네트워크 관련 파일**을 살펴보겠습니다.

- **/etc/sysconfig/network**
    - 네트워크 사용 유무(NETWORKING=yes), 호스트명(HOSTNAME=www), 게이트웨이 주소(GATEWAY), 게이트웨이 장치 파일(GATEWAYDEV),
    NIS 도메인 이름(NISDOMAIN) 등 설정
    - 최근 게이트웨이 주소는 이더넷 디바이스 파일인 ifcfg-eth0 에 기록되고 있음

- **/etc/sysconfig/network-scripts 디렉토리**
    - 네트워크 인터페이스 환경 설정과 관련된 파일이 저장되는 곳
    - 이더넷 카드는 ifcfg-eth0, ifcfg-eth1, ... 등으로 순차적으로 저장됨
    - 해당 파일 내에는 디바이스명, 프로토콜, IP 주소 등 네트워크 설정과 관련된 전반적인 내용이 기록됨
    (+ 최근에는 게이트웨이 주소, DNS 서버 등)

- **/etc/resolv.conf**
    - 시스템에서 사용하는 네임서버(DNS) 설정 파일
    - ex.
    ```text
    # Generated by NetworkManager
    nameserver 203.247.32.31
    nameserver 168.126.63.1
    ```

- **/etc/hosts**
    - DNS 서버를 사용하기 이전에 많이 이용된 파일로 자주 사용되는 IP 주소와 호스트명을 매핑시켜 데이터베이스처럼 사용하는 파일.
    별칭 지정 가능

### 1-4. 기출 예상문제 오답노트

<br><br>
## 2. 리눅스 시스템 관리

### 2-1. 일반 운영 관리

### 사용자 관리

리눅스에서 **root** 계정은 자동으로 존재하는 Super User 로써 최고관리자 역할을 합니다.

먼저 **사용자(User) 개요**에 대해 살펴보겠습니다.

- **사용자의 분류**
    - 리눅스의 사용자는 크게 root 사용자와 일반 사용자로 구분
    - **root 사용자**는 시스템 운영에 있어 모든 권한을 행사하기 때문에 Privileged User 또는 Super User 라 함
    - **일반 사용자**는 역할에 따라 제한된 권한을 갖는데, 로그인이 가능한 사용자와 시스템의 필요에 의해 생성된 시스템 계정으로 나눔
    - 리눅스에서 모든 사용자는 계정 생성 시 자동으로 할당되는 숫자값이 UID(User Identity)로 관리됨
    (수동 지정도 가능, ```# useradd -u```)
    - UID 는 0번부터 할당되며, root 가 0번이기 때문에 0번 사용자를 수퍼유저로 인식함
    - 새로운 사용자 생성 시 레드햇 계열은 UID=500 부터, 데비안 계열은 UID=1000 부터 할당됨

- **시스템 계정**
    - 리눅스 사용자 계정 정보는 **/etc/passwd** 파일에 기록됨
    - 이 파일에 기록된 bin, daemon, adm, game 등 관리자가 생성하지 않은 계정들을 **시스템 계정**이라 함
    - 시스템 계정이 기본적으로 존재하는 이유는 **모든 시스템 파일에 root 관련 소유권과 권한을 부여하지 않기** 위함
    - 이는 특정 시스템 프로그램이 실행되면서 **root 관련 핵심 시스템 파일에 간섭하는 것을 원천적으로 차단**함
    - ex.
        - 예를 들어, root 권한으로 실행된 game 프로그램이 오류를 일으켜 실행관련 정보를 /etc/inittab 에 기록하게 되면
        시스템이 부팅되지 않는 최악의 상황이 발생할 수 있음!
        - game 이라는 시스템 계정이 존재하여 그 권한으로 game 프로그램이 실행된다면,
        위와 같은 핵심 시스템 파일에 원천적으로 접근이 불가함

> **일반 사용자를 수퍼유저로 전환**
> - 리눅스에서 UID 와 GID 가 0이 되면 계정에 관계없이 수퍼유저가 됨
> - 이러한 방식은 적절한 권한할당 방식이 아니므로, 특정 계정에 sudo 권한을 임시로 부여하는 방식으로 활용함

- **root 계정 관리**
    - 루트 계정 관리를 위해, **(1) 다른 수퍼유저가 존재하는지 점검(UID=0 인 다른 유저가 있는지?)** 후
    - **(2) PAM(Pluggable Authentication Modules) 을 이용하여 root 계정으로 직접 로그인하는 것을 막고**,
    필요시 su 명령의 사용을 유도
    - **(3) 환경 변수인 TMOUT 을 설정하여 무의미하게 장시간 로그인하는 것을 막음**
    - **(4) 일반 사용자에게 특정 명령어 권한만 할당해 줄 경우, su 보다는 sudo 를 이용하도록 함**

다음으로 **사용자 계정 관리**에 대해 살펴봅니다.

- **useradd**
    - 사용자 계정 생성 명령어
    - **```# useradd [option] [계정] [이름]```**
    - 주요 옵션
        - **-p**: 사용자의 암호를 추가 지정. 리눅스에서 암호화된 값으로 지정해야 함
        - **-d**: 사용자 홈 디렉토리 지정. 이 커맨드는 기본적으로 홈 디렉토리를 생성하지 않으므로 지정한 디렉토리를 생성하는
        -m 옵션과 함께 사용되어야 함
        - **-g**: 사용자 그룹 지정. 그룹이 미리 생성되어 있어야 함. 레드햇 계열에서는 기본적으로 아이디와 동일한 그룹에 포함시키고, 다른
        배포판에서는 users 에 포함시킴
        - **-G**: 추가 그룹 지정 (--groups)
        - **-c**: 사용자에 대한 설명 지정
        - **-s**: 사용자가 사용할 기본 셸 지정
        - **-D**: /etc/default/useradd 에 설정된 유저 추가와 관련된 기본 사항들을 보여줌
        - **-m**: 사용자 생성 시 홈 디렉토리를 생성하는 옵션. 레드햇 리눅스는 이 옵션 없이도 생성되지만, 다른 배포판에서는 그렇지 않음
        - **-k**: 사용자 생성 시 /etc/skel 에 지정된 기본 정보를 활용해 기본 환경 파일 제공하는데,
        이 옵션은 다른 경로의 skeldir 를 지정함
        - **-f**: 사용자의 패스워드 만기일을 날짜수로 지정
        - **-e**: 사용자 계정의 만기일을 YYYY-MM-DD 형식으로 지정
        - **-u**: 사용자 생성 시 UID 값 지정
    - ex.
        - **```# useradd marine -d /home/terran/marine -g terran```**: 생성 시 홈 디렉토리와 그룹 지정. 미리 생성되어 있어야 함
        - **```# useradd -D```**: 사용자 생성 시 기본적으로 적용되는 정보 출력 (/etc/default/useradd)
        ```text
        GROUP=100
        HOME=/home
        INACTIVE=1
        EXPIRE=
        SHELL=/bin/bash
        SKEL=/etc/skel
        ```

> **adduser**
> - **useradd** 명령은 아주 기본적인 계정 생성 정보만 제공하므로 세세한 옵션 지정에 유용힘
> - **adduser** 명령은 지정한 계정명에 해당하는 홈 디렉토리를 옵션지정 없이 자동으로 생성하여 간편하게 일반 계정 생성이 가능함
> - **adduser** 명령은 대화형으로 암호, FULLNAME 등 부가적인 정보를 입력받아 계정을 생성하며,
> 이에 적용되는 기본 정보는 **/etc/adduser.conf** 에 기록되어 있음

- **passwd**
    - 사용자 암호 부여 및 변경 명령어
    - useradd 로 계정 생성 후 passwd 로 암호를 지정하지 않으면(또는 -p 옵션) 로그인이 되지 않음
    - 다른 사용자의 암호 변경은 root 만 가능
    - **```$ passwd [사용자명]```**

- **su**
    - substitute user 의 대리 유저라는 의미로, 다른 사용자의 권한으로 셸을 전환하는 명령어
    - 전환시 패스워드 입력이 필요하며, exit 커맨드로 이전 사용자 셸로 빠져나올 수 있음
    - 사용자명을 지정하지 않으면 root 로 전환
    - root 관리자의 경우 telnet 등 원격접속이 불가하므로, su 명령으로 일반 사용자의 셸로 전환하여 수행 (이 때는 패스워드 x)
    - **```$ su [option] [사용자명]```**
    - 주요 옵션
        - **-, -l**: su 명령만 사용하면 셸 전환 이전 사용자의 환경변수 값이 그대로 유지되며 지정한 사용자의 권한으로만 변경됨. 이 옵션을
        포함하면 지정한 사용자의 권한뿐 아니라 실제 그 사용자가 로그인한 것처럼 셸이 전환됨 (--login)
        - **-c**: 사용자를 전환하지 않고 다른 사용자의 권한으로 명령을 일시적으로 수행 (--command)
    - ex.
        - **```$ su```**: root 사용자로 셸이 변경되지만 환경변수 등은 이전 사용자의 환경으로 유지됨.
        이에 따른 root 권한 제약 발생 가능
        - **```$ su -```**: root 사용자로 로그인한 효과. 모든 환경이 전환됨
        - **```$ su root -c "tail /etc/shadow"```**: 사용자 전환 없이 root 권한으로 -c 옵션 이하의 커맨드를 일회적으로 수행
        - **```# su - yuloje```**: 사용자 전환. root 에서 전환하는 경우 패스워드 묻지 않음

다음으로 **사용자 관련 파일**을 살펴보겠습니다.

리눅스에서 대부분의 시스템 정보는 텍스트 파일에 저장해서 관리됩니다. 따라서 사용자 계정관련 모든 정보도 텍스트 파일로 관리됩니다.

**useradd** 명령으로 사용자 생성 시 사용자 기본 정보는 **/etc/default/useradd** 파일에서 차용하여 **/etc/passwd**, **/etc/group**,
**/etc/shadow** 등의 파일에 기록되고, 기본 홈 디렉토리 생성 정보는 **/etc/skel** 디렉토리에서 기본적으로 차용하여 보통 **/home/[계정명]**
방식으로 생성됩니다.

- **/etc/passwd**
    - 모든 사용자 정보목록 파일. 각 사용자 정보의 7개 필드들은 콜론(:)으로 구분됨
    - 새 사용자를 생성하면 지정된 형식으로 파일의 마지막 줄에 관련 정보가 추가되며 UID 는 보통 마지막 계정의 다음 숫자로 지정됨
    - 형식: **[USERNAME]:[PSSSWORD]:[UID]:[GID]:[FULLNAME]:[HOME-DIRECTORY]:[SHELL]**
    - ex.
        - **posein:x&nbsp;:500:500:System Engineer:/home/posein:/bin/bash**
    - 패스워드 필드의 경우 암호화되어 **/etc/shadow** 에 별도 관리됨

- **/etc/shadow**
    - **/etc/passwd** 의 두 번째 필드인 패스워드를 암호화하여 관리하는 파일이며 총 9개의 필드로 구성됨 (오직 root 만 접근가능)
    - 형식: **[USERNAME]:[PASSWORD]:[LAST]:[MAY]:[MUST]:[WARN]:[EXPIRE]:[DISABLE]:[RESERVED]**
    - 필드 설명
        - **USERNAME**: 사용자 계정. 아이디
        - **PASSWORD**: 암호화(encode)된 패스워드. 초기에는 MD5 알고리즘, SHA-512 알고리즘을 사용하는 경우 $6 으로 시작됨
        - **LAST**: 가장 최근에 패스워드를 바꾼 날. 1970년 1월 1일부터 일수로 계산한 숫자 (ex. 15917 은 2013년 7월 31일)
        - **MAY**: 패스워드 변경 후 최소로 사용해야 하는 날짜 수. 패스워드 재변경까지의 유예 기간 (ex. 0이면 언제든 변경 가능)
        - **MUST**: 현재 사용중인 패스워드의 최대 사용 기간, 즉 유효기간 (ex. 99999 는 사실상 변경 기한 없음)
        - **WARN**: 패스워드 유효기간이 만료되기 전에 경고를 나타내는 기간 (ex. 7은 7일전부터 경고 알림)
        - **EXPIRE**: 패스워드 만료 이후 실제 계정 사용이 불가하기까지의 기간. 일종의 유예기간 (ex. 3은 3일간 유예)
        - **DISABLE**: 계정 만기일. 실제 계정 사용이 불가능하게 되는 날을 나타냄. 마찬가지로 1970년 1월 1일부터 일수로 계산
        - **RESERVED**: 다른 기능을 위해 남겨둔 예약공간. 아직 사용되지 않음

> **pwconv, pwunconv**
> - 패스워드를 **/etc/shadow** 가 아닌 **/etc/passwd** 에서 직접 관리하려면 **pwconv** 입력, 다시 되돌리려면 **pwunconv** 입력
> - 효율성과 보안성 면에서 **/etc/shadow** 활용이 좋음

> **pwch**
> - Password Check 의 약자로 **/etc/passwd** 와 **/etc/shadow** 파일을 점검
> - 각 사용자의 필드 개수 검사, 아이디 중복유무 검사, 유효한 사용자 여부 검사, 유효한 UID 및 GID 여부 검사, 사용자의 Primary 그룹 존재유무
> 검사, 홈 디렉토리 존재유무 검사, 로그인 셸 검사 등 수행

- **/etc/default/useradd**
    - **useradd** 명령으로 사용자 생성 시 기본적으로 적용되는 설정이 들어있는 파일
    - **```$ useradd -D```** 입력으로 내용확인 가능
    - 항목 섦명
        - **GROUP=100**: 기본 GID=100 인 users 그룹에 속하게 됨. 레드햇의 경우 생성하는 사용자명과 동일한 그룹을 생성하여 소속시킴
        - **HOME=/home**: 기본 /home/[사용자명] 디렉토리를 홈 디렉토리로 지정
        - **INACTIVE=-1**: 패스워드 사용기한이 지난 뒤 실제 로그인을 막는 유예기간 설정. -1은 상징적 의미로, 설정되지 않음을 의미 (0은 없음)
        - **EXPIRE=**: 계정 유효기간을 지정 (YYYY-MM-DD 형식)
        - **SHELL=/bin/bash**: 기본 셸 지정
        - **SKEL=/etc/skel**: 사용자 생성 시 기본 제공되는 파일 및 디렉토리가 들어 있는 디렉토리 지정
        - **CREATE_MAIL_SPOOL=yes**: 사용자 생성 시 메일 파일을 생성할 것인지 지정 (**/var/spool/mail/[사용자명]**)

- **useradd 명령을 이용한 /etc/defaults/useradd 파일 관리**
    - **```# useradd -D [option]```**
    - 주요 옵션
        - **-D**: 기본 내용 출력. 설정 변경 시에도 이 옵션을 포함해야 함
        - **-g**: 기본 그룹 설정. 설정하는 그룹은 **/etc/group** 내에 있어야 함
        - **-b**: 사용자 홈 디렉토리의 상위 디렉토리 지정 (/home)
        - **-f**: INACTIVE 행과 관련된 옵션으로, 패스워드 유효기간이 만료된 이후 유예기간을 일자수로 설정
        - **-e**: 사용자 계정 만료일 설정
        - **-s**: 사용자의 기본 셸 설정 옵션
    - ex.
        - **```# useradd -D -b /home2 -s /bin/csh -e 2022-02-27```**

- **/etc/login.defs**
    - 메일 디렉토리, 패스워드 관련 설정(최대 사용기한, 최소 사용기한, 최소 길이, 만기이전 경고 날짜), UID 의 최소값 및 최대값, GID 의 최소값
    및 최대값, 홈 디렉토리 생성 여부, 기본 UMASK 값, 패스워드 암호화 알고리즘 등이 정의되어 있음
    - 항목 설명
        - **MAIL_DIR /var/spool/mail**
        - **PASS_MAX_DAYS 99999**: 패스워드 최대사용기간. 99999면 무제한
        - **PASS_MIN_DAYS 0**: 패스워드 최소사용기간. 0이면 변경제한 없음
        - **PASS_MIN_LEN 5**: 패스워드 최소길이
        - **PASS_WARN_AGE 7**: 패스워드 만기일 도래 전 7일 경고알림
        - **UID_MIN 500**: UID 최소값
        - **UID_MAX 1000**: UID 최대값
        - **GID_MIN 500**: GID 최소값
        - **GID_MAX 60000**: GID 최대값
        - **CREATE_HOME yes**: 홈 디렉토리 생성여부. 레드햇 계열이 아니라면 useradd 시 -m 옵션을 통해 홈 디렉토리 생성을 명시해줘야 함
        - **UMASK 077**: 사용자의 umask 값을 설정. 참고로 umask 022 인 경우 파일은 644, 디렉토리는 755 권한으로 생성됨
        - **USERGROUPS_ENAB yes**: 사용자 생성 시 별도 그룹지정이 없으면 계정명과 동일한 그룹이 자동 생성되는데, 이 설정은 해당 사용자
        제거시 그룹도 자동으로 제거되도록 함
        - **ENCRYPT_METHOD SHA512**: 패스워드 암호화 알고리즘을 SHA512 로 설정

이번에는 **생성된 사용자 계정을 관리하거나 삭제**하는 방식에 대해 살펴봅니다.

- **usermod**
    - 사용자의 셸, 홈 디렉토리, 그룹, UID, GID 등 사용자 관련 대부분의 정보변경 가능
    - **```# usermod [option] [계정명]```**
    - 주요 옵션
        - **-d**: 홈 디렉토리 변경. 변경할 디렉토리는 미리 생성해둬야 함 (--home)
        - **-m**: -d 와 함께 쓰여 기존 홈 디렉토리의 파일 및 디렉토리를 변경할 홈 디렉토리로 옮김 (--move-home)
        - **-g**: 사용자 그룹 변경
        - **-s**: 사용자 셸 변경 (--shell)
        - **-u**: 사용자 UID 변경
        - **-e**: 사용자 계정 만기일 변경 (YYYY-MM-DD or MM/DD/YY)
        - **-f**: 패스워드 만기일 경과 후 로그인 제한 유예기간 변경
        - **-c**: 사용자에 대한 설명, 간단한 정보 변경
        - **-G**: 추가로 다른 그룹에 속하게 함
        - **-a*: -G 와 함께 쓰여 기존의 2차 그룹 외에 추가로 속할 그룹을 지정하도록 함 (--append)
        - **-p**: /etc/shadow 의 두 번째 필드인 암호화된 패스워드 값을 변경 (변경할 값도 암호화되어야 함)
        - **-l**: 사용자 아이디 변경 (--login)
        - **-L**: 사용자의 패스워드에 LOCK 을 걸어 로그인을 막음 (--lock)
        - **-U**: 패스워드 LOCK 해제 (--unlock)
    - ex.
        - **```# usermod -d /home2/posein -m posein```**
        - **```# usermod -g terran drone```**: drone to terran
        - **```# usermod -s /bin/false posein```**: /etc/false 는 실질적인 셸이 아니므로, 해당 계정을 제한할 때 사용됨
        - **```# usermod -e 2022-02-27 jalin```**
        - **```# usermod -G IHD posein```**
        - **```# usermod -l yuloje posein```**: posein to yuloje

> **아이디 변경 시 고려할 점**
> - -l 로 계정명이 바뀌며 홈 디렉토리도 변경되어야 하므로 미리 생성해두어야 하고,
> - -d, -m 옵션을 함께 사용해 지정해줘야 함

- **userdel**
    - 사용자 계정삭제 명령
    - **```# userdel [option] [계정명]```**
    - 주요 옵션
        - **-r**: 사용자의 홈 디렉토리 및 메일관련 파일까지 제거 (--remove)
    - ex.
        - **```# userdel rdsuser```**

> **사용자 계정 삭제시 고려할 점**
> - userdel 명령만 실행시 **/etc/passwd**, **/etc/shadow** 등록정보만 삭제됨
> - 사용자 홈 디렉토리, 메일관련 파일들이 함께 제거하기 위해 **-r** 옵션을 명령에 포함시켜야 함
> - 홈 디렉토리 삭제: **```# rm -rf /home/rdsuser```**
> - 메일관련 삭제: **```# rm -rf /var/spool/mail/rdsuser```**

다음은 **사용자 패스워드 관리**방법입니다.

- **passwd**
    - 기본적으로 패스워드를 부여하거나 변경하는 명령이며 추가로 계정을 사용하지 못하게 하거나 만기일 및 유효기간 등 설정 가능
    - **```# passwd [option] [계정명]```**
    - 주요 옵션
        - **-S**: 패스워드 정보 조회
        - **-l**: 패스워드 잠금을 걸어 로그인을 막음 (--lock)
        - **-u**: 잠금 해제 (--unlock)
        - **-d**: 패스워드 제거. 패스워드 입력 없이 로그인 가능
        - **-n**: 패스워드 설정 및 변경 후 최소 사용해야 하는 날짜수 설정. 값이 3이면 3일동안은 재변경 불가능
        - **-x**: 현재 패스워드 유효기간 설정. 패스워드 최대 사용 날짜수 설정. 값이 90이면 90일동안 사용 가능
        - **-w**: 패스워드 만료 전 경고날짜 설정. 값이 5면 만료 5일 전부터 경고 메시지 보여줌
        - **-i**: 패스워드 만료후 실제로 로그인이 불가능하게 되기까지의 유예기간 설정. 값이 10이면 만료 이후 10일동안 유예
        - **-e**: 다음 로그인 시 반드시 패스워드 변경하도록 강제
    - ex.
        - **```# passwd -S rdsuser```**: 패스워드 정보 출력.
            - ```rdsuser PS 2022-03-13 0 99999 7 3 (Password set, SHA512 crypt.)```
            - PS 표시는 패스워드가 설정되었다는 의미
            - 좌측부터, '패스워드변경일' '패스워드최소보유일(may)' '패스워드최대보유일(must)' '만기전경고일' '유예기간'
            '(암호화 알고리즘)'
        - **```# passwd -l rdsuser```**: 패스워드 잠금 설정.
        **/etc/shadow** 내 패스워드 필드 맨 앞에 **'!!'** 넣어서 로그인을 막음. **-u** 옵션으로 잠금 해제함
        - **```# passwd -d rdsuser```**: **/etc/shadow** 패스워드 필드를 제거하여 아이디만 입력시 로그인 가능
        - **```# passwd -n 3 -x 200 -w 5 -i 10 rdsuser```**: 패스워드 변경 후 적어도 3일간 사용해야 함, 최대 사용일은 200일,
        만료전 경고는 5일전부터 나타나고, 만료후 유예기간은 10일
        - **```# passwd -e rdsuser```**: 다음 로그인시 반드시 비밀번호 변경해야 함

- **chage**
    - 패스워드 정보를 출력하거나 설정하는 명령. **/etc/shadow** 의 날짜 관련 필드 모두를 설정 가능한 것이 특징
    - **```# chage [option] [계정명]```**
    - 주요 옵션
        - **-l**: 패스워드 정보 출력 (--list)
        - **-d**: **/etc/shadow** 의 3번째 필드인 **최근 패스워드 변경일(1970년 1월 1일부터 계산한 날짜 수)** 설정
        - **-m**: 패스워드 설정 및 변경 후 최소 사용해야 하는 날짜수 설정.
        - **-M**: 현재 패스워드 유효기간 설정. 패스워드 최대 사용 날짜수 설정. (만기일)
        - **-W**: 패스워드 만료 전 경고 출력일자 설정.
        - **-I**: 패스워드 만료후 유예기간
        - **-E**: 계정 만기일 설정. (MM/DD/YY or YYYY-MM-DD 포맷)
    - ex.
        - **```# chage -l rdsuser```**: 패스워드 정보 출력
        - **```# chage -m 10 -M 100 -W 5 -I 3 rdsuser```**: 패스워드 변경 후 최소 10일간 사용해야 함, 최대 사용일은 100일,
        만료전 경고는 5일전부터 나타나고, 만료후 유예기간은 3일
        - **```# chage -E 2022-03-31 rdsuser```**: 계정 만기일 설정
        - **```# chage -d 15917 rdsuser```**: 패스워드 변경일 설정

> **패스워드 관리 툴 비교**
>
> | | last | may | must | warn | expire | disable |
> | chage | -d | -m | -M | -W | -I | -E |
> | passwd | | -n | -x | -w | -i | |
> | usermod | | | | | -f | -e |

**그룹 계정 관리**에 대해 살펴보겠습니다.

서버 운영체제인 리눅스 시스템에는 다수의 사용자가 접속할 수 있는데, 특정 그룹의 사용자 간 파일 공유가 필요한 상황이 있을 수 있습니다.
이를 위해 **그룹(Group)** 으로 사용자들을 묶어 특정 파일 및 디렉토리에 대한 **허가권(Permission)** 설정을 할 수 있습니다.
리눅스에서 모든 사용자는 하나 이상의 그룹에 속하도록 되어 있습니다.

레드햇 계열 리눅스에서는 사용자간의 불필요한 공유를 막기 위해 사용자의 아이디와 동일한 그룹을 생성해서 단독으로 그룹에 포함되도록 설정되어
있으며, 그룹 변경을 위해서는 **usermod** 명령을 활용해야 합니다.

- **/etc/group**
    - 리눅스에 등록되어 있는 그룹의 목록
    - **```[GroupName]:[Password]:[GID]:[Member List]```** 4개 필드로 구성됨
    - 항목 설명
        - **GroupName**: 그룹명. 보통 **groupadd** 로 생성
        - **Password**: 그룹 패스워드는 **/etc/gshadow** 에 별도 저장됨. 따라서 'x' 로 표시
        - **GID**: 그룹 아이디 숫자값
        - **Member List**: 그룹에 속한 사용자 목록. 이 필드에는 **주그룹(Primary Group)**이 아닌 **2차 그룹(Secondary Group)**
        멤버들이 기록됨

- **/etc/gshadow**
    - 그룹의 암호가 관리되는 파일. root 사용자만 확인 가능
    - **```[GroupName]:[Password]:[Admin]:[Member List]```** 4개 필드로 구성됨
    - 항목 설명
        - **GroupName**: 그룹명
        - **Password**: 그룹 패스워드. '!' 표시는 패스워드가 설정되지 않았음을 의미하고, **gpasswd** 명령으로 설정하면 SHA-512
        알고리즘으로 암호화되어 기록됨($6 으로 시작되는 형태). 패스워드가 설정되었다면, 다른 그룹의 사용자가 **newgrp** 명령을 통해
        해당 그룹에 속할 수 있음
        - **Admin**: 그룹 관리자. 그룹 관리자는 멤버 리스트에 포함되지 않아도 됨 (그룹 자체이므로, Primary)
        - **Member List**: 그룹에 속한 사용자 목록. 여기에 속한 사용자는 **newgrp** 사용시 패스워드 입력 없이 주그룹으로 전환 가능

> **관련 명령어**
> - **grpconv**, **grpunconv**: 후자의 명령을 사용하면 패스워드를 **/etc/group** 에서 관리하게 됨. 전자를 사용하면 다시
> **/etc/gshadow** 에서 관리함
> - **grpck**: **/etc/group** 및 **/etc/gshadow** 파일을 점검. 하는 일은 필드 개수 검사, 그룹 중복유무 검사, 유효한 그룹여부 검사,
> 유효한 GID여부 검사, 그룹 멤버와 관리자 검사 등

- **groupadd**
    - 새로운 그룹을 생성하는 명령. root 만 사용 가능
    - **```# groupadd [option] [그룹명]```**
    - 주요 옵션
        - **-g**: 그룹 생성과 동시에 GID 부여. 레드햇 기준으로는 시스템 예약 아이디를 제외하고 500번 이상으로 지정해야 함.
        다른 계열에서는 1000부터 지정
        - **-r**: 생성하는 그룹을 시스템 레벨로 사용. 0 ~ 499 번호가 지정됨
    - ex.
        - **```# groupadd -g 1001 terran```**: 테란 그룹을 1001 GID 로 생성

- **groupmod**
    - 그룹명이나 GID 변경
    - **```# groupmod [option] [그룹명]```**
    - 주요 옵션
        - **-n**: 그룹명 변경 (--new-name)
        - **-g**: GID 변경 (--gid)
    - ex.
        - **```# groupmod -n ihd rds```**
        - **```# groupmod -g 555 rds```**

- **groupdel**
    - 그룹 삭제 명령. 속한 사용자가 없어야 실행 가능. 2차 그룹 사용자는 존재해도 무관
    - **```# groupdel [그룹명]```**

- **gpasswd**
    - 그룹의 패스워드를 설정하거나 그룹관리자를 지정하는 명령
    - 해당 그룹에 속하지 않아도 그룹관리자 지정 가능
    - 그룹관리자는 다른 사용자를 그룹에 2차 그룹으로 속하게 하거나 그룹 패스워드를 설정 가능
    (그룹 패스워드 설정시 **newgrp** 활용해 패스워드 입력하여 일시적으로 1차 그룹 변경 가능)
    - **```#gpasswd [option] [그룹명]```**
    - 주요 옵션
        - **-A**: root 가 그룹 관리자를 지정
        - **-a**: 그룹 관리자가 그룹에 사용자를 추가
        - **-d**: 그룹 관리자가 그룹에서 사용자를 제외
        - **-r**: 그룹 패스워드 제거. 패스워드가 없다면 그룹에 속하지 않은 사용자는 **newgrp** 로 임시 1차그룹변경 불가능
        - **-R**: 그룹 패스워드 비활성화(disable). 오직 해당 그룹의 사용자만 **newgrp** 사용 가능
        - **-M**: root 가 그룹 멤버를 지정
    - ex.
        - **```# gpasswd -A rdsuser terran```**: 테란 그룹의 관리자로 rdsuser 를 지정
        - **```$ gpasswd terran```**: 테란 그룹의 관리자가 테란 그룹의 패스워드 지정
        - **```$ gpasswd -a rdsuser terran```**: 테란 그룹에 rdsuser 를 포함시킴
        - **```# gpasswd -d rdsuser terran```**: 테란 그룹에서 rdsuser 사용제 제외
        - **```# gpasswd -M rdsuser terran```**: 테란 그룹에 rdsuser 를 멤버로 포함시킴
        - **```# gpasswd -r terran```**: 그룹 패스워드 제거. 패스워드가 없으므로 테란에 속하지 않은 사용자는 **newgrp** 커맨드로
        테란 그룹 임시변경 불가
        - **```# gpasswd -R terran```**: 그룹 패스워드를 비활성화시켜 **-r** 옵션과 동일한 효과를 냄

- **newgrp**
    - 사용자가 일시적으로 자신의 1차 그룹을 변경할 때 사용하는 명령
    - 해당 그룹에 속하면 패스워드 입력이 불필요하고, 아니라면 입력해야 함. 이 때는 패스워드가 사전에 설정되어 있거나 활성화되어 있어야 함
    (원래 그룹으로 돌아가려면 **exit** 입력)
    - **```# newgrp [그룹명]```**

**사용자 계정 관리와 연관된 추가적인 명령어**들을 살펴보겠습니다.

- **users**
    - 시스템에 로그인되어 있는 사용자의 아이디를 출력
    - **```$ users```**: 아이디만 나열됨

- **who**
    - 시스템에 로그인되어 있는 사용자 정보를 출력. **users** 보다 자세한 정보
    - **```$ who [option]```**
    - 주요 옵션
        - **-b**: 시스템의 부팅 시간 출력 (--boot)
        - **-d**: 죽은 프로세스 출력 (--dead)
        - **-H**: 출력되는 정보의 헤더를 출력 (--heading)
        - **-l**: 시스템 로그인 프로세스를 출력 (--login)
        - **-p**: init 프로세스에 의해 발생되어 활성화된 프로세스를 출력 (--process)
        - **-r**: 현재의 런레벨 출력 (--runlevel)
        - **-t**: 마지막으로 시스템 시간이 변경된 정보 출력 (--time)
        - **-T**: 사용자의 메시지 상태 출력 (-w, --mesg)
        - **-u**: 시스템에 로그인한 사용자 목록 출력
        - **-m**: 표준 입력과 연관된 호스트명과 사용자명을 출력. **```$ who am i```** 와 동일
        - **-a**: -b, -d, -l, -p, -r, -t, -T, -u 통합
    - ex.
        - **```# who```**: 시스템에 로그인되어 있는 사용자의 아이디, 접속한 터미널, 로그인한 날짜 및 시간, 로그인 위치 출력
        ```
        rdsuser     tty2        Aug 19 15:07
        jalin       tty3        Aug 19 15:07
        root        tty1        Aug 19 15:00 (:0)
        root        pts/0       Aug 19 15:05 (:0.0)
        ```
        - **```$ who -m```**: 현재 사용중인 표준입력과 연관된 호스트명와 사용자명을 출력 (**```$ who am i```**와 동일)

- **whoami**
    - 실질적으로 사용중인 권한자를 출력
    - **```$ whoami```**

- **w**
    - 시스템에 로그인되어 있는 사용자와 사용자가 수행중인 작업을 출력
    - **```$ w [option] [사용자명]```**
    - 주요 옵션
        - **-h**: 윗부분 설명인 헤더(header)를 출력하지 않음
        - **-s**: LOGIN@, JCPU, PCPU 를 제외하고 간략히 출력
    - 주요 출력내용
        - **USER**: 시스템에 로그인한 사용자의 아이디
        - **TTY**: 터미널 타입(Terminal type). 로컬 시스템의 콘솔은 **ttyn** 형식으로 표기, 외부에서 telnet 등으로 접속하거나
        X-Window 터미널은 **pts/n** 형식으로 표기
        - **FROM**: 접속한 위치 표현. 로컬 시스템의 콘솔로 접속한 경우는 **하이픈(-)**, X-Window 는 **:0**,
        X-Window 터미널은 **:0.0**, 외부에서 접속한 경우에는 **원격 호스트의 도메인명이나 IP** 가 표시됨
        - **LOGIN@**: 시스템에 로그인한 시간 (ex. 15:07)
        - **IDLE**: 최종명령 수행 후 대기시간 (ex. 8:04)
        - **JCPU**: JOB CPU 시간. 시스템에 로그인한 후 CPU 사용시간
        - **PCPU**: Process CPU 시간. WHAT 컬럼에 표시된 작업에 의해 사용된 프로세스 시간
        - **WHAT**: 현재 사용중인 셸이나 작업 등 표시
    - ex.
        - **```$ w```**
            - 출력에서 첫번째 줄은 현재시간, 서버가동 후 활성화된 시간, 현재 로그인한 총 사용자수, 최근 1분, 5분, 15분간의 시스템 부하
            - 헤더 다음줄부터는 위 설명된 항목내용들 출력
        - **```$ w -h rdsuser```**: rdsuser 사용자의 작업 정보를 헤더 없이 출력

- **logname**
    - 접속한 사용자의 로그인 계정을 출력
    - 만약 su 명령으로 다른 사용자로 전환했을 경우, 최초에 로그인했던 계정을 출력함
    - **```$ logname```**

- **id**
    - 시스템에 등록된 현재 사용자 혹은 지정한 사용자 아이디에 대한 정보 출력
    - UID, GID, 사용자가 속한 그룹정보 출력
    - SELinux 리눅스 배포판에서는 context 항목이 추가로 나타남
    - **```$ id [option] [사용자명]```**
    - 주요 옵션
        - **-g**: 주그룹(Primary Group or Effective Group)의 GID 만 출력
        - **-G**: 사용자가 속한 모든 그룹의 GID 출력
        - **-u**: 사용자의 UID 값 출력
        - **-n**: -u 나 -g 옵션과 같이 사용되며, 숫자값인 UID 나 GID 대신 이름으로 출력
    - ex.
        - **```$ id```**: 사용자의 UID, GID, 그룹 정보 출력 (+context)
        ```
        uid=500(rdsuser) gid=500(rdsuser) groups=500(rdsuser) context=unconfined_u:unconfined_r:unconfin
        ed_t:s0-s0:c0.c1023
        ```
        - **```$ id -Gn rdsuser```**: rdsuser 가 속한 모든 그룹의 이름을 출력

- **groups**
    - 사용자가 속한 그룹명 출력
    - **```$ groups [사용자명]```**

- **lslogins**
    - 시스템 전체 사용자의 정보를 출력.
    - **/etc/passwd**, **/etc/shadow** 뿐 아니라 로그파일(**wtmp**, **btmp**)에서도 관련 정보를 가져와 출력
    - **```$ lslogins [option]```**
    - 주요 옵션
        - **-G**: 각 사용자의 그룹 정보 출력
        - **-L**: 각 사용자의 마지막 로그인 정보 출력 (--last)
        - **-u**: 사용자 계정정보 출력 옵션. 일반적으로 시스템 계정을 제외하고 실제 로그인이 되는 계정 위주로 관련 정보 출력

### 파일 시스템 관리

먼저 **소유권(Ownership)**과 **허가권(Permission)**에 대해서 살펴봅니다.

리눅스는 다중 사용자 시스템이기 때문에 파일과 디렉토리에 대해 소유권 및 권한에 따라 접근 제어를 할 필요가 있습니다.
**허가권은 소유권을 가진 사용자가 설정**하고, **소유권은 사용자 소유권과 그룹 소유권**이 있습니다.
허가권은 **읽기(4, r)**, **쓰기(w, 2)**, **실행(x, 1)**의 권한이 있으며,
**사용자(User)**, **그룹(Group)**, **다른 사용자(Other)**로 나누어 각각설정이 가능합니다.
**허가권 10자리에서 맨 앞자리는 파일 혹은 디렉토리의 타입**을 나타냅니다.

> **'ls -l' 을 이용한 파일타입 확인**
> - **-**: 일반 타입
> - **d**: 디렉토리
> - **l**: 링크 파일
> - **b**: 블록 디바이스(디스크 드라이버)
> - **c**: 캐릭터 디바이스(입출력 관련 특수파일)
> - **p**: named pipe(FIFO)
> - **s**: 소켓

> **권한 설명**
> - **r**: 파일 혹은 디렉토리의 내용을 볼 수 있는 권한
> - **w**: 파일 수정 혹은 디렉토리 내 파일 생성 및 삭제할 수 있는 권한
> - **x**: 실행 파일을 실행 혹은 디렉토리 내부로 접근할 수 있는 권한

**특수 권한**에 대해서 살펴봅니다.

- **특수 권한**
    - 앞서 살펴본 3계층 3권한으로는 한계가 존재
    - 특정 상황에서 일부 권한을 임시적으로 부여하는 것을 특수 권한이라 함
    - **Set-UID**: 보통 실행 파일에 적용되어 해당 파일을 실행하는 동안에는 실행시킨 사용자의 권한이 아니라
    파일 소유자의 권한으로 인식하게 됨. **소유자(User) 권한의 x 자리에 s 로 표기**됨
    (ex. **passwd** 명령 사용시 **/etc/shadow** root 권한파일을 root 권한으로 임시 실행)
    - **Set-GID**: Set-UID 와 유사하게 파일 실행시 그것을 소유한 그룹 권한으로 인식하게 됨. 보통 디렉토리에 설정되어 그곳에 파일 혹은
    디렉토리를 생성하면 생성한 사용자의 그룹이 아닌 디렉토리의 그룹으로 소유권이 지정됨. **소유그룹(Group) 권한의 x 자리에 s 로 표기되며
    실행 권한이 없다면 S 로 표기**됨
    - **Sticky-Bit**: 디렉토리에 설정되어 일종의 **공유 디렉토리**로 사용됨. 공유 디렉토리에서 어떤 파일의 다른 사용자(Other) 영역으로
    rwx 가 모두 설정된 경우 **파일을 생성한 사용자가 아님에도 파일을 삭제할 수** 있는데, 이때 **Sticky-Bit** 를 설정하면 본인 파일 외에
    삭제가 불가능하게 됨. **다른 사용자(Other) 계층의 x 자리에 t 로 표기되며, 실행 권한이 없는 경우 T 로 표기**됨
    (ex. **/tmp** 임시저장용 공유 디렉토리에서 특정 응용 프로그램이 임시 생성한 파일을 다른 응용 프로그램이 삭제할 수 없음)

이러한 특수 권한은 **보안상의 위험을 초래할 수 있으므로 정확한 이해와 제한된 적용**이 필요합니다.

- **특수 권한의 설정**
    - 특수 권한들은 다음으로 살펴볼 **chmod** 명령으로 지정함 (허가권 지정 명령어)
    - 문자 모드에서 **Set-UID** 및 **Set-GID**는 **s**, **Sticky-Bit**는 **t** 사용
    - 숫자 모드에서는 **천의 자리**가 사용되며 각각 **4, 2, 1**의 값을 가짐

관련 명령어들을 살펴보겠습니다.

- **chmod(Change Mode)**
    - 파일이나 디렉토리에 허가권(Permission)을 설정하는 명령
    - 알파벳을 사용하는 **문자 모드(Symbolic mode)** 혹은 8진수 값을 사용하는 **숫자 모드(Numeric mode)**로 지정
    - **문자 모드**: 권한의 표시는 **r, w, x**, 사용자의 지정은 **u, g, o, a**, 설정 기호는 **+, -, =**
    - **숫자 모드**: **4(r, 읽기), 2(w, 쓰기), 1(x, 실행), 0(-, 권한없음)**의 숫자를 조합하여 8진수의 값을 만들어 설정.
    나열되는 숫자의 자리수는 **u(100의자리), g(10의자리), o(1의자리)**에 해당하는 세자리 (ex. 755)
    - **```$ chmode [option] [mode] [file(s)]```**
    - 주요 옵션
        - **-R, --recursive**: 하위 디렉토리를 포함하여 내부의 모든 파일의 접근 권한 변경
        - **-c, --changes**: 변경된 정보 출력
        - **-f, --silent, --quite**: 중요한 오류 메시지가 아니면 출력하지 않음
        - **--version**: 명령어의 버전 정보 출력
    - ex.
        - **```$ chmod ugo+rwx aa.txt```**: same as 'chmod a+rwx aa.txt', 'chmod 777 aa.txt'
        - **```$ chmod 755 aa.txt```**: 소유자는 rwx, 나머지는 각각 rx
        - **```$ chmod o-r,o-w *```**: same as 'chmod o-rw *', 다른 사용자에게 읽기 및 쓰기권한 제거
        - **```$ chmod a+r *.txt```**
        - **```$ chmod o=r /etc/fstab```**: 파일에 다른 사용자가 읽기만 가능하도록 설정. 다른 사용자에 대한 기존 권한은 초기화
        - **```$ chmod -R go-rwx *```**
        - **```$ chmod a= a.txt```**: 모든 사용자에게 어떠한 권한도 설정하지 않음. same as 'chmod 0 a.txt'
        - **```$ chmod 66 a.txt```**: same as 'chmod 066 a.txt'
        - **```$ chmod u+s a.out```**: Set-UID 설정. x 동작에서 임시적으로 파일 소유자의 권한으로 실행
        - **```$ chmod g+s a.out```**: Set-GID 설정. x 동장에서 임시적으로 파일 소유그룹의 권한으로 실행
        - **```$ chmod o+t data/```**: 현재 디렉토리 밑의 data 디렉토리에 Sticky-Bit 설정. 공유 디렉토리지만 파일 소유자가 아니면
        파일 삭제 불가
        - **```$ chmod g+s,o+t /project```**: /project 디렉토리에 Set-GID 설정하여 파일 생성 시 자동으로 그룹 소유권으로 지정하고,
        Sticky-Bit 지정하여 그룹 사용자 간 공유모드 디렉토리로 사용
        - **```$ chmod 3070 /project```**: /project 디렉토리에 070 권한으로 그룹 소유자만 접근 및 수정 가능하도록 하고, 천의자리
        3(2+1)으로 Set-GID 와 Sticky-Bit 설정

- **chown(Change Owner)**
    - 파일이나 디렉토리의 소유권 및 그룹 소유권을 변경하는 명령
    - **```# chown [option] [owner][:group] [file(s)]```**
    - 주요 옵션
        - **-R, --recursive**: 하위 디렉토리를 포함하여 디렉토리 내부의 모든 파일의 접근 권한을 변경
        - **-c, --changes**: 변경된 정보 출력
        - **-f, --silent, --quite**: 중요한 오류 메시지가 아니면 출력하지 않음
        - **--version**: 명령어의 버전정보 출력
    - ex.
        - **```# chown -R rdsuser *```**: 하위 디렉토리 포함 현재 디렉토리의 모든 파일의 소유자를 변경
        - **```# chown rdsuser:ihduser a.txt```**: same as 'chown rdsuser.ihduser a.txt'
        - **```# chown 500 a.txt```**: UID 가 500인 사용자로 파일 소유자 변경
        - **```# chown :rdsuser a.txt```**: 파일의 그룹 소유권 변경


- **chgrp(Change Group)**
    - 파일이나 디렉토리의 소유 그룹을 변경하는 명령. 보통 root 유저가 사용
    - 만약 특정 사용자가 여러 그룹에 속해 있다면 그 범주 내에서 파일의 소유 그룹을 변경할 수 있음
    - **```# chgrp [option] [file(s)]```**
    - 주요 옵션
        - **-R, --recursive**: 하위 디렉토리를 포함하여 디렉토리 내부의 모든 파일의 접근 권한을 변경
        - **-c, --changes**: 변경된 정보 출력
        - **-f, --silent, --quite**: 중요한 오류 메시지가 아니면 출력하지 않음
        - **-h, --no-dereference**: Symbolic Link 파일의 그룹 소유권 변경. 이 옵션 없이 사용하면 원본 파일의 그룹 소유권이
        변경되지만, 이 옵션을 사용하면 심볼릭 링크파일 자체의 그룹 소유권이 변경됨
        - **--version**: 명령어의 버전정보 출력
    - **```# chgrp -R ihd ~rdsuser```**: rdsuser 사용자의 홈 디렉토리를 포함한 모든 파일이나 디렉토리의 소유그룹을 ihd 로 변경

- **umask**
    - 파일이나 디렉토리 생성시 부여되는 기본 허가권 값을 설정하는 명령
    - 파일은 666, 디렉토리는 777에서 설정된 umask 값을 뺀 값으로 기본 허가권을 부여함
    - **```$ umask [option] [값]```**
    - 주요 옵션
        - **-S**: umask 값을 문자로 표기
    - ex.
        - umask 값이 0002 인 경우 파일은 664, 디렉토리는 775 로 생성됨
        - **```$ umask 022```**
        - **```$ umask u=rwx,g=rw,o=rw```**: 파일은 655, 디렉토리는 766 으로 생성됨. same as 'umask 011'

다음으로 **파일 링크**에 대해 살펴봅니다.

- **파일 링크(Link)**
    - 파일이나 디렉토리에는 I-node(Index node) 번호가 부여되고, 파일명이 달라도 이 번호가 같으면 같은 하드링크 파일로 취급됨
    - 파일을 여러 개의 이름으로 관리하거나, 디렉토리 접근 경로를 단축하는 용도로 사용됨

- **ln**
    - Hard Link 또는 Symbolic Link 를 생성하는 명령. 기본적으로 하드링크가 생성됨
    - **```$ ln [option] [원본파일] [대상파일명]```**
    - 주요 옵션
        - **-s**: 심볼릭 링크 생성옵션 (--symbolic)
        - **-v**: 링크 생성정보를 자세하게 출력 (--verbose)
        - **-f**: 링크파일 존재시, 그것을 삭제하고 생성 (--force)
    - ex.
        - **```$ ln joon.txt j```**: 하드링크 생성 (동일 파일을 여러 이름으로 관리)
        - **```$ ln -s joon.txt j```**: 심볼릭 링크 생성. 소프트 링크라고도 함
        - **```$ ln -s /etc/xinetd.d x```**: 프로세스 효율적 관리를 위해 사용되는 xinetd 파일에 대한 심볼릭 링크를
        현재 디렉토리에 생성

> **하드 링크란?**
> - 동일한 I-node 파일을 다른 이름으로 여러개 생성하여 관리. 파일에만 사용 가능
> - Stick-Bit 가 설정되지 않은 공유 디렉토리에 있는 파일의 하드링크를 사용자 디렉토리 내에 생성하여,
> 다른 사용자에 의해 공유 디렉토리 내 파일이 삭제되어도 복제본을 보존할 수 있도록 하기 위해 사용됨
> - 특징
>     - **I-node 번호가 동일**
>     - **원본과 링크파일의 내용과 크기가 동일함**
>     - **하드링크 생성 시 'ls -l' 명령 결과 파일의 링크 카운트가 올라가는 것을 볼 수 있음**
>     - **어느 파일의 내용을 수정해도 동일하게 반영됨**
>     - **원본이 삭제되어도 링크파일은 영향을 받지 않음**
>     - **하드링크는 파일에만 설정 가능하며, 동일한 파일시스템에서만 사용 가능**
>     - **파티션이나 디스크 드라이브를 가로질러 사용할 수 없음**

> **심볼릭 링크란?**
> - 하나의 파일을 여러 이름으로 가리키게 하는 링크로 원본과 링크는 서로 다른 파일로 취급됨
> - 일반적으로 디렉토리 경로 단축을 위해 사용됨 (=바로가기)
> - 특징
>     - **I-node 변호가 다름**
>     - **원본을 가리키기만 하므로 링크파일의 크기가 매우 작음**
>     - **'ls -l' 결과 파일정보의 맨 앞의 타입을 나타내는 부분에 'l' 표시**
>     - **원본이나 링크 중 어느 파일을 수정해도 같이 반영됨**
>     - **원본이 삭제되면 링크는 아무 구실을 못함**
>     - **윈도우의 바로가기나 단축 아이콘과 같은기능**
>     - **777 허가권으로 생성되나, 원본의 허가권과는 무관함**

다음으로 **파일 시스템 관리 및 복구**방법에 대해 살펴보겠습니다.

- **파일 시스템 생성**
    - 하드디스크를 새로 추가하거나 기존 디스크에 공간이 남을 경우 해당 공간을 파일시스템 생성을 통해 사용할 수 있음
    - 절차
        1. **하드디스크 인식여부 확인**: 보통 자동인식되므로 장치 파일명만 확인하면 됨. **```$ fdisk -l```** 커맨드로 확인
        2. **파티션 분할 및 생성**: **fdisk** 명령을 이용해 원하는 디스크 파티션 분할
        3. **파일 시스템 생성**: 일반적으로 **포맷(Format)**이라 부르는 단계로, 원하는 리눅스 파일 시스템을 선택한 후에 관련 명령어인
        **mkfs** 등을 사용하여 생성
        4. **사용하려는 디렉토리 생성**: 마운트할 디렉토리 마련. 새로 생성한다면 **mkdir** 명령 사용
        5. **마운트**: **mount** 명령으로 파일 시스템이 생성된 파티션을 디렉토리에 연결
        6. **관련 파일 등록**: 마운트된 연결을 **umount** 명령으로 해제할 수 있음. 혹은 시스템 종료하면 마운트가 해제됨.
        시스템 재부팅시에도 기존 마운트를 유지하려면 마운트정보를 **/etc/fstab** 설정 파일에 기록해두어야 함

다음은 관련 명령어를 살펴보겠습니다.

- **fdisk**
    - 디스크 파티션을 확인하고 파티션 추가/삭제하는 명령으로 설정 후에는 반드시 시스템 재부팅이 필요
    - **```# fdisk [option] [장치명]```**
    - 주요 옵션
        - **-l**: 현재 디스크의 파티션 테이블 정보 출력
        - **-s [파티션]**: 특정 파티션의 크기를 출력. 단위는 block
        - **-v**: 명령의 버전 출력
    - ex.
        - **```# fdisk -l```**: 장착되어 인식된 디스크들의 파티션 테이블 정보를 출력함
        - **```# fdisk /dev/sdb```**: 지정한 디스크의 파티션 작업 진행
        - **```# fdisk -s /dev/sda9```**: 지정한 디스크의 파티션 크기 출력
    - **```# fdisk /dev/sdb```** 와 같이 파티션 작업을 실행하면 명령행 방식으로 텍스트 기반 특정 명령어를 입력해야 함.
    초기 fdisk 의 명령행 모드에 진입하여 'm' 을 입력하면 사용 가능한 명령의 목록을 출력함. 다음은 주요 명령
        - **p**: 현재 지정한 디스크의 정보 출력
        - **d**: 파티션 삭제
        - **n**: 새 파티션 생성(추가)
        - **t**: 파티션의 속성 변경. 주요 코드로는 82(Swap), 83(Linux), 8e(Linux LVM), fd(Raid) 등이 있음
        - **w**: 변경된 파티션 정보를 저장하고 종료
        - **q**: 변경된 파티션 정보를 저장하지 않고 종료

**fdisk** 명령으로 디스크의 파티션 분할 작업을 진행했다면, 분할된 파티션에 적절한 파일 시스템을 생성해야 합니다.

- **mkfs(Make Filesystem)**
    - 새로운 파일 시스템을 생성하는 명령으로 root 만 사용 가능. 유형 지정이 별도로 없다면 기본적으로 **ext2** 로 생성됨
    - **```# mkfs [-t FS_type] [option] [장치명]```**
    - 주요 옵션
        - **-t FS_type**: 파일 시스템의 유형을 지정. ext2, ext3, ext4, ...
        - **-c**: 배드 블록(bad block)을 체크한 후 파일 시스템을 구축
        - **-v**: 결과를 상세히 출력
    - ex.
        - **```# mkfs -t ext2 /dev/hdb1```**
        - **```# mkfs -t ext4 /dev/sdb1```**

- **mke2fs**
    - ext2, ext3, ext4 파일 시스템을 만드는 명령으로 최근 리눅스 배포판에서 **mkfs** 명령 실행 시 실제 사용됨 (기본 ext2 로 지정)
    - **```# mke2fs [option] [장치명]```**
    - 주요 옵션
        - **-j**: 저널링(Journaling) 파일 시스템인 ext3 로 생성
        - **-t FS_type**: 파일 시스템 유형 지정 옵션
        - **-b block_size**: 블록 사이즈를 지정하는 옵션. 1024, 2048, 4096 으로 지정 가능
        - **-R raid_options**: RAID 관련 옵션으로 -R 다음에 argument=값 형태로 지정
        - **-T usage_type**: I-node 의 크기를 지정하는 옵션으로 RHEL 4 까지는 FS_type 에 news, largefile, largefile4 를
        지정할 수 있음. I-node 의 크기는 news 는 4k, largefile 은 1M, largefile4 는 4M 으로 지정함. RHEL 5 에서는
        **/etc/mke2fs.conf** 에서 크기를 지정할 수 있음
    - ex.
        - **```# mke2fs -j /dev/sdb1```**: 저널링 파일 시스템인 ext3 로 생성
        - **```# mke2fs -t ext4 /dev/sdc1```**
        - **```# mke2fs -j -b 4096 -R stride=32 /dev/md0```**: RAID 장치인 /dev/md0 를 ext3 파일 시스템으로 생성하고,
        블록 사이즈를 4096바이트로 지정. 추가로 stripe 당 블록 사이즈를 32바이트로 지정
        - **```# mke2fs -j -T largefile /dev/hda7```**: I-node 크기를 largefile 1MB 로 지정

> **파일 시스템 생성 명령**
> - 최근 리눅스 배포판에서는 명령어 사용법을 간소화하여 **mkfs.extn** 방식으로 곧바로 사용
> - ex. **```# mkfs.ext4 /dev/sdb1```**

- **mount**
    - 보조 기억장치나 파일 시스템이 다른 하드디스크를 **/ (root directory)** 하위 디렉토리로 연결하여 실제로 사용 가능하도록 하는 명령
    - **```# mount [option] [device] [directory]```**
    - 주요 옵션
        - **-a**: **/etc/fstab** 에 명시된 파일 시스템을 마운트할 때 사용되는 옵션
        - **-t FS_type**: 마운트할 장치의 파일 시스템 유형을 지정
        - **-o [항목]**: 마운트 시 추가적인 설정 적용. 다수의 설정은 콤마(,)로 구분함
    - **-o 의 주요 항목**
        - **ro**: 읽기 전용 마운트
        - **rw**: 읽기/쓰기 모드로 마운트 (기본값)
        - **remount**: 해당 파티션을 다시 마운트. 파티션 정보가 바뀌었을 때 사용
        - **loop**: loop 디바이스로 마운트할 때 사용 (ex. CD-ROM 이미지 파일인 iso 를 마운트할 때 사용)
        - **noatime**: 파일을 읽으면 Access Time 이 변경되는데, 이 옵션을 사용하면 Access Time 이 파일 수정시에 변경됨.
        이러한 옵션을 사용하는 이유는 시스템의 작업을 줄여 성능 향상시키는 데 있음 (노트북에서 디스크 접근에 따른 배터리 시간을 늘려줌)
        - **username=[사용자명]**: Samba 처럼 사용자 계정이 필요한 경우 사용
        - **password=[암호]**: 계정에 패스워드가 적용된 경우 username 과 함꼐 사용
        - **acl**: ext3 파일 시스템에서 지원하는 접근 제어 리스트(Access Control Lists)를 사용 가능하도록 마운트할 때 사용
    - **주요 파일 시스템 유형**
        - **msdos**: MS-DOS 파일 시스템인 FAT-16 마운트 시 지정
        - **vfat**: 마이크로소프트사의 파일 시스템인 FAT-32 마운트 시 지정
        - **ntfs**: 마이크로소프트사의 윈도루 NT, 2000, XP 이후 버전에서 하용하는 파일 시스템 마운트 시 지정
        - **ext2, ext3, ext4**: 리눅스 시스템 마운트 시 지정
        - **iso9660**: CO-ROM 이나 DVD 마운트 시 지정
        - **smbfs**: 네트워크 파일 시스템인 삼바 파일 시스템 마운트 시 지정
        - **cifs**: 삼바 파일 시스템이 확장된 파일 시스템
        - **nfs**: 네트워크 파일 시스템인 NFS 로 공유된 영역 마운트 시 지정
        - **udf**: DVD 파일 시스템으로 대부분의 배포판 리눅스에서 iso9660 으로 지정해도 마운트 가능
    - **주요 디바이스 파일명**
        - **FDD**: **/dev/fd0**, **/dev/fd1** 등
        - **CD-ROM 및 DVD**: **/dev/cdrom**, **/dev/dvd**, **/dev/sr0**, **/dev/hdc**, **/dev/sdb** 등
        - **IDE HDD**: **/dev/hda1**, /dev/hdb1** 등
        - **USB Memory, SCSI HDD, S-ATA HDD**: **/dev/sda**, **/dev/sdb1** 등
    - ex.
        - **```# mount ```**: 현재 마운트된 목록을 보여줌
        - **```# mount -t ext4 -o ro /dev/sdb1 /mnt```**: ext4 파일 시스템인 **/dev/sdb1** 장치를 읽기 전용으로
        **/mnt** 디렉토리에 마운트
        - **```# mount -o remount /home```**: (파티션 설정 변경 후) **/home** 영역을 다시 마운트
        - **```# mount -t iso9660 -o ro,loop /root/CentOS-6.4-i386.bin-DVD1.iso /media```**: **iso CD 이미지 파일**을
        **읽기 전용** 및 **루프백 장치**로 **/media** 디렉토리에 마운트
        - **```# mount -t smbfs -o username=administrator,password='1234' //192.168.4.70/data /net```**: **삼바**로 공유된
        **192.168.4.70 서버**의 **/data** 디렉토리를 **/net** 디렉토리로 마운트
        - **```# mount -o noatime /raiddata```**: **/raiddata** 디렉토리 내 파일의 내용을 보더라도
        **Access Time 을 갱신하지 않도록** 함
        - **```# mount LABEL=/home```**: **LABEL** 이 **/home** 으로 설정된 파티션을 마운트. 관련 라벨 정보는 **/etc/fstab** 에
        등록되어 있어야 함

- **umount**
    - 언마운트(unmount) 의 약자로 마운트된 파일 시스템을 해제시키는 명령
    - Floppy, USB Memory 등 보조 기억장치 사용 후 반드시 언마운트 이후 장치를 제거해야 데이터 손실이 없음
    - 특히 CD-ROM 이나 DVD 마운트 해제 없이는 드라이브 안에 있는 디스크를 꺼낼 수 없음
    - **```# umount [option] [장치명]```**
    - **```# umount [option] [마운트된_디렉토리명]```**
    - 주요 옵션
        - **-a**: **/etc/fstab** 에 명시된 파일 시스템을 언마운트할 때 사용
        - **-t FS_type**: 언마운트 할 파일 시스템을 지정할 때 사용
    - ex.
        - **```# umount /media```**: 마운트된 디렉토리 언마운트
        - **```# umount /dev/sdb1```**: 마운트된 장치 언마운트
        - **```# umount -a -t iso9660```**: 파일 시스템이 iso9660 으로 마운트된 모든 장치들을 언마운트

- **eject**
    - CD-ROM, DVD 등과 같이 이동식 보조 기억장치의 미디어 꺼낼 때 사용
    - 이 명령을 사용하면 자동으로 언마운트(unmount) 작업을 수행함
    - **```# eject [장치명 or 마운트된_디렉토리명]```**
    - ex.
        - **```# eject```**: 기본 DVD 또는 CD-ROM 장치를 언마운트한 후에 디스크 트레이(Tray) 오픈
        - **```# eject /dev/cdrom```**
        - **```# eject /media```**

다음으로 **파일 시스템 관련 파일**을 살펴보겠습니다.

- **/etc/fstab**
    - 파일 시스템 관련 다양한 정보를 담고 있는 파일
    - 부팅 시 마운트할 파티션 정보가 기록되어 있음
    - 따라서 **파티션 정보 변경 혹은 디스크 추가시 이를 재부팅시에도 유지하려면 이 파일에 관련 정보를 등록해야만** 함
    - **mount**, **umount**, **fsck** 등의 명령어가 수행될 때 이 파일의 정보를 참조함
    - 필드 구성 (파일 내 한 행이 하나의 파일 시스템 설정)
        - **첫 번째 영역**: 장치명이 기록되는 영역이었으나, 최근 배포판 리눅스에서는 **볼륨 라벨(Volumn Label)** 이나
        **UUID** 정보가 대신 기록됨 (ex. /dev/sdb1, LABEL=/, UUID=fa853197-a7...8caa 등)
        - **두 번째 영역**: 마운트될 디렉토리(**Mount Point**) 기록 (ex. /, /home 등)
        - **세 번째 영역**: **파일 시스템 유형** 기록 (ex. /ext4m swap, nfs 등)
        - **네 번째 영역**: **마운트 옵션** 기록 (ex. defaults, usrquota, grpquota, acl 등)
        - **다섯 번째 영역**: **dump** 명령을 통한 백업 시 레벨 덤프 사용 주기를 결정하는 부분. 값이 0이면 dump 를 사용하지 않고
        1이면 매일 수행, 2면 이틀에 한번 수행
        - **여섯 번째 영역**: 부팅 시 파일 시스템 점검 순서 지정. 점검은 **fsck** 명령으로 수행됨. 보통 루트 파일 시스템이 1이고
        다른 파일 시스템은 2로 설정하여 순서대로 점검함. 0은 파일 시스템 점검하지 않음
    - **네 번째 영역의 주요 옵션**
        - **defaults**: rw, suid, dev, exec, auto, nouser, async 가 적용됨
        - **auto**: 시스템 부팅시 장치가 존재하면 자동으로 마운트하고, **-a** 옵션을 이용한 마운트 및 활성화 등을 가능하게 함
        - **noauto**: 시스템 부팅시 자동으로 마운트되지 않도록 하는 옵션. 명시적으로만 마운트 가능. **-a** 이용한 마운트 불가
        - **user**: 로컬 시스템에서 일반 사용자가 마운트할 수 있는 권한을 부여
        - **usrquota**: 사용자의 용량을 제한하는 Disk Quota 사용시 해당 영역에 설정
        - **grpquota**: Disk Quota 를 그룹별로 사용시 해당 영역에 설정
        - **noquota**: 해당 파티션에서 사용자들의 쿼터 설정하지 않음
        - **nosuid**: 해당 파티션에서 SUID 나 SGID 설정을 허용하지 않음
        - **nodev**: 해당 파티션에서 문자나 특별한 장치(디바이스)를 허용하지 않음
        - **noexec**: 해당 파티션에서 실행 파일이 실행되지 않도록 설정
        - **suid**: 해당파티션에서 SUID 나 SGID 사용을 허용
        - **ro**: 해당 파티션을 읽기 전용으로 설정
        - **rw**: 해당 파티션을 읽고 쓰기 모드로 설정
        - **async**: 파일을 비동기적으로 관리하도록 설정
        - **acl**: Access Control List 사용

- **/etc/mtab**
    - 현재 시스템에 마운트되어 있는 파일 시스템 정보를 담은 파일

> **UUID(Universally Unique Identifier)**
> - 범용 고유 식별자로써 여러 개체들이 존재하는 환경에서 식별하기 위해서 사용되는 고유한 이름을 통칭
> - 최근 리눅스에서는 새 파티션을 생성하면 고유한 UUID 를 부여하고, 이 정보는 **blkid** 커맨드로 확인함
> ```shell script
> [rdsuser@www ~]$ blkid
> /dev/sda1: UUID="71c8104b-3f5d...f18e" TYPE="ext4"
> /dev/sda2: UUID="4073e4da-5444...ced0" TYPE="swap"
> 
> [rdsuser@www ~]$
> ```

> **[퀵스타트] 새 디스크 추가 후 /data 사용하기**
> 1. **```# fdisk -l```**: 장치 확인
> 2. **```# fdisk /dev/sdb```**: 파티션 분할 및 생성
>     - **n**(new partition)
>     - **p**(primary)
>     - **1**(partition number)
>     - **[엔터치면 전체할당, 혹은 할당량 지정]**
>     - **w**(저장 후 종료) or **q**(저장하지 않고 종료)
> 3. **```# mkfs.ext4 /dev/sdb1```**: 파일 시스템 생성
> 4. **```# mount -t ext4 /dev/sdb1 /data```**: 디렉토리에 마운트
> 5. **/etc/fstab** 에 등록
>     - **```/dev/sdb1   /data   ext4    defaults    0 0```**

다음으로 **파일 시스템 점검** 관련 명령어를 살펴봅니다.

- **fsck(Filesystem Check)**
    - 파일 시스템을 검사하고 수리하는 명령
    - 손상된 디렉토리나 파일을 수정할 때 임시로 **/lost+found** 디렉토리에서 작업을 수행하고 정상 복구되면 사라짐
    - 따라서 이 디렉토리에 파일이 많다면 깨진 파일이 많다는 의미
    - **```# fsck [option] [장치명]```**
    - 주요 옵션
        - **-a**: 확인질문 없이 무조건 수행
        - **-r**: 확인질문을 함. 여러개의 **fsck** 가 병렬 모드 형태로 작동하고 있을 때 유용
        - **-A**: **/etc/fstab** 에 정의되어 있는 모든 파일 시스템을 체크
        - **-P**: **-A** 옵션을 사용할 때 루트 파일 시스템을 다른 파일 시스템과 병렬로 함께 체크
        - **-R**: **-A** 옵션을 사용할 때 루트 파일 시스템은 체크하지 않고 건너뜀
        - **-N**: 실행을 하지 않고 단지 어떤 것이 실행되어지는지만 보여줌
        - **-T**: 검사를 시작할 때 제목을 보여주지 않음
        - **-s**: **fsck** 동작을 시리얼화함. 대화형 모드에서 여러 파일 시스템을 점검할 때 유용
        - **-V**: 실행되는 각 파일 시스템용 명령을 포함해 자세한 출력을 수행함
        - **-v**: 버전 정보를 보여줌
        - **-t FS_type**: 점검할 파일 시스템의 유형을 지정. 파일 시스템 앞에 no 를 붙이면 지정한 파일 시스템을 제외한 나머지를
        검사하고, **-A** 옵션이 설정되어 있는 경우 **/etc/fstab** 에서 파일 시스템 유형이 맞는 것만 검사함
    - ex.
        - **```# fsck /dev/sdb3```**

- **e2fsck**
    - 리눅스 파일 시스템인 ext2, ext3, ext4 를 검사하고 수리하는 명령
    - 현재 리눅스 배포판에서 **fsck** 명령 실행 시 실제 사용되는 명령
    - **```# e2fsck [option] [장치명]```**
    - 주요 옵션
        - **-n**: 특정 상황에 대한 물음에 no 로 인식하여 처리
        - **-y**: 특정 상황에 대한 물음에 yes 로 인식하여 처리
        - **-c**: 배드 블록(Bad Block) 체크
        - **-f**: 깨끗한 파일 시스템까지 강제적으로 체크
    - ex.
        - **```# e2fsck -y /dev/sda3```**: 파일 시스템 점검시 모두 yes 처리

- **df(Disk Free)**
    - 현재 마운트된 디스크의 크기, 사용량, 남아있는 용량 등에 대한 정보를 출력
    - **```$ df [option]```**
    - 주요 옵션
        - **-h**: 용량의 단위 표시(KB, MB, GB) (--human-readable)
        - **-k**: 킬로바이트(Kilobyte) 단위로 출력 (기본값)
        - **-m**: 메가바이트(Megabyte) 단위로 출력
        - **-T**: 각 파티션에 대한 파일 시스템 유형을 보여줌
        - **-i**: I-node 의 사용량을 보여줌. 'No space left on device' 출력시 아이노드를 다 써버린 것
    - ex.
        - **```$ df -hT```**: 장치 파티션에 마운트된 파일 시스템의 디스크 사용량 관련 정보 출력. 여기에 사용량 단위와 함께 파일 시스템
        유형도 출력
        - **```$ df -i```**: 마운트된 파일 시스템의 I-node 사용량 관련 정보 출력

- **du(Disk Usage)**
    - 마운트된 파일 시스템의 I-node 사용량 관련 정보 출력
    - **```$ du [option] [File(s) or Directory(ies)]```**
    - 주요 옵션
        - **-h**: 용량의 단위 표시(KB, MB, GB) (--human-readaable)
        - **-b**: 바이트(Byte) 단위로 출력
        - **-k**: 킬로바이트(Kilobyte) 단위로 출력 (기본값)
        - **-m**: 메가바이트(Megabyte) 단위로 출력
        - **-a**: 디렉토리에 존재하는 모든 파일에 대해 각각의 크기를 출력. 전체 파일 크기 출력
        - **-s**: 파일들의 전체 크기를 합한 값만 출력. 디렉토리 전체 사용량
        - **-d N**: 최대 N 번째 하위 디렉토리까지 표시 (--max-depth=N)
    - ex.
        - **```$ du -sh```**: 현재 디렉토리의 총 사용량을 단위(KB, MB, GB)로 출력
        - **```$ du -sh *```**: 현재 디렉토리 하위 모든 파일 및 디렉토리 사용량을 단위로 각각 출력
        - **```$ du -d 2 -h```**: 현재 디렉토리 기준 2 depth 까지 출력

다음으로 **스왑(Swap)**에 대해 살펴봅니다.

스왑(Swap) 이란 **하드디스크의 일부를 마치 메모리처럼 사용**하는 기술로, 일반적으로 리눅스 설치 시 설정합니다.
설치 후에도 디스크나 파티션 여유공간이 있다면 추가 설정할 수 있습니다.

스왑 관련 명령들을 살펴보겠습니다.

- **mkswap**
    - 스왑 파티션이나 스왑 파일을 생성하는 명령
    - **```# mkswap [option] [스왑_파일] [size]```**
    - **```# mkswap [option] [스왑_파티션]```**
    - 주요 옵션
        - **-c**: 스왑 파티션을 생성하기 전에 배드 블록을 검사하는 옵션
    - ex.
        - **```# mkswap /swap-file 10240```**: 10240K 크기의 /swap-file 을 생성. 크기를 나타내는 10240 은 생략 가능
        - **```# mkswap -c /dev/sdb2```**: /dev/sdb2 의 배드 블록을 검사한 후 스왑 파티션으로 생성

- **swapon**
    - 스왑 파티션이나 스왑 파일을 활성화시키는 명령으로 스왑의 상태 확인도 가능
    - **```# swapon [option] [스왑_파일]```**
    - **```# swapon [option] [스왑_파티션]```**
    - 주요 옵션
        - **-a**: **/etc/fstab** 파일에 등록된 스왑 영역을 전부 활성화. **noauto** 옵션이 설정된 경우는 제외
        - **-s**: 스왑 영역의 상태를 출력
    - **```# swapon /swap-file```**: 스왑 파일 활성화
    - **```# swapon /dev/sdb2```**: 스왑 파티션 활성화
    - **```# swapon -a```**: **/etc/fstab** 에 설정된 스왑 영역을 전부 활성화시킴
    - **```# swapon -s```**: 현재 스왑 상태를 출력

- **swapoff**
    - 활성화된 스왑 파티션이나 스왑 파일을 중지
    - **```# swapoff [option] [스왑_파일]```**
    - **```# swapoff [option] [스왑_파티션]```**
    - 주요 옵션
        - **-a**: 모든 스왑 영역을 중지
    - ex.
        - **```# swapoff /swap-file```**

- **free**
    - 현재 사용중인 메모리의 상태를 출력
    - **```$ free [option]```**
    - 주요 옵션
        - **-m**: 메모리 상태를 MB 단위로 출력
        - **-k**: 메모리 상태를 KB 단위로 출력
    - **```$ free -m```** << **CentOS 7 이전**
        ```text
                total       used    free    shared    buffers    cached
        Mem:     7805        653    7152         3         26       196
        -/+ buffers/cache:   429    7376
        Swap:    9913          0    9913
        ```
        - **Mem**: 물리적 메모리의 상태를 나타내는 부분
            - total: 전체 메모리 용량
            - used: 사용중인 메모리양
            - free: 유휴 메모리양
            - shared: 프로세스 간 공유되고 있는 메모리양
            - buffers, cached: 버퍼 메모리, 캐시 메모리로 사용되는 양
        - **-/+ buffers/cache**: 버퍼나 캐시 메모리로 사용되는 영역을 제외하고 실제 사용중인 메모리와 남은 영역 출력
        - **Swap**: 스왑 영역의 메모리 상태를 나타내는 부분. used 는 사용중인 스왑 메모리양, free 는 사용되지 않는 스왑 메모리양
    - **```$ free -m```** << **CentOS 7 이후**
        (<a href="https://brunch.co.kr/@dreaminz/2#:~:text=free%20%3A%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%97%90%EC%84%9C%20%EC%82%AC%EC%9A%A9%20%EA%B0%80%EB%8A%A5%ED%95%9C,%EA%B0%84%20%ED%86%B5%EC%8B%A0%EC%97%90%20%EC%82%AC%EC%9A%A9%EB%90%9C%EB%8B%A4." target="_blank">doz 정리글 참조</a>)
        ```text
                total   used    free    shared    buff/cache    available
        Mem:     7805    429    7152         3           224         7376
        Swap:    9913      0    9913
        ```
        - **Mem-used**: 이전 버전에서 used 는 버퍼와 캐시 사용량이 포함되었으나, 이후 버전에서는 buff/cache 사용량을 따로 분리했음
        (total - free - buff/cache). buff/cache 는 free 사용량에도 포함되지 않음 (이전 버전에서는 포함되었다고 봐도 무방)
        - **buff/cache**: 커널의 디스크에 대한 I/O 성능향상을 위하여 유휴 시스템 메모리 자원을 캐시 영역으로 사용
            - **Cache(Page Cache + Slabs)**: 디스크 내 파일정보를 페이지 단위로 읽어들여 캐시에 저장하여 이후 더 빠른조회가 가능,
            Page 캐시상 파일내용이 수정되면 dirty 플래그가 붙은 dirty page 가 되어 이후 커널의 백그라운드에서 처리되어 디스크에 반영
            후 플래그 제거됨. 캐시 영역은 페이지 캐시에 더해 커널이 내부적으로 사용하는 캐시인 slab 영역으로 구성
            - **buffer cache**: Page 캐시가 파일의 내용을 저장한다면, Buffer 캐시는 UFS(Unix File System) 기준 블록내
            Super block 과 Inode block 에 해당하는 메타데이터를 저장.
            특정 디렉토리를 읽어들이면 하위 파일들의 Inode block 들을 buffer 캐시에 저장하여 이후 더 빠르게 확인이 가능
            - 시스템 메모리 공간의 여유가 있다면 커널은 I/O 처리속도를 향상시키기 위하여 buff/cache 할당 영역을 확장시켜 나감
            - 그러나 시스템 메모리가 부족할 경우 사용하던 영역을 반환함 (Page Cache 중 dirty page 를 제외한 캐시부터 순차적으로 반환)
        - **available**: swapping 없이 새 어플리케이션의 실행이 가능한 실질적 가용 메모리양. 고정적으로 사용 가능한 free 용량에
        buff/cache 재할당 가능 영역을 고려하여 산출됨 (/proc/meminfo 파일 내부정보로 계산, 자세한 내용은 더 찾아볼 것)

> **할당된 buff/cache 영역을 모두 반환한 경우는?**
> - 프로그램 구동을 위해 필요한 메모리를 확보하기 위해 buff/cache 영역을 모두 반환한 경우, swap 영역을 할당함
> - 이는 성능 저하를 야기하며, 이것마저 부족하게 된다면 OOM(Out of Memory) Killer 에 의해 프로세스들이 강제 종료됨

> **메모리의 비정상적인 사용 모니터링 방법**
> - **free** 명령으로 자세한 메모리 사용현황을 알 수 없으므로 **/proc/meminfo** 파일의 상세 내용을 참조하여야 함 (필요시 더 찾아볼 것)

다음으로 **스왑 영역 만들기**를 진행해 보겠습니다.

- **스왑 파일 생성하기**
    1. **dd** 명령을 이용하여 원하는 파일의 크기만큼 스왑 파일을 생성
        - **```# dd if=/dev/zero of=/swap-file bs=1K count=1024000```**
        - **if** 부분은 초기화시 사용하는 장치 파일명, **of** 부분은 생성할 스왑파일명, **bs** 부분은 블록 크기를 지정(단위입력
        없으면 바이트 크기), **count** 부분은 **bs** 설정한 블록의 개수(위 경우 1GB 크기의 파일 생성)
    2. 스왑 파일 생성
        - **```# mkswap /swap-file```**
    3. 스왑 파일 활성화
        - **```# swapon /swap-file```**
    4. 시스템 부팅시마다 사용하려면 **/etc/fstab** 파일에 등록
        - **```/swap-file    swap    swap    defaults    0 0```**

- **스왑 파티션 생성하기**
    1. **fdisk** 명령으로 스왑 파티션 생성
        - **```# fdisk /dev/sdb```**
        - 명령행 모드에서 파티션의 속성을 변경하는 모드인 **t** 입력, Swap 속성코드인 **82** 입력, 생성하는 파티션명은 **/dev/sdb2**
    2. 스왑 파티션 생성
        - **```# mkswap -c /dev/sdb2```**
        - 배드 블록을 검사(**-c**)하며 스왑 파티션 생성
    3. 스왑 파티션 활성화
        - **```# swapon /dev/sdb2```**
    4. 시스템 부팅시마다 사용하려면 **/etc/fstab** 파일에 등록
        - **```/dev/sdb2    swap    swap    defaults    0 0```**

다음으로 **디스크 쿼터**에 대해 살펴보겠습니다.

- **Disk Quota**
    - 리눅스 시스템에서 사용자는 기본적으로 디스크에 남은 모든 용량을 사용할 수 있음
    - 사용자가 많은 경우 디스크 사용량에 제한을 둘 필요가 있는데, 이를 **디스크 쿼터**라 부름
    - **디스크 쿼터**: 사용자 및 그룹의 디스크 사용량과 생성할 수 있는 파일의 개수(I-node 수)를 제한하는 것

다음은 디스크 쿼터 관련 명령어입니다.

- **quotacheck**
    - 디스크를 사용하고 있는 파일 시스템을 검사하여 quota 기록 파일(aquota.user, aquota.group or quota.user, quota.group)을
    가장 최신상태로 업데이트하는 명령
    - 이 기능은 처음 설정시 혹은 사용자의 변경된 용량, 쿼터 등의 정보를 인식하지 못하는 경우 사용
    - **/home** 디렉토리가 단독 파티션으로 분할된 경우는 **/home** 을 체크하고, 아닌 경우 **/** 를 체크
    - **```# quotacheck [option] [dir_name]```**
    - 주요 옵션
        - **-a**: 사용자와 그룹에 대한 쿼터 체크
        - **-m**: 읽기전용모드 등의 이유로 마운트하지 못할 경우 강제로 체크
        - **-f**: 쿼터파일 초기 생성 시 인식하지 못하는 경우 강제로 인식하도록 함
        - **-u**: 사용자 쿼터파일 체크시 사용 (기본 옵션)
        - **-g**: 그룹 쿼터파일 체크시 사용
        - **-c**: 기존 생성된 쿼터관련 파일을 읽지 않고 새롭게 초기화
    - ex.
        - **```# quotacheck /home```**: **/home** 에 생성한 쿼터파일 체크. 파일 손상의 위험이 있으므로 **quotaoff** 상태에서 수행
        - **```# quotacheck -mf /home```**: **quotaoff** 하고 진행하지 않아도 무조건 검사
        - **```# quotacheck -mf -u -g /home2```**: 사용자 쿼터파일과 그룹 쿼터파일을 동시에 검사
        - **```# quotacheck -a```**: 생성된 쿼터파일을 찾아 검사
        - **```# quotacheck -cf /home```**: 쿼터파일 초기화

- **edquota**
    - 사용자나 그룹에 쿼터를 설정할 때 사용하는 명령
    - vi 편집기가 실행되며, 쿼터 단위는 기본 KB 이므로 10MB 제한하려면 10000 로 입력해야 함
    - **```# edquota [option]```**
    - 주요 옵션
        - **-u**: 사용자 쿼터를 설정할 때 사용 (기본 옵션)
        - **-g**: 그룹 쿼터를 설정할 때 사용
        - **-t**: Soft Limit 을 초과한 후부터 적용되는 시간제한(Grace Period) 설정
        - **-p**: 특정 사용자의 쿼터를 다른 사용자에게 동일한 설정으로 적용
    - ex.
        - **```# edquota rdsuser```**: 사용자 쿼터 할당. vi 편집기가 실행되어 다음과 같이 설정<br>
        ```text
        Disk quotas for user rdsuser (uid 1001):
          Filesystem        blocks    soft    hard    inodes    soft    hard
          /dev/sda1           1200       0       0       166       0       0
        ```
            - **Filesystem**: Quota 가 설정된 파티션
            - **Blocks**: 현재 사용중인 용량(KB)
            - **soft**: 사용 가능한 최대 용량(KB). 만약 **hard** 용량보다 낮다면, **soft** 용량 초과 후 **hard** 에 도달하기
            전까지 지정한 **유예기간(Grace Period)** 동안 초과가 가능. 유예기간 내 **soft** 수준까지 줄이지 않으면
            파일 생성이 불가해짐
            - **hard**: 실제 사용 가능한 최대 용량(KB). 이 수치는 절대 초과할 수 없음
            - **inodes**: 현재 사용중인 I-node 수(파일이나 디렉토리의 수)
            - **soft**: 사용 가능한 I-node 수 지정. **Blocks** 의 **soft** 와 같은 방식
            - **hard**: 실제 사용 가능한 I-node 수 지정. **Blocks** 의 **hard** 와 같은 방식
        - **```# edquota -t```**: 유예기간(Grace Peroid) 지정. vi 편집기가 실행되어 다음과 같이 설정<br>
        ```text
        Grace period before enforcing soft limits for users:
        Time units may be: days, hours, minutes, or seconds
          Filesystem        Block grace period        Inode grace period
          /dev/sda1               7days                     7days
        ```
            - **Filesystem**: Quota 가 설정된 파일 시스템
            - **Block grace period**: **Block** 의 **soft** 제한 초과시 유예기간
            - **Inode grace period**: **Inode** 의 **soft** 제한 초과시 유예기간
        - **```# edquota -p rdsuser ihduser```**: rdsuser 의 쿼터 설정을 ihduser 에게 동일하게 적용

- **quotaon/quotaoff**
    - 쿼터 설정을 활성화/비활성화
    - **```# quotaon [option] [디렉토리명]```**
    - **```# quotaoff [option] [디렉토리명]```**
    - 주요 옵션
        - **-u**: 사용자 쿼터 활성화 옵션 (기본 옵션)
        - **-g**: 그룹 쿼터 활성화 옵션
        - **-v**: 메시지 자세히 출력
    - ex.
        - **```# quotaon /home```**
        - **```# quotaon -gv /home```**: 그룹 쿼터를 시작하며 메시지 자세히 출력
        - **```# quotaoff /home```**

- **repquota**
    - 파일 시스템 단위로 쿼터 설정정보 출력
    - **```# repquota [option] [디렉토리명]```**
    - 주요 옵션
        - **-a**: 쿼터가 설정된 모든 파티션 정보 출력. 별도 디렉토리명 지정하지 않아도 됨
        - **-u**: 사용자 쿼터정보 출력 (기본 옵션)
        - **-g**: 그룹 쿼터정보 출력
    - ex.
        - **```# repquota /```**: / 에 설정된 사용자 쿼터정보 출력
        - **```# repquota -g /home```**: /home 의 그룹 쿼터정보 출력
        - **```# repquota -a```**: 설정된 쿼터정보 전부 출력

- **quota**
    - 사용자 단위로 쿼터 설정정보 출력
    - **```$ quota [사용자명]```**
    - 주요 옵션
        - **-u**: 사용자 쿼터정보 출력 (기본 옵션)
        - **-g**: 그룹 쿼터정보 출력
        ```text
        [rdsuser@www ~]$ quota
        Disk quotas for user rdsuser (uid 1001):
            Filesystem    blocks    quota    limit    grace    files    quota    limit    grace
             /dev/sda1      1204   100000   120000               167        0        0
        ```

- **setquota**
    - 쿼터를 설정하는 명령. vi 편집기 대신 직접 명령행 입력
    - **```# setquota [option] [사용자명] [block_soft] [block_hard] [inode_soft] [inode_hard]```**
    - **```# setquota -t [block_grace] [inode_grace] [Filesystem]```**
    - 주요 옵션
        - **-u**: 사용자 쿼터 설정시 사용 (기본 옵션)
        - **-g**: 그룹 쿼터 설정시 사용
        - **-t**: 유예 기간(Grace Period) 설정시 사용 (단위는 초)
    - ex.
        - **```# setquota -u rdsuser 10000 11000 0 0 /home```**: 용량 제한 soft 10MB, hard 11MB 설정, I-node 제한은 미설정
        - **```# setquota -t 86400 28800 /home```**: block grace 는 하루(24h), inode grace 는 8시간 설정

> **[퀵스타트] 사용자 쿼터 설정하기**
> 1. **/etc/fstab 설정**
>     - 파일의 4번째 필드에 사용자쿼터 옵션인 **usrquota** 추가 기입(콤마로 구분)
>     - 만약 /home 파티션이 분리되어 있다면 그곳에, 아니라면 / 영역에 설정
> 2. **/home 영역 다시 마운트**
>     - **```# mount -o remount /home```**
> 3. **쿼터파일 생성 및 쿼터 체크**
>     - **```# quotacheck -mf /home```**
> 4. **사용자에 대한 쿼터 설정**
>     - **```# edquota rdsuser```**
> 5. **쿼터 시작**
>     - **```# quotaon /home```**
> 6. **쿼터 설정 확인**
>     - **```# repquota /home```**

> **[퀵스타트] 그룹 쿼터 설정하기**
> 1. **/etc/fstab 설정**
>     - 파일의 4번째 필드에 그룹쿼터 옵션인 **grpquota** 추가 기입(콤마로 구분)
>     - 만약 /home 파티션이 분리되어 있다면 그곳에, 아니라면 / 영역에 설정
> 2. **/home 영역 다시 마운트**
>     - **```# mount -o remount /home```**
> 3. **쿼터파일 생성 및 쿼터 체크**
>     - **```# quotacheck -gm /home```**
> 4. **그룹에 대한 쿼터 설정**
>     - **```# edquota -g terran```**
> 5. **쿼터 시작**
>     - **```# quotaon /home```**
> 6. **쿼터 설정 확인**
>     - **```# repquota -g /home```**

### 프로세스 관리

### 소프트웨어 설치 및 관리

### 2-2. 장치 관리

### 장치의 설치 및 관리

### 주변장치 관리

### 2-3. 시스템 및 보안 관리

### 시스템 분석

### 시스템 보안 및 관리

### 시스템 백업

### 2-4. 기출 예상문제 오답노트

<br><br>
## 3. 네트워크 및 서비스의 활용

<br><br>
## 4. 기출 및 부록 정리
