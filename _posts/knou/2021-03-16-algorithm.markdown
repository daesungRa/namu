---
title:  "[방통대] 알고리즘 수업 정리"
created:   2021-03-16 22:48:07 +0900
updated:   2021-03-17 15:29:33 +0900
author: namu
categories: knou
permalink: "/knou/:year/:month/:day/:title"
image: https://images.unsplash.com/photo-1509475826633-fed577a2c71b?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=1651&q=80
alt: algorithm image
image-view: true
image-author: Sigmund
image-source: https://unsplash.com/photos/HsTnjCVQ798
---


---

### 목차

1. [알고리즘 학습에 앞서서](#1-알고리즘-학습에-앞서서)
2. [알고리즘의 기초](#2-알고리즘의-기초)
3. [분할정복 알고리즘 1](#3-분할정복-알고리즘-1)
4. [분할정복 알고리즘 2](#4-분할정복-알고리즘-2)
5. [동적 프로그래밍 알고리즘 1](#5-동적-프로그래밍-알고리즘-1)
6. [동적 프로그래밍 알고리즘 2](#6-동적-프로그래밍-알고리즘-2)
7. [](#)
8. [](#)
9. [](#)
10. [](#)
11. [](#)
12. [](#)
13. [](#)
14. [](#)
15. [](#)

---

<br>
## 들어가며

다음은 2021학년도 1학기 알고리즘 수업에 대한 정리입니다.

<br>
## 1. 알고리즘 학습에 앞서서

### 컴퓨터 과학에서 알고리즘의 위치

- 컴퓨터 과학 = 컴퓨터 + 데이터 + (프로그램 + 알고리즘)

알고리즘은 컴퓨터 과학 내에서 문제해결을 위한 프로그램을 작성하는 데 사용됩니다.
알고리즘이 없으면 문제 해결 방법을 찾을 수가 없죠.

따라서 컴퓨터 과학은 **알고리즘의 과학**이라고 할 수 있습니다.<br>
-> "알고리즘과 관련된 이슈를 다루는 학문" (한계, 분석, 개발, 실행, 통신, 표현)

잘 알려진 특정 문제를 통해 알고리즘의 설계 및 분석 방법을 습득해야 하는데,
이를 위해서는 ```컴퓨터 기반 문제 해결 방법에 대해 체계적으로 생각하는 훈련```을 통해
```주어진 문제에 대한 지적 추상화 능력 및 통찰력 향상```이 이루어져야 합니다.

### 알고리즘은 왜 필요한가?

컴퓨터 과학은 컴퓨터를 이용해서 주어진 문제를 해결하기 위한 학문입니다.
문제 해결 과정에서는 일련의 절차가 수행되어져야 합니다. 문제 해결을 위한 "레시피"라고 이해하면 편한데,
식재료를 음식으로 만들기까지 단계적인 조리 과정이 문제 해결을 위한 절차와 유사하기 때문입니다.
**문제 해결을 위한 일련의 단계적인 처리과정이 곧 알고리즘**입니다.

나아가 같은 음식을 만드는 데에도 여러 방식이 존재하는 것처럼 동일한 문제 해결을 위한 알고리즘에도 여러 방식이 있을 수 있습니다.
여러 레시피 중 "맛있고 건강에 도움이 되게 하는" 레시피가 좋은 레시피입니다.
이와 마찬가지로 효율적인 알고리즘이 좋은 알고리즘입니다.

> 효율적인 알고리즘의 예시 => 퀘닉스버그 다리 문제 '한붓 그리기'
>> - 한 점에서 연결된 선분이 홀수개인 홀수점이 0개 혹은 2개이어야 한다.
>> - 홀수점이 2개일 경우 홀수점에서 시작해야 한다.

### 알고리즘의 학습을 위해 필요한 것

- 자료구조
- 프로그램 능력
- 수학적 지식(기반)

본 수업에서는 알고리즘에 활용되는 자료구조 이해와 기본적인 프로그램 능력, 수학적 지식이 필요합니다.
프로그램 능력이라 함은 최소한 코드를 보고 흐름을 이해할 수 있어야 함을 의미하며,
수학적 지식은 논리적인(수학적) 사고가 가능한지가 중요합니다.
자료구조는 복습을 통해 우선적으로 학습하게 됩니다.

<br>
## 2. 알고리즘의 기초

본 강에서는 알고리즘의 개념, 설계, 분석을 공부하고, 성능을 어떻게 평가할 것인지에 대해 살펴봅니다.

### 학습목표

- 알고리즘의 정의 및 조건 이해
- 알고리즘 설계의 다양성 및 대표적인 설계 기법의 종류를 이해하고 설명할 수 있다
- 알고리즘의 시간 복잡도의 개념을 이해하고 적용할 수 있다
- 점근성능의 표기법의 종류를 이해하고 적용할 수 있다
- 기본적인 점화식의 종류와 개념을 이해하여 설명할 수 있다

### 알고리즘의 개념

알고리즘은 주어진 문제를 풀기 위한 명령어들의 단계적 나열을 의미합니다.
단, **```입출력```**0개 이상의 input과 1개 이상의 output이 있어야 하며,
**```명확성```**각 명령은 모호하지 않고 단순 명확하야 하고,
**```유한성```**한정된 수의 단계를 거친 후에는 반드시 종료되어야 하며,
**```유효성```**모든 명령은 컴퓨터에서 수행 가능해야 합니다.

위 네 가지 조건이 만족되는 알고리즘이어야만 컴퓨터로 해결할 수 있습니다.

여기서 실용적인 관점 하나를 추가하자면, 알고리즘은 **```효율적```**이어야만 합니다.
해결하는데 너무 많은 시간이 소요된다면 그것은 문제해결을 위해 적절한 알고리즘이라고 할 수 없습니다.

### 알고리즘의 생성 단계

설계 -> 표현/기술 -> 정확성 검증 -> 효율성 분석

...

### 시간 복잡도

시간 복잡도는 주어진 알고리즘의 연산 횟수를 함수화하여 그 중 최고차항에 대한 Big-oh(빅-오) 표기법으로 나타냅니다.

### 점근성능, 표기법

성능을 측정할 때는 입력 크기 n이 **무한대로 커짐**을 가정합니다.
이에 따라 상수 및 최고차항보다 작은 차수의 항들은 사실상 의미가 없어집니다.
알고리즘의 다항식 함수에서 최고차항만을 취해서 표현하는 것을 **점근성능**이라고 합니다.

점근성능은 정확한 값이 아닌 어림값입니다. 하지만 입력 크기에 따른 증가추세를 파악하여 알고리즘 간 우열을 표현하는 데는 아주 용이합니다.

- [정의] Big-oh 점근적 상한
> 어떤 양의 상수 c와 n0이 존재하여 모든 n>=n0에 대하여 f(n)<=c*g(n)이면 f(n)=O(g(n))이다.

Big-oh 점근적 상한 정의가 의미하는 바는 **내가 정의한 알고리즘 함수 f(n)의 수행시간의 상한식 g(n)**입니다.
즉 아무리 성능이 나빠져도(수행시간이 늘어나도↑) 상한함수보다는 나빠지지(수행시간이 늘어나지↑) 않음을 의미합니다.
내 알고리즘의 최악의 수행사례를 가정하여 시간 복잡도를 표현하는 것입니다.
이를 O(g(n))으로 표기합니다.

- [정의] Big-omega 점근적 하한
> 어떤 양의 상수 c와 n0이 존재하여 모든 n>=n0에 대하여 f(n)>=c*g(n)이면 f(n)=Ω(g(n))이다.

Big-omega 점근적 하한은 Big-oh와는 반대로 **하한식 g(n)**을 표현합니다.
이는 내 알고리즘의 성능이 아무리 좋아져도(수행시간이 줄어들어도↓) 하한함수보다는 좋아지지(수행시간이 줄어들지↓) 않음을 의미합니다.

- [정의] Big-theta 점근적 상하한
> 어떤 양의 상수 c1, c2와 n0이 존재하여 모든 n>=n0에 대하여 c1*g(n)<=f(n)<=c2*g(n)이면 f(n)=θ(g(n))이다.

추가적으로 Big-theta 점근적 하한은 **상한식과 하한식을 전부 포함하는 g(n)**을 표현합니다.

일반적으로 시간 복잡도를 표현할 때는 Big-oh 점근적 상한식을 활용하므로, **O(상수를 제거한 상한식의 최고차항)**으로 나타냅니다.

ex) ```f(n) = 3n² + 5``` => O(n²)

### 주요 O-표기 간의 연산 시간의 크기 관계

O(n), O(n^2), O(n^3)중 어느 것이 가장 효율적인(연산횟수 ↓) 알고리즘일까요?
단순히 n에 수를 늘려가며 대입하여 비교해봐도 O(n)의 연산 횟수 증가정도가 가장 작습니다.

주요 알고리즘 함수식 비교
- O(1) < O(logn) < O(n) < O(nlogn) < O(n²) < O(2ⁿ) < O(n!)

오른쪽으로 갈수록 연산 횟수 정도가 더 큰 비효율적(연산횟수, 수행시간 ↑) 알고리즘입니다.

![Big-Oh complexity chart](https://media.vlpt.us/images/raram2/post/7c0a3c68-c792-44a3-8173-b6ba81145a85/BigO%20notation.png)
이미지 출처: [velog.io](https://velog.io/@raram2/big-o-notation-and-time-complexity)

### 실용적으로 구해보기

알고리즘의 함수식을 구한 후 최고차항 함수식 g(n)을 추출하여 빅-오로 표기하는 것이 정석적인 방법이나,
실용적으로는 **알고리즘 내에 나타난 루프의 반복 횟수를 조사**하여 시간 복잡도를 취합니다.

설명하자면 n이 무한대로 증가함에 따라 가장 영향을 받는 부분이 반복문이기 때문에 위와 같이 합니다.
알고리즘의 함수식에서 반복 상황이 중첩적으로 가장 많은 루프를 최고차항으로 판단합니다.
그 외 최고차항에 붙은 상수는 반복문 내 존재하는 단순 연산들의 개수를,
낮은 차수들은 중첩 반복이 더 적은 또다른 반복문을,
기타 상수는 함수 내 추가적인 연산만을 의미하기 때문에 점근 상황에서는 무시 가능합니다.

### 순환 알고리즘의 성능

순환 알고리즘의 시간 복잡도는 일반적인 방법으로 알아내기 어렵습니다.
따라서 각 순환 알고리즘에 따른 **점화식**을 활용합니다.
대표적인 순환 알고리즘인 재귀식을 활용하는 이진 탐색의 점화식은 다음과 같습니다.

- 재귀(recursion)
    - T(n) = T(n/2) + O(1), T(1) = c1

매번 점화식을 풀기보다는 아래 기본 점화식과 폐쇄형을 미리 숙지해 둡시다.

![recurrence relation](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdwE1HE%2FbtqCB8Oqd1I%2Fis2pl7hQcgIk9BdY3XMN5k%2Fimg.png)
이미지 출처: [atoz-develop.tistory.com](https://atoz-develop.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EC%84%A4%EA%B3%84%EC%99%80-%EB%B6%84%EC%84%9D-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84%EC%99%80-%EC%A0%90%EA%B7%BC%EC%84%B1%EB%8A%A5)

<br>
## 3. 분할정복 알고리즘 1

<br>
## 4. 분할정복 알고리즘 2

<br>
## 5. 동적 프로그래밍 알고리즘 1

<br>
## 6. 동적 프로그래밍 알고리즘 2

최적 부분 구조(Optimal Substructure)와 중복되는 부분 문제(Overlapping Subproblem)의 특징을 갖는 동적 프로그래밍에서는
memoization을 빈번하게 사용합니다. 가능하다면 반복문Loop으로 구현하고 좋으며 보텀업 방식을 찾아가는 것이 성능상 좋습니다.

### 스트링 편집 거리 문제 (Edit distance)

이 문제는 **문자열 Xi를 문자열 Yj로 편집하는 데 드는 최소비용 구하기**입니다.<small>(i, j는 각 문자열의 길이입니다.)</small>
**편집에는 삽입I, 삭제D, 변경C 연산**이 있는데 각각의 비용이 소요됩니다.
특정 순서 i의 문자를 편집하고자 할 때 Xi 문자를 삭제할지 새로 삽입할지, 아니면 Xi를 변경할지 결정하되,
최소 비용이 드는 것을 선택해야 합니다.

따라서 두 문자열 사이의 편집 거리는 이들의 부분 문자열 사이의 편집거리를 포괄하게 되어 최적성의 원리를 만족합니다.
즉, X 문자열 중 특정 위치의 문자까지의 편집 최소비용은 그 이전 문자까지의 편집 최소비용을 포함한다는 의미입니다.
따라서 동적 프로그래밍 방법을 적용할 수 있습니다.

직전 부분 문자까지의 최소 편집 거리를 통해서 마지막 문자까지의 최소 편집 거리를 도출하는 방식이므로,
그 상황은 **(1)마지막 문자열을 삭제하는 경우, (2)마지막 문자열을 삽입하는 경우,
(3)마지막 문자열이 같거나 같도록 만들어주는 경우**의 총 세 가지가 있으며, 이 중 최소값을 구하면 됩니다.
이에 따른 점화식은 다음과 같이 도출합니다.

```text
E(i, j) = min[E(i - 1, j) + δD,
              E(i, j - 1) + δI,
              E(i - 1, j - 1) + (0 / δC)]

* 0 / δC = 0, xi = yi or 0 / δC, xi != yi
```

최소값 E(i, j)를 구하되(min),
이전 단계로부터 문자를 삭제하거나 삽입하거나 같게 하는 경우 중 하나가 선택되도록 하는 것입니다.

DP는 메모이제이션을 많이 활용한다고 했으므로,
부분 구조들의 최소비용 저장을 위해 문자열 X, Y에 해당하는 이차원 배열을 만들어
직전 부분 구조로부터 해당 순서의 최소비용을 구해나갈 수 있습니다. 예제 문제를 봅시다.

#### 예제 1) X = bbabb, Y = abaa, δD = δI = 1, δC = 2 일때 edit distance 구하기

|  |  | a | b | a | a |
|  | **0** | **1** | **2** | **3** | **4** |
| b | **1** | 2 | 1 | 2 | 3 |
| b | **2** | 3 | 2 | 3 | ... |
| a | **3** |  |  |  |  |
| b | **4** |  |  |  |  |
| b | **5** |  |  |  | **E(i, j)** |

```text
/* (1, 1)의 최소비용 구하기 */
E(1, 1) = min[E(0, 1) + 1, E(1, 0) + 1, E(0, 0) + 2]
        = min[2, 2, 2] = 2

/* (1, 2)의 최소비용 구하기, 같은 문자이므로 변경(δC)시 비용은 0 */
E(1, 2) = min[E(0, 2) + 1, E(1, 1) + 1, E(0, 1) + 0]
        = min[3, 3, 1] = 1

/* (1, 3)의 최소비용 구하기 */
E(1, 3) = min[E(0, 3) + 1, E(1, 2) + 1, E(0, 2) + 2]
        = min[4, 2, 4] = 2

...
```

순서대로 각 항목의 최소비용을 구해나가는 과정을 메모이제이션으로 나타낸 것입니다.
최적 부분 구조가 보이시나요? 각 순서의 항목들은 이전 문자까지의 최소비용으로부터 구해집니다.
삭제, 삽입 시 1의 비용이 추가되고 변경시 2의 비용이 순서대로 추가되는 것이죠.
만약 Xi -> Yj 문자가 같다면 바꿀 필요가 없으므로 변경 비용은 0일 것입니다.

이런 식으로 E(i, j)를 구하게 되면 최소 비용은 5가 도출됩니다.
이번에는 의미 있는 문자열로 문제를 풀어봅시다.

#### 예제 2) X = SNOWY, Y = SUNNY, δD = δI = 1, δC = 2 일때 edit distance 구하기

|  |  | S | U | N | N | Y |
|  | **0** | **1** | **2** | **3** | **4** | **5** |
| S | **1** | 0 | 1 | 2 | 3 | 4 |
| N | **2** | 1 | 2 | 1 | 2 | 3 |
| O | **3** | 2 | 3 | ... |  |  |
| W | **4** |  |  |  |  |  |
| Y | **5** |  |  |  |  | **4** |

```text
/* (1, 1)의 최소비용 구하기, 같은 문자이므로 변경(δC)시 비용은 0 */
E(1, 1) = min[E(0, 1) + 1, E(1, 0) + 1, E(0, 0) + 0]
        = min[2, 2, 0] = 0

/* (1, 2)의 최소비용 구하기 */
E(1, 2) = min[E(0, 2) + 1, E(1, 1) + 1, E(0, 1) + 2]
        = min[3, 1, 3] = 1

/* (1, 3)의 최소비용 구하기 */
E(1, 3) = min[E(0, 3) + 1, E(1, 2) + 1, E(0, 2) + 2]
        = min[4, 2, 4] = 2

...
```

풀이 과정은 위와 동일합니다. 직전 문자의 최소비용으로부터 다음 문자의 최소비용을 도출하는 방식입니다.

이제 코드로 구현을 해볼텐데, 위 알고리즘의 순서대로 하면 됩니다.

1. **입력**: X, Y 문자열과 각 편집비용 입력
2. 충분한 크기의 메모이제이션 생성(X, Y 문자열 길이의 +1)
3. **초기화**: 초기값 세팅
    - 초기값은 (1, 0), (2, 0), ..., (i, 0) 자리에 X의 각 문자를 세팅하고, Y 문자열에 대해서도 동일하게 하면 됩니다.
4. **탐색**: i, j 순서까지 반복하여 최소비용 구하기
    - 메모이제이션 이차원 배열의 각 항목에 최소비용을 넣되,
    - 각각의 직전 항목으로부터 insert, delete, change 중 최소비용을 선택합니다.
5. 최소비용 반환

이것을 파이썬으로 구현해 보겠습니다.

```python
def solution(str1, str2, insert, delete, change):  # 1.
    n, m = len(str1), len(str2)

    # 2. Make memoization
    answer = [[0 for _ in range(m + 1)] for _ in range(n + 1)]

    # 3. Initialize values
    for i in range(1, n + 1):
        answer[i][0] = i * insert
    for j in range(1, m + 1):
        answer[0][j] = j * insert

    # 4. Calc distance
    for i in range(n):
        for j in range(m):
            answer[i + 1][j + 1] = min(
                answer[i][j + 1] + delete,
                answer[i + 1][j] + insert,
                answer[i][j] + (0 if str1[i] == str2[j] else change),
            )
    return answer[n][m]
```

```solution()``` 함수는 **1. 문자열 두 개를 입력받아** 이전 문자열에서 나중 문자열로 편집하는 최소비용을 반환합니다.
insert, delete, change 의 연산별 비용은 함수 내에 고정적으로 세팅할 수 있습니다.
다음으로 **2. 메모이제이션을 생성**하되, 초기비용 0으로부터 출발하기 위해 각 문자열의 길이 +1에 해당하는 이차원 배열을 만듭니다.
그리고 **3. 초기값 세팅** 시 (x축, 0), (0, y축) 방향으로 insert 비용만큼 값이 증가하도록 넣습니다.
insert = 1 이라면 1씩 증가할 것이고, 2라면 x2씩 값이 증가할 것입니다.
마지막으로 최적 부분 구조가 되는 **4. 각 문자별 최소비용**을 상향식으로 계산해 나갑니다.

여기서 추가적으로 어떤 방식으로 변경되는지 편집 방향을 알고 싶다면, 마지막 최소비용이 구해지는 E(n, m)으로부터 역추적하는 로직 P를 추가합니다.

### 플로이드(Floyd) 알고리즘 - 모든 정점 간의 최단경로(Shortest Path) 구하기

가중 방향 그래프에서 최단 경로를 구하는 방법은 여러 가지가 있습니다.
그 중 **플로이드 알고리즘은 모든 정점 간의 최단 경로**를 다이나믹 프로그래밍 방식으로 구해나가는 것입니다.
즉, 최적 부분 구조를 갖는다는 의미이죠.

이와 다르게 단일 출발점으로부터 다른 모든 정점까지의 최단 경로를 구하는 방법을 다익스트라<small>Dijkstra</small> 알고리즘이라고 합니다.
이것은 기본적으로 그리디<small>greedy, 탐욕</small> 알고리즘으로 분류되지만,
이전 방문노드의 값을 활용하므로 최적 부분 구조로 볼 수도 볼 수도 있습니다.

어쨌든 플로이드의 아이디어는 이렇습니다. 모든 정점 간의 최단경로를 구하기 위해 최적 부분 구조의 특성을 이용하여
**모든 정점 간의 관계가 표현된 이차원 배열 메모이제이션**에 상향식으로 최소 가중치 비용을 채워 나갑니다.
특정 정점 i, j를 의미하는 각 항목에서의 최소비용을 구할 때 경유하는 정점 k를 순차적으로 늘려나가며 최소비용을 찾습니다.
두 정점 간에 직접 연결이 최소비용이기도 하지만, 특정 정점을 경유할 시 그것이 최소비용이 될 수도 있습니다.
또는 직접연결이 불가하여 비용을 구하지 못하던 정점들도, 여러 다른 정점들을 경유할 시 최소비용이 도출될 수 있습니다.

다시 말하자면, 두 정점 i와 j 간의 최단경로를 구할 시 경유하는 정점 1부터 k 까지를 모두 고려하여 그 중 최소비용을 사용합니다.
**정점 k 를 경유하는 시점의 최단경로는 정점 k - 1 까지 경유하는 최소비용을 최적 부분으로 갖는다는 점**을 생각하십시오.
정점 k - 1 입장에서는 현재까지가 최단거리일 것이고, 정점 k 까지 고려하는 상황에서는 k 를 경유하는 시점의 거리를 이전 최단거리와 비교해야 할 것입니다.
정점 k 를 고려하기 위해서는 (출발점인 i부터 k 까지의 최단거리 + k부터 목적지 j 까지의 최단거리) 계산을 하면 됩니다.
그럼 플로이드의 점화식을 살펴봅시다.

```text
D(i, j, 0) = d(ij) = w(ij), 1 <= i, j <= n  /* 경유 정점이 없는 경우 가중치를 그대로 사용 */

D(i, j, k) = min[ D(i, j, k - 1), D(i, k, k - 1) + D(k, j, k - 1) ]
```

최단거리 D(i, j, k)에서 k 는 경유지점, i와 j는 각각 출발지점과 목적지점을 의미합니다.
뒤에 min 연산에서는 ij 까지 중 k - 1을 경유하는 상황의 최단거리와, k를 경유하는 최단거리 중 작은 것을 선택합니다.

알고리즘 구현 시, 순서는 다음과 같이 하면 됩니다.

1. **입력**: 모든 정점과 가중치 값 입력
2. **초기화**: 입력값에 따라 이차월 배열(인접 행렬)로 비용 초기화
    - 이 때 ij로 직접 연결을 고려하므로, 직접 연결 간선이 존재하는 경우 그것의 가중치로,
    - 존재하지 않는 경우 무한대의 값으로 초기화합니다.
3. **탐색**: 경유 노드를 기준으로 모든 출발점과 끝점간 반복하며 최소비용을 구합니다.

이것을 파이썬으로 구현해 보겠습니다.

```python
import sys

INF = sys.maxsize  # Static Infinite value


def solution(n, graph, start, end):
    # 2. Make memoization and Initialize values
    answer = [[INF]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            answer[i][j] = graph[i][j]

    # 3. Calc distance -> 경유하는 k기준
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if answer[i][j] > answer[i][k] + answer[k][j]:
                    answer[i][j] = answer[i][k] + answer[k][j]

    return answer[start - 1][end - 1]  # Start with index 0
```

구현 자체는 상당히 쉽습니다.
가중 방향 그래프에 맞게 초기화하고 ij 최단거리와 k를 경유하는 상황의 최단거리를 비교하면 완료되기 때문입니다.
