---
title:  "[방통대] 데이터베이스 수업 정리"
created:   2021-03-20 14:42:24 +0900
updated:   2021-04-15 11:58:15 +0900
author: namu
categories: knou
permalink: "/knou/:year/:month/:day/:title"
image: https://images.unsplash.com/photo-1569235186275-626cb53b83ce?ixlib=rb-1.2.1&ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&auto=format&fit=crop&w=1952&q=80
alt: database image
image-view: true
image-author: Maksym Kaharlytskyi
image-source: https://unsplash.com/photos/Q9y3LRuuxmg
---


---

### 목차

1. [데이터베이스의 이해](#1-데이터베이스의-이해)
2. [데이터베이스 모델링](#2-데이터베이스-모델링)
3. [관계형 모델](#3-관계형-모델)
4. [SQL 1](#4-sql-1)
5. [SQL 2](#5-sql-2)
6. [SQL 3](#6-sql-3)
7. [](#)
8. [](#)
9. [](#)
10. [](#)
11. [](#)
12. [](#)
13. [](#)
14. [](#)
15. [](#)

### 참조

- 정재화 (2020). 데이터베이스 시스템. 서울: 한국방송통신대학교출판부.
- 정재화. 데이터베이스 시스템 강의 (2021). 한국방송통신대학교 UKNOU 캠퍼스

---

<br>
## 들어가며

다음은 2021학년도 1학기 데이터베이스 수업에 대한 정리입니다.

<br>
## 1. 데이터베이스의 이해

데이터베이스 시스템이 만들어진 이유는 급격한 사회 트렌드의 변화 속에서 빠르게 증대되는 데이터를 효율적으로 관리할 필요성이 높아졌기 때문입니다.
실제로 데이터 세계의 총량은 2013년 ```4.4 ZB```(제타바이트) 규모였으나 2020년 ```44 ZB``` 규모로 증대될 것이라 예측되었고,
현재는 ```60 ZB``` 분량으로 늘어났다고 합니다.

### 데이터베이스의 역할

데이터베이스 시스템은 이와 같이 많은 데이터를 **저장 및 관리**하고 필요한 데이터를 **신속히 검색**할 수 있도록 보조하는 장치입니다.

**데이터 관리의 역사**
![history of database]({{ site.github.url }}{% link assets/post-img/history_of_db.png %})

전통적 데이터 관리 방식(데이터베이스 시스템 이전)을 살펴보기 위해 **파일 처리 시스템**에 주목해 봅시다.
학적, 성적, 수강 관리 어플리케이션이 각각 존재한다고 했을 때, 파일 처리 시스템에서는 이들의 데이터를 파일의 형태로 따로따로 저장했습니다.
단순히 데이터를 저장하는 수준이었던 이 방식에는 몇 가지 문제점이 존재했는데,
**```데이터 종속의 문제```**(물리적, 논리적 종속), **```데이터 중복의 문제```**(일관성, 보안성, 경제성 저해),
**```무결성 훼손의 문제```**(데이터의 제약조건 불만족, 정확성x), **```동시 접근의 문제```**(일관성 훼손) 들이 그것입니다.

### 데이터베이스의 특징

데이터베이스 시스템의 사용은 **데이터의 사용과 관리 영역을 철저히 분리**하여 파일 처리 시스템의 문제점을 해결하는 데 그 의미가 있습니다.
기본 원리는 데이터베이스 시스템이 중간관리자 역할을 하여 **어플리케이션 혹은 사용자가 직접적으로 데이터에 접근하지 못하도록** 하는 것입니다.
데이터에 접근 가능한 것은 오직 데이터베이스 시스템뿐이며 이 중간관리자를 DBMS(Database Management System)라고 부릅니다.

**데이터베이스 시스템의 구성**
![structure of database system]({{ site.github.url }}{% link assets/post-img/structure_of_db_system.png %})

데이터베이스의 특징은 다음과 같습니다.

**1. 데이터베이스 시스템의 자기 기술성**
- 데이터와 데이터의 정의 및 설명(메타데이터)을 포함
- 값은 그것의 의미가 정의되지 않았기 때문에 데이터라고 할 수 없음
- 이렇게 값에 부여되는 의미나 정의를 메타데이터라고 함
    - ```'12'라는 값은 '오늘', '낮 최고 기온'이라는 설명이 붙을 때 의미를 갖는 데이터가 됩니다.```

**2. 프로그램과 데이터의 격리 및 추상화**
- 사용자에게 데이터에 대한 개념적인 표현을 제공하여 접근성을 향상
- DBMS의 3단계 구조 <small>\> 외부(뷰), 개념, 내부 단계의 스키마 제공</small>
- 각 단계 사이에는 ```개념-내부 사상```, ```외부-개념 사상```이라는 연결점이 존재
- 사용자는 외부 단계를 통해서만 데이터를 볼 수 있음, 꼭 필요한 데이터만 필터되어 뷰로 제공됨
    - ![3 layer of dbms]({{ site.github.url }}{% link assets/post-img/dbms-3-layer.png %})

**3. 다중 뷰 제공**
- 각 사용자가 관심을 갖는 데이터베이스의 일부만을 표현할 수 있는 기능 제공

**4. 데이터 공유와 다수 사용자 트랜잭션 처리**
- 다수의 데이터 조작 요청을 **동시성 제어 기능**을 통해 데이터의 일관성을 보장하면서 동시에 작업을 수행
- Read 후 Write의 과정을 하나의 트랜잭션으로 접근하면, 해당 데이터에 대해 락이 걸림
- 트랜잭션 처리완료 후 다음 접근이 가능함
    - > **트랜잭션**: 하나의 논리적 작업을 처리하기 위한 일련의 데이터베이스 명령의 집합

### 데이터베이스의 구성요소

**데이터베이스 언어**
- DBMS에게 어플리케이션이 수행하는 질의언어(언어 형태의 인터페이스)가 필요함
    - DDL(데이터 정의 언어): 데이터 객체를 생성, 수정, 삭제하기 위한 언어. 데이터 구조화
    - DML(데이터 조작 언어): 구조화된 데이터에 접근 및 조작(검색, 삽입, 삭제, 수정)
- 표준화된 데이터베이스 언어
    - **SQL**(Structured Query Language)
    - 자연어와 유사한 특징이 있음

**데이터베이스 시스템 아키텍쳐**

데이터베이스 시스템이라 함은 단순히 데이터 저장의 측면 뿐만 아니라
클라이언트가 데이터에 어떠한 방식으로 접근 및 처리를 하는지에 대해 전체적으로 설계된 아키텍쳐(구조)를 의미합니다.

- 중앙집중식 방식
    - 단일 서버가 다수의 클라이언트 장치를 대신하여 작동(중앙컴퓨터 + 다수의 터미널)
    - 저렴하고 수월하게 구축 가능하나 중앙 컴퓨터의 과부하로 전체 성능 저하 가능
- 분산 시스템 방식
    - 클라이언트 장치의 성능 향상으로 자체적인 처리 능력 보유(클라이언트가 일정 부분 데이터 처리)
    - **클라이언트-서버(Client-Server) 데이터베이스 시스템**

분산 시스템 방식은 부하를 분산하고 소프트웨어 유지보수 비용 절감 및 이식성 증대의 측면에서 효율적입니다.
또한 분산 시스템은 비즈니스 로직 어플리케이션 서버가 추가적으로 분리되었는지 여부에 따라 2계층 구조와 3계층 구조로 나뉩니다.


<br>
## 2. 데이터베이스 모델링

데이터베이스를 사용하기 위한 계획을 세우는 과정을 모델링이라고 합니다.

### 데이터베이스 모델링의 이해

- 데이터베이스 모델링의 필요
    - 비즈니스적 관점: 어떤 데이터를 저장해야 하는가?
    - 컴퓨터 프로그래머 관점: 어떻게 데이터를 저장해야 하는가?
- 데이터베이스 시스템 구현 과정(데이터의 관점)
    - 사용자 요구사항 분석
    - 개념적 데이터 모델링
    - 논리적 데이터 모델링 > 개념 스키마 생성
    - 물리적 데이터 모델링 > 내부 스키마 생성
    - ![create db system]({{ site.github.url }}{% link assets/post-img/create_db_system.png %})
- 데이터베이스 모델링의 개념
    - 데이터의 의미를 파악하고 데이터와 관여하는 업무 프로세스를 개념적으로 정의하고 분석하는 작업
    - 모델링의 단계
    - ![steps of data modeling]({{ site.github.url }}{% link assets/post-img/steps_of_data_modeling.png %})

**데이터 모델**이란 요구사항에 필요한 데이터를 선별하고 구조화하기 위해 표준적으로 정의된 개념 틀이라고 생각하면 됩니다.
우리가 필요한 데이터는 이렇게 설계된 모델에 맞게 저장 및 사용되죠.

> 데이터 모델: 의미, 데이터 타입, 연산 등을 명시하기 위해 사용할 수 있는 개념들의 집합

**데이터 모델링**이라 함은 실세계의 일부분을 구조화된 데이터 모델의 형태로 나타내는 과정입니다.
데이터 모델링은 아래의 단계에 맞게 진행됩니다.

**1. 개념적 데이터 모델링**
    - 요구사항의 해석 오류를 방지
    - 데이터 구조, 데이터 타입, 속성, 관계, 제약조건 등을 이끌어내는 과정
    
**2. 논리적 데이터 모델링**
    - 특정 DBMS의 구현 모델에 맞춰 데이터를 표현하는 과정
    - 데이터 정의 언어(DDL)로 기술된 개념 스키마 생성
    
**3. 물리적 데이터 모델링**
    - 데이터베이스 파일의 내부 저장구조, 파일 구성, 인덱스, 접근 경로 등을 결정하는 과정

### 사용자 요구사항 분석

- 사용자 요구사항이 왜 필요할까요?
        > 충분한 사전 분석없이 적절한 설계가 불가능하기 때문입니다.
    - 데이터베이스 구조가 복잡해지고 수명 주기가 단축되고 있기 때문에 신속성 및 정확성이 요구되며, 효율적 운용에 초점이 맞춰지고 있습니다.
    - **사용자의 요구를 명세하지 않고 설계 및 개발을 진행하면, 결과물의 완성도가 저하되고 신뢰도가 추락**할 수 있습니다.
    - 개발 후 발생하는 에러 수정에 많은 **추가 비용이 지출**됩니다.
- 사용자 요구사항 분석의 개념
    - 시스템의 대상이 되는 업무를 분석하여, 필요한 데이터를 저장 및 운용할 수 있는 구조를 개발합니다.
    - 이는 **도출, 분석, 기록** 단계로 수행되며 국제 표준화 기준이 있습니다.
        > [IEEE-Std-830](https://standards.ieee.org/standard/830-1998.html)
- 분석 과정
    - 제안요청서를 통한 **요구사항 도출** 단계
        - 구축 대상, 프로젝트 목표, 범위 기준
        - 업무 관계자 인터뷰
        - 외부자료 수집 및 분석
    - 요구사항 명세서를 통한 **요구사항 분석** 단계
        - 이전 단계의 고객 요구사항에 분석가 및 개발자 관점의 명세사항 추가
        - 도출된 요구사항의 명확성, 완전성, 모호성 검증
        - 불완전한 부분이 존재할 경우 도출 단계 재수행
        - 요구사항을 분류하여 통합 또는 분리
    - 요구사항 정의서를 통한 **요구사항 기록** 단계
        - 요구사항 목록 정리 및 관리자의 승인
        - 정리된 요구사항을 형식에 맞춰 문서화
        - 프로젝트 종료 때까지 반영 여부 지속적 관리

### ER 모델

ER 모델은 실세계의 속성들로 이루어진 **개체(Entity)와 개체 간 관계(Relationship)**를 정형화시킨 모델이며,
데이터베이스 시스템 구현 과정 중 **개념적 모델링 단계**에서 ER 표현을 위해 사용됩니다.
이것은 ER 다이어그램(ERD)로 표현됩니다. 그 구성요소는 다음과 같습니다.

- 개체 집합(Entity set)
    - 실세계에서 다른 객체와 구별되는 유무형의 사물을 개체(Entity)라 하며, 여러 속성들로 구성됨
    - 개체 집합이란 같은 속성을 공유하는 개체들의 모임
    - ex. \[학생 개체\] -> (201934-021216, 유관순, 여, 17)
        - | 학생 |
          |:---:|
          | 학생번호 |
          | 학생이름 |
          | 성별 |
          | 나이 |
- 관계 집합
    - 개체 집합 '학생'과 '학과'가 있다고 가정했을 때, 각각은 동질성을 지닌 속성으로 이루어진 개체들로 구성됨
    - 이때 '학생' 개체는 전공을 선택하는 과정에서 '학과' 개체와 '전공' 관계를 맺음
    - 이러한 관계는 개체 간 연관성을 나타내며,
    - 관계 집합이란 개체 집합 간의 연결 관계를 의미
        - ![erd01]({{ site.github.url }}{% link assets/post-img/erd01.png %})
- 속성
    - 속성은 개체를 구체적으로 설명하는 것
    - 속성에 포함될 수 있는 값의 특성에 따라 여러 종류로 구분
    - 속성의 종류
        - **단순 속성**: 더 작은 구성요소로 나눌 수 없는 속성
        - **복합 속성**: 더 작은 구성요소로 나눌 수 있는 속성
        - **단일값 속성**: 한 개체에 단 하나의 값만 가지는 속성
        - **다중값 속성**: 여러 값을 가지는 속성
        - **유도 속성**: 다른 속성의 값으로부터 값이 유추될 수 있는 속성 (ex. 생년월일로 나이 유추 가능)
        - **저장 속성**: 유도 속성을 위해 사용될 수 있도록 개체에 저장되어 있는 속성
    - 학번은 복합 속성이면서 단일 값 속성이며, 저장 속성
    - 나이는 단순 속성이면서 단일 값 속성이며, 유도 속성
    - 요구사항에 따라 단일 값 속성일수도, 다중 값 속성일수도 있음
- 제약조건(Constraints)
    - ER 모델에서 다루는 데이터 모델은 데이터의 조건을 표현하기 위한 도구이기도 함
    - 이러한 데이터 조건은 개체와 관계에 대한 **표현의 정확성**을 위해 필요함
    - 이를 **데이터가 준수해야 하는 제약조건**으로 정의할 수 있음
    - 제약조건의 종류
        - **사상수(mapping cardinality)**: 한 개체 집합이 관계 집합 내에서 다른 개체와 관계를 맺을 수 있는 수량
            - 일대일(1:1) 관계: 개체X 한 개와 개체Y 한 개씩만 관계를 맺음
            - 일대다(1:N) 관계: 개체X 한 개와 개체Y 여러 개가 관계를 맺음
            - 다대다(N:M) 관계: 개체X 여러 개와 개체Y 여러 개가 관계를 맺음
        - **참가 제약조건**
            - 전체적 참가: 한 개체 집합의 모든 개체가 관계 집합에 참여하는 경우로 이중선으로 표현
            - 부분적 참가: 한 개체 집합의 일부 개체가 관계 집합에 참여하는 경우로 단일선으로 표현
            - 예를 들어 교수 개체 집합과 과목 개체 집합이 관계를 맺는다고 가정을 했을 때,
            - 과목 개체 집합은 전체적 참가, 교수 개체 집합은 부분적 참가 제약조건을 지정할 수 있음
        - **키 속성**
            - 특정 개체를 식별하기 위해 유일한 값을 가지는 속성의 집합, 밑줄로 표현
            - 개체를 고유하게 구분하기도 하지만, **관계 집합의 특정 관계를 찾는 역할**도 함
            - 학생 이름은 키 속성이 될 수 없지만(동명이인) 학생 번호는 유일할 수 있음
- 특수 속성과 특수 관계
    - 어떤 학생이 수강 신청을 할때 그 시각을 저장하기 위한 속성은 어느 한쪽 개체에도 없음
    - **관계 집합의 속성**: 이때, 관계 집합의 속성으로써 수강 신청 시각을 표현할 수 있음
        - ![erd02]({{ site.github.url }}{% link assets/post-img/erd02.png %})
    - **재귀적 관계**: 한 개체 집합이 자기 자신과 관계 집합을 형성하는 관계
        - ex. 과목 개체 -> 과목코드와 선수과목코드의 관계
    - **특수 관계**
        - 약한 개체 집합: 개체의 존재 유무가 관계를 맺고 있는 다른 개체에 종속되는 개체 집합
        - 강한 개체 집합: 상대적으로 약한 개체 집합과 연결되는 일반 개체 집합. (관계는 1:N 으로 구성)
        - ex. 학생 개체와 계좌 개체 간의 관계. 학생 개체가 사라지면 계좌 개체도 사라짐
        - ![erd03]({{ site.github.url }}{% link assets/post-img/erd03.png %})

<br>
## 3. 관계형 모델

관계형 모델은 논리적 모델링 단계에서 산출됩니다.
이는 이전 단계인 개념적 모델링의 개체-관계모델(ERD)을 통해 도출됩니다.

개념 단계를 넘어서 DBMS에서 사용하는 데이터 모델에 맞추어 데이터를 표현해야 하는데 이를 논리적 데이터 모델링이라 합니다.
이것의 최종 목적은 데이터 정의 언어로 기술된 개념 스키마를 생성하여 관계형 모델을 만드는 것입니다.

### 관계형 모델의 개념

- 관계형 모델(relational model)
    - 릴레이션(relation)으로 데이터 표현
    - 단순하고 직관적인 구조화 모델
    - 현재 대다수 DBMS의 시초 > RDBMS

> #### 릴레이션의 구성과 특징
> ![relation01]({{ site.github.url }}{% link assets/post-img/relation01.png %})
> - 레코드의 유일성: 중복된 레코드의 존재 불가능
> - 레코드의 무순서성: 레코드 순서는 의미가 없음
> - 컬럼의 무순서성: 컬럼도 순서가 없으며, 이름과 값의 쌍임
> - 컬럼값의 원자성: 모든 값들은 나눌 수 없는 단 하나의 의미

앞서 개체 집합에는 키 속성이 있다고 했는데, 릴레이션에서 이것은 유일성을 가지는 키 컬럼으로 지정할 수 있습니다.
예를 들어 학과 릴레이션에서 학과명 혹은 전화번호가 그것입니다.

유일성을 가진 릴레이션 키 속성은 개체 집합에서의 키 속성과 한 가지 차이점이 있습니다.
그것은 **최소성(Irreducibility)**인데, 레코드를 대표하는 식별키는 군더더기를 제외한 가장 간결한 값이어야 합니다.

> #### 키의 종류 및 속성
> - 키의 속성 >> 유일성(Uniqueness), 최소성(Irreducibility)
> - 키의 종류
>   - 수퍼키(super key): 유일성 만족
>   - 후보키(candidate key): 유일성, 최소성 만족
>   - 기본키(PK: primary key): 레코드의 구분을 위해 **선택된 후보키**
>   - 외래키(FK: foreign key): 참조된 다른 릴레이션의 기본키

유일성을 만족시키기 위해서는 학과명 컬럼 하나만으로도 가능하지만, **학과명+단과대학**의 결합으로도 유일성을 만족시킬 수 있습니다.
따라서 특별한 사유가 있는것이 아니라면 릴레이션의 기본키 속성으로 선택되기 위해서는 최소성까지도 만족하는 학과명만을 사용하게 됩니다.

또는 유일성+최소성을 만족시키는 주소 컬럼, 전화번호 컬럼 등을 기본키로 선택할 수 있습니다.
이렇게 기본키가 될 수 있는(유일성+최소성을 만족하는) 컬럼을 후보키라고 합니다.

외래키는 릴레이션 간의 관계를 표현할 때 유용합니다.
예를 들어 교수의 소속 학과를 저장하기 위해서는 교수 릴레이션에 **소속학과 외래키(FK)**를 지정하게 됩니다.
앞서 1장에서 **파일 처리 시스템은 여러 파일에 걸쳐 동일한 데이터가 존재하는 데이터 중복의 문제**가 있다고 했는데,
외래키를 사용하면 교수가 속한 학과의 정보는 학과 릴레이션에 한 번만 저장되기 때문에 이 문제를 해결할 수 있습니다.

![relation02]({{ site.github.url }}{% link assets/post-img/relation02.png %})

DBMS(매니지먼트 시스템)는 데이터의 무결성을 만족시키기 위해 **관계형 모델에 제약조건**을 가지고 있습니다.
파일 처리 시스템에서는 데이터를 넣는 대로 파일에 저장이 되었으나, DBMS 에서는 관리 시스템이 이를 차단하게 됩니다.

> #### 관계형 모델의 제약조건
> - 영역 제약조건: 컬럼에 정의된 도메인(domain, 영역)에 속한 값으로만 컬럼값이 결정
> - 키 제약조건: 유일성과 최소성을 만족하지 않는 데이터는 키 컬럼에 입력되지 않음
> - 개체 무결성 제약조건: 어떠한 기본키(PK) 값도 널(null)이 될 수 없음
> - 참조 무결성 제약조건: 반드시 존재하는 레코드의 기본키만 참조 가능

여기서 널(null)은 '아직 데이터를 알 수 없다'의 의미입니다. 미지의 값이라는 것이죠. '0'이나 '없음'과는 다른 값입니다.
따라서 기본키에 null 값을 넣을 수 있다면 null 이 있는 레코드 자체를 식별할 수 없게 됩니다. > **개체 무결성 제약조건**

### ERD의 변환

논리적 데이터 모델링은 **DBMS의 구현 모델에 맞춰 데이터를 표현하는 과정**입니다.
개념적 데이터 모델링에서 생성된 ERD를 DBMS에 최적화하여 구현하는 것이죠.
우리가 데이터베이스를 사용할 때 실제 커뮤니케이션하는 층위는 DBMS이기 때문에 이 과정은 필요합니다.

또한 이 과정에서는 데이터 정의 언어(DDL)로 기술합니다.

> #### 관계형 모델로 변환 방법
> 1. 개체 집합: 개체 집합은 릴레이션으로 변환
> 2. 약한 개체 집합: 강한 개체 집합의 키 속성을 약한 개체 집합의 릴레이션에 포함
> 3. 일대일 관계: 두 릴레이션 중에서 한 릴레이션의 PK를 다른 릴레이션의 FK로 참조
> 4. 일대다 혹은 다대일 관계: '일'쪽의 PK를 '다'쪽 릴레이션에서 FK로 참조
> 5. 다대다 관계: 관계 릴레이션을 생성하고, 두 릴레이션의 PK를 각각 참조하는 FK를 복합키 형태의 컬럼으로 구성
> 6. 다중값 속성: 릴레이션의 PK를 참조하는 FK와 다중값 속성으로 별도 릴레이션 구성
> 7. 관계 집합의 속성: FK가 위치한 릴레이션의 컬럼으로 삽입

그럼 ER 다이어그램을 관계형 모델로 변환해 봅시다.
교수 개체 집합과 과목 개체 집합 간의 관계입니다.

(교수) <- <강의> = (과목)

> ![erd_relation01]({{ site.github.url }}{% link assets/post-img/erd_relation01.png %})

이는 일대다 관계입니다. 따라서 '다'쪽의 과목 릴레이션에 '일'쪽 교수 릴레이션의 PK가 교수번호 FK로써 저장되었습니다.

(학생) - <수강> - (과목)

> ![erd_relation02]({{ site.github.url }}{% link assets/post-img/erd_relation02.png %})

이번에는 다대다의 관계입니다. 학생 릴레이션의 PK, 과목 릴레이션의 PK 각각을 PK, FK 쌍으로 갖는 **수강 릴레이션이 생성**되었습니다.
여기에는 수강 신청시각의 관계집합의 속성이 컬럼으로 저장될 수 있습니다.

다음으로는 특수한 상황입니다. **약한 개체 집합을 릴레이션으로 표현하는 경우**인데요,

(학생) <- <<보유>> -> (계좌)

> ![erd_relation03]({{ site.github.url }}{% link assets/post-img/erd_relation03.png %})

기본적으로는 일대일의 관계이지만, 계좌 개체 집합이 약한 개체 집합이므로 강한 개체 집합인 학생 개체 집합의 의존적인 데이터가 사라지면
약한 개체 집합의 계좌 데이터도 함께 사라져야만 합니다.

일대일에서 릴레이션의 FK는 어느 쪽에 추가해도 상관없지만(가급적 개수가 적은 쪽으로, 의미적으로 의존적인 쪽으로),
약한 개체 집합의 경우는 계좌 릴레이션에 학생 릴레이션의 학생번호 PK를 FK로써 저장해야 합니다.
또한 연쇄삭제를 의미하기 위해 **학생번호 FK를 PK의 제약조건까지 만족하는 복합키**로써 지정합니다. >> 계좌번호+학생번호(복합키: PK, FK)

### 데이터 연산

위 과정을 통해 도출된 관계형 모델을 통해 관계 연산을 수행할 수 있습니다.
관계 연산은 **DBMS가 결과적으로 여러 릴레이션 간의 관계를 하나의 릴레이션으로 표현**하여 보여주기 위해 필요합니다.

- **관계 연산의 개념**: 관계형 모델을 기반으로 새로운 릴레이션을 생성하는 표현

관계 연산을 정의하기 위해 **관계 대수(relational algebra)**를 활용합니다.
이때 연산자는 다음과 같습니다.

> ![relational algebra](http://www.mathcs.emory.edu/~cheung/Courses/377/Syllabus/4-RelAlg/FIGS/rel-alg.gif)
> <small style="float: right;">출처: <a href="http://www.mathcs.emory.edu/~cheung/Courses/377/Syllabus/4-RelAlg/intro.html" target="_blank">mathcs</a></small>

각각 순서대로 합집합, 교집합, 차집합, 카티션, 셀렉션, 프로젝션, 조인, 디비전 등등입니다.
관계 대수 연산자의 중첩을 통해 연산 처리 절차 자체를 표현할 수도 있고,
이 결과 생성된 임시 릴레이션은 사용자가 원하는 데이터셋을 가공하여 보여줍니다.

여기서 **집합 연산자(합, 교, 차, 카티션)**의 경우는 각 릴레이션을 하나의 집합으로, 레코드를 집합에 포함된 원소로 가정합니다.

> #### 관계 대수를 활용한 연산 표현
> - 셀렉션
>   - ![algebra_selection]({{ site.github.url }}{% link assets/post-img/algebra_selection.png %})
> - 프로젝션
>   - ![algebra_projection]({{ site.github.url }}{% link assets/post-img/algebra_projection.png %})
> - Q1. 직위가 '부교수'인 교수의 교수이름을 출력하라.
>   - ![algebra_selection_projection]({{ site.github.url }}{% link assets/post-img/algebra_selection_projection.png %})
>   - 셀력션 후 프로젝션을 수행하는 연산 처리 절차를 표현
> - 집합 연산자 사용 조건
>   - 연산을 위해 릴레이션 R과 S의 차수(컬럼의 개수)가 동일
>   - 모든 i에 대해 R의 i번째 컬럼의 도메인과 S의 i번째 컬럼의 도메인이 반드시 동일
> - 카티션 프로덕트 연산
>   - 두 릴레이션에 포함된 레코드 간의 **모든 조합을 생성하는 이항 연산자 'X'**(R X S)
>   - 카티션 프로덕트는 서로 다른 컬럼과 레코드를 가지고 있는 두 릴레이션을 결합하는 역할
> - **조인(JOIN)**
>   - 조건 상관 없이 결합하는 카티션과 다르게 특정 조건을 만족하는 릴레이션 간 레코드를 결합
>   - ![algebra_join01]({{ site.github.url }}{% link assets/post-img/algebra_join01.png %})
>   - 조인의 연산 처리 절차를 살펴보면, 내부적으로 cartesian 이후 selection 이 수행됨을 확인할 수 있습니다.
>   - ![algebra_join02]({{ site.github.url }}{% link assets/post-img/algebra_join02.png %})
>   - 과목과 교수 릴레이션을 카티션한 후, 교수번호가 동일한 레코드 결과만 셀렉션하는 조인 연산입니다.

위와 같이 여러 조건에 따른 관계성을 표현하는 집합 연산 외에 수량적인 연산이 필요할 수 있습니다.
특정 조건을 만족하는 레코드의 개수 구하기처럼 말이죠.
이때는 sum, avg, count 등의 **집계 함수**를 사용합니다.

다음은 과목 릴레이션의 과목명 개수를 추출하는 count 집계함수의 활용예입니다.

- ![algebra_function01]({{ site.github.url }}{% link assets/post-img/algebra_function01.png %})

여기서는 단순히 과목명의 개수를 추출합니다.

그렇다면 소속학과 별 교수가 몇명인지는 어떻게 추출할까요?
학과의 개수를 세서? 교수의 명수를 세서?
한 릴레이션 내에서 특정 조건을 만족하는 개수를 추출할 때는 그룹화(group) 절차를 거칩니다.

- ![algebra_function02]({{ site.github.url }}{% link assets/post-img/algebra_function02.png %})

연산식을 보면, 소속학과에 따라 레코드들을 그룹화하고, 각 그룹의 레코드 개수를 추출함으로써 원하는 결과를 얻었습니다.

<br>
## 4. SQL 1

<br>
## 5. SQL 2

<br>
## 6. SQL 3
