---
title:  "[방통대] 자료구조!"
created:   2021-09-21 19:17:32 +0900
updated:   2021-09-21 19:17:32 +0900
author: namu
categories: knou
permalink: "/knou/:year/:month/:day/:title"
image: https://cdn.pixabay.com/photo/2018/04/07/09/29/small-poly-3298069_960_720.jpg
alt: data structure dog image
image-view: true
image-author: Manuchi
image-source: https://pixabay.com/ko/users/manuchi-1728328/
---


---

### 목차

1. [자료구조란 무엇인가?](#1-자료구조란-무엇인가)
2. [배열](#2-배열)
3. [스택](#3-스택)
4. [큐](#4-큐)
5. [연결 리스트](#5-연결-리스트)
6. [연결 리스트의 응용](#6-연결-리스트의-응용)
7. [](#)
8. [](#)
9. [](#)
10. [](#)
11. [](#)
12. [](#)
13. [](#)
14. [](#)
15. [](#)

### 참조

- 정광식, 방송통신대학교 자료구조 강의, 2021

---

<br>
## 1. 자료구조란 무엇인가?

2학년 기초과목인 자료구조입니다!

### 1.1 자료와 정보 사이의 관계

**```DATA```** 로 표현되는 **자료**를 가공해 **정보(Information)**를 만듭니다.
여기서 가공은 컴퓨터가 수행하며 이 과정을 처리, 즉 프로세스라고 합니다.

<br>

```text
I = P(D)
```

<br>

가공된 정보는 유의미해서 이에 맞는 다음 행위를 결정하는데 사용됩니다.
예를 들어 입출금 내역 정보를 통해 돈통에 잔돈이 얼마나 남아 있는지, 부족하진 않는지 빠르게 판단할 수 있습니다.

컴퓨터과학 초창기에는 처리된 정보에 많은 초점이 맞춰져 있었다면,
현재는 빅데이터의 발전으로 대용량의 **자료Data를 얼마나 효과적으로 다루는지**도 중요하게 되었습니다.

<br>

> **자료의 정의**
>> 현실 세계에서 관찰이나 측정을 통해서 수집된 **값**이나 **사실**

<br>

좋은 자료구조는 정리가 잘 되어 있다??<br>
컴퓨터과학 관점에서는 컴퓨터의 처리 효율성이 최대가 될 수 있도록 목록별, 주제별, 구조적으로 잘 정리된 자료구조를 좋은 자료구조라 합니다.

그리고 정보의 정의는 다음과 같습니다.

<br>

> **정보의 정의**
>> 어떤 상황에 대해서 적절한 의사결정을 할 수 있게 하는 지식으로써
>> 자료의 유효한 해설이나 자료 상호 간의 관계를 표현하는 내용

<br>

---

<br>

### 1.2 추상화의 개념

수도권 지하철 노선도를 생각해 봅시다.

역과 노선이 굉장히 유기적으로 그려져 있지만, 그렇다고 이것이 실제 물리적 노선과 일치하는 것은 아닙니다.
**모든 자료 중 정보전달에 꼭 필요한 부분만 추출되어 사람이 이해하기 쉽게 추상화**되어 있기 때문입니다.

만약 우리가 지하철 경로를 설명한다면 이와 같이 필요한 부분만 뽑아내어 추상화된 개념으로 설명하게 될 것입니다.

<br>

> **추상화**
>> 공통적인 개념을 이용하여 같은 종류의 다양한 객체를 정의하는 것

<br>

"버스 타고 수원까지 가자!" 라는 추상화된 말에는 버스의 종류, 요금, 노선, 그리고 출발지와 목적지의 구체적인 정보가 내포되어 있습니다.

그렇다면 컴퓨터과학에서 자료의 추상화는 어떻게 설명할까요?

<br>

> **자료의 추상화**
>> 다양한 객체를 컴퓨터에서 표현하고 활용하기 위해 필요한 자료의 구조에 대해서 공통의 특징만을 뽑아 정의한 것

<br>

컴퓨터과학에서는 **자료의 추상화를 통해 컴퓨터 내부의 이진수의 표현 방법, 저장 위치 등 구체적인 정보는 굳이 표현하지 않고
단순하게 개발자의 머릿속에 그림을 그리는 것처럼 개념화**합니다.

<br>

---

<br>

### 1.3 자료구조의 개념

자료를 추상화, 구조화하는 것을 자료구조라 합니다.

> **자료구조**
>> 추상화를 통해 알고리즘에서 사용할 자료의 논리적 관계를 구조화한 것

<br>

---

<br>

### 1.4 자료구조와 알고리즘의 관계

자료구조가 컴퓨터가 처리할 자료를 추상화하는 과정이라면, **알고리즘은 컴퓨터가 수행할 명령을 추상화하는 과정**입니다.

입력된 자료를 자료구조를 통해 추상화/구조화하고, 추상화된 알고리즘을 수행해 출력할 결과를 만들어냅니다.
여기서 프로그램이 하는 일은 알고리즘을 구현해 실제 동작하게 하는 것입니다.

<br>

> **알고리즘이란?**
>> - 사람이 컴퓨터에게 일을 시키는 명령어의 연속된 덩어리
>> - 명령어의 유한 집합이 사람의 머릿속에 추상화되어 존재하는 것
>> - 사람이 컴퓨터에게 일을 시키기 위한 명령 / 명령을 전달하기 위한 방법(언어/글)

- 알고리즘의 조건
    - **출력, 유효성, 입력, 명확성, 유한성**

<br>

---

<br>

### 1.5 알고리즘 성능의 분석과 측정

**알고리즘의 성능 분석**은 **실행하는 데 필요한 시간과 공간을 추정**하여 수행합니다.(-> 예측의 영역)

**알고리즘의 성능 측정**은 **컴퓨터가 실제로 프로그램을 실행하는데 걸리는 시간을 측정**합니다.(-> 측정의 영역)

- 실행 시간의 측정
    - 실제 시계로 재기
    - 실제로 실행될 수 있는 프로그램(실행 파일)이 필요
    - 시스템 시계를 이용

<br>
## 2. 배열

배열은 자료의 추상화된 의미와 구체화된 의미가 유사한 자료구조입니다.

자료의 **순서성**이 매우 중요하며, 이 인덱스는 실제 메모리에 물리적으로 저장되는 주소의 순서와 유사합니다.

### 2.1 배열의 정의

배열의 정의는 다음과 같습니다.

<br>

> **배열**
>> **[사전적 의미]** 일정한 차례나 간격에 따라 벌여 놓음<br>
>> **[정의 1]** 차례(순서)와 관련된 기본적인 자료구조<br>
>> **[정의 2]** 인덱스와 원소값(<index, value>)의 쌍으로 구성된 집합<br>

<br>

인덱스 자체가 순서성을 포함하고 있습니다.
따라서 **인덱스로 특정 위치의 값에 접근 가능**합니다.

또한 **한 배열의 모든 원소들은 같은 자료형과 같은 크기의 기억공간**을 갖습니다.

인덱스와 메모리 주소의 순서가 유사하다는 말의 의미는,
**인덱스 숫자(개념적)와 메모리 주소값(주소)은 서로 다르지만 순서적으로 동일**하다는 것입니다.

따라서 개발자가 인덱스로 배열에 접근하면 운영체제가 이에 해당하는 물리 주소로 연결해줍니다.

<br>

---

<br>

### 2.2 배열의 추상 자료형

교수님이 설명하시는 ```추상 자료형```이란 **call by reference** 되는 따로 정의된 객체 혹은 연산을 의미하고,
```자료형```은 int, float 등과 같이 직접 메모리에 할당되는 **원시Primitive 타입(call by value)**을 의미합니다.

<br>

> **추상 자료형**
>> 객체 및 관련된 연산의 정의

> **자료형**
>> 메모리 저장 할당을 위한 선언

<br>

그럼 이제 **배열의 추상 자료형**을 살펴보겠습니다.

앞서 설명했듯, 배열은 추상 자료형이므로 객체 타입입니다.
이러한 배열 객체와 연산 가이드라인을 살펴보면,

- **ADT Array 객체**
    - Index: 순서를 나타내는 우너소의 유한집합
    - Element: 타입이 같은 원소의 집합

따라서, 배열 구현 시 ```A[1]``` 은 배열 A 의 1번 인덱스의 값을 지징하는 것으로 개념화할 수 있습니다.

- **연산**
    - a: 0개 이상의 원소를 갖는 배열
    - item:  배열에 저장되는 원소
    - n: 배열의 최대 크기를 정의하는 정수값
    - ```Array create(n) ::= 배열의 크기가 n인 빈 배열을 생성하고 배열을 반환```
    - ```Element retrieve(a, i) ::= ```
        - ```if (i in Index) then {```
        - ```    배열의 i번째에 해당하는 원소값 'e' 를 반환;```
        - ```} else {```
        - ```    에러 메시지 반환;```
        - ```}```
    - ```Array store(a, i, e) ::= ```
        - ```if (i in Index) then {```
        - ```    배열 a의 i번째 위치에 원소값 'e'를 저장하고 배열 a를 반환;```
        - ```} else {```
        - ```    인덱스 i가 배열 a의 크기를 벗어나면 에러 메시지 반환;```
        - ```}```

<br>

---

<br>

### 2.3 배열의 연산의 구현

위와 같은 배열 객체와 연산의 개념을 c 를 사용하여 다음과 같이 구현할 수 있습니다.

**[연산 void create()]**
```c
void create(int *a, int n) {  // n = 5
    int i;
    for (i = 0; i < n; i++) {
        a[i] = 0;
    }
}
```

- 첫 번째 인자 ```int *a``` 는 생성된 배열 a 의 주소값
- 주어진 숫자 ```int n``` 이 5 라면 총 다섯칸이며, 배열 a 의 인덱스 4 까지 0 ~ 4 의 숫자가 각각 요소로 들어감

배열 a 의 각 요소는 ```a[0], a[1], ..., a[4]``` 와 같은 방식으로 접근할 수 있습니다.

**[연산 int retrieve()]**
```c
#define array_size 5

int retrieve(int *a, int i) {  // i = 2
    if (i >= 0 && i < array_size) {
        return a[i];
    } else {
        printf("Error\n");
        return -1;
    }
}
```

<br>

---

<br>

### 2.4 1차원 배열 및 배열의 확장

<br>

---

<br>

### 2.5 희소행렬의 개념

<br>
## 3. 스택

### 3.1 

---

### 3.2 

---

### 3.3 

---

### 3.4 

---

### 3.5 

<br>
## 4. 큐

### 4.1 

---

### 4.2 

---

### 4.3 

---

### 4.4 

---

### 4.5 

<br>
## 5. 연결 리스트

### 5.1 

---

### 5.2 

---

### 5.3 

---

### 5.4 

---

### 5.5 
