---
title:  "[방통대] 데이터베이스 수업 정리"
created:   2021-03-20 14:42:24 +0900
updated:   2021-04-15 11:58:15 +0900
author: namu
categories: lecture
permalink: "/lecture/:year/:month/:day/:title"
image: https://images.unsplash.com/photo-1569235186275-626cb53b83ce?ixlib=rb-1.2.1&ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&auto=format&fit=crop&w=1952&q=80
alt: database image
image-view: true
image-author: Maksym Kaharlytskyi
image-source: https://unsplash.com/photos/Q9y3LRuuxmg
---


---

### 목차

1. [데이터베이스의 이해](#1-데이터베이스의-이해)
2. [데이터베이스 모델링](#2-데이터베이스-모델링)
3. [관계형 모델](#3-관계형-모델)
4. [SQL 1](#4-sql-1)
5. [SQL 2](#5-sql-2)
6. [SQL 3](#6-sql-3)
7. [정규화](#7-정규화)
8. [연습문제 풀이01](#8-연습문제-풀이01)
9. [데이터 저장과 파일](#9-데이터-저장과-파일)
10. [인덱싱](#10-인덱싱)
11. [해싱과 특수 인덱스](#11-해싱과-특수-인덱스)
12. [](#)
13. [](#)
14. [](#)
15. [](#)

### 참조

- 정재화 (2020). 데이터베이스 시스템. 서울: 한국방송통신대학교출판부.
- 정재화. 데이터베이스 시스템 강의 (2021). 한국방송통신대학교 UKNOU 캠퍼스

---

<br>
## 들어가며

다음은 2021학년도 1학기 데이터베이스 수업에 대한 정리입니다.

<br>
## 1. 데이터베이스의 이해

데이터베이스 시스템이 만들어진 이유는 급격한 사회 트렌드의 변화 속에서 빠르게 증대되는 데이터를 효율적으로 관리할 필요성이 높아졌기 때문입니다.
실제로 데이터 세계의 총량은 2013년 ```4.4 ZB```(제타바이트) 규모였으나 2020년 ```44 ZB``` 규모로 증대될 것이라 예측되었고,
현재는 ```60 ZB``` 분량으로 늘어났다고 합니다.

### 데이터베이스의 역할

데이터베이스 시스템은 이와 같이 많은 데이터를 **저장 및 관리**하고 필요한 데이터를 **신속히 검색**할 수 있도록 보조하는 장치입니다.

**데이터 관리의 역사**
![history of database]({{ site.github.url }}{% link assets/post-img/history_of_db.png %})

전통적 데이터 관리 방식(데이터베이스 시스템 이전)을 살펴보기 위해 **파일 처리 시스템**에 주목해 봅시다.
학적, 성적, 수강 관리 어플리케이션이 각각 존재한다고 했을 때, 파일 처리 시스템에서는 이들의 데이터를 파일의 형태로 따로따로 저장했습니다.
단순히 데이터를 저장하는 수준이었던 이 방식에는 몇 가지 문제점이 존재했는데,
**```데이터 종속의 문제```**(물리적, 논리적 종속), **```데이터 중복의 문제```**(일관성, 보안성, 경제성 저해),
**```무결성 훼손의 문제```**(데이터의 제약조건 불만족, 정확성x), **```동시 접근의 문제```**(일관성 훼손) 들이 그것입니다.

### 데이터베이스의 특징

데이터베이스 시스템의 사용은 **데이터의 사용과 관리 영역을 철저히 분리**하여 파일 처리 시스템의 문제점을 해결하는 데 그 의미가 있습니다.
기본 원리는 데이터베이스 시스템이 중간관리자 역할을 하여 **어플리케이션 혹은 사용자가 직접적으로 데이터에 접근하지 못하도록** 하는 것입니다.
데이터에 접근 가능한 것은 오직 데이터베이스 시스템뿐이며 이 중간관리자를 DBMS(Database Management System)라고 부릅니다.

**데이터베이스 시스템의 구성**
![structure of database system]({{ site.github.url }}{% link assets/post-img/structure_of_db_system.png %})

데이터베이스의 특징은 다음과 같습니다.

**1. 데이터베이스 시스템의 자기 기술성**
- 데이터와 데이터의 정의 및 설명(메타데이터)을 포함
- 값은 그것의 의미가 정의되지 않았기 때문에 데이터라고 할 수 없음
- 이렇게 값에 부여되는 의미나 정의를 메타데이터라고 함
    - ```'12'라는 값은 '오늘', '낮 최고 기온'이라는 설명이 붙을 때 의미를 갖는 데이터가 됩니다.```

**2. 프로그램과 데이터의 격리 및 추상화**
- 사용자에게 데이터에 대한 개념적인 표현을 제공하여 접근성을 향상
- DBMS의 3단계 구조 <small>\> 외부(뷰), 개념, 내부 단계의 스키마 제공</small>
- 각 단계 사이에는 ```개념-내부 사상```, ```외부-개념 사상```이라는 연결점이 존재
- 사용자는 외부 단계를 통해서만 데이터를 볼 수 있음, 꼭 필요한 데이터만 필터되어 뷰로 제공됨
    - ![3 layer of dbms]({{ site.github.url }}{% link assets/post-img/dbms-3-layer.png %})

**3. 다중 뷰 제공**
- 각 사용자가 관심을 갖는 데이터베이스의 일부만을 표현할 수 있는 기능 제공

**4. 데이터 공유와 다수 사용자 트랜잭션 처리**
- 다수의 데이터 조작 요청을 **동시성 제어 기능**을 통해 데이터의 일관성을 보장하면서 동시에 작업을 수행
- Read 후 Write의 과정을 하나의 트랜잭션으로 접근하면, 해당 데이터에 대해 락이 걸림
- 트랜잭션 처리완료 후 다음 접근이 가능함
    - > **트랜잭션**: 하나의 논리적 작업을 처리하기 위한 일련의 데이터베이스 명령의 집합

### 데이터베이스의 구성요소

**데이터베이스 언어**
- DBMS에게 어플리케이션이 수행하는 질의언어(언어 형태의 인터페이스)가 필요함
    - DDL(데이터 정의 언어): 데이터 객체를 생성, 수정, 삭제하기 위한 언어. 데이터 구조화
    - DML(데이터 조작 언어): 구조화된 데이터에 접근 및 조작(검색, 삽입, 삭제, 수정)
- 표준화된 데이터베이스 언어
    - **SQL**(Structured Query Language)
    - 자연어와 유사한 특징이 있음

**데이터베이스 시스템 아키텍쳐**

데이터베이스 시스템이라 함은 단순히 데이터 저장의 측면 뿐만 아니라
클라이언트가 데이터에 어떠한 방식으로 접근 및 처리를 하는지에 대해 전체적으로 설계된 아키텍쳐(구조)를 의미합니다.

- 중앙집중식 방식
    - 단일 서버가 다수의 클라이언트 장치를 대신하여 작동(중앙컴퓨터 + 다수의 터미널)
    - 저렴하고 수월하게 구축 가능하나 중앙 컴퓨터의 과부하로 전체 성능 저하 가능
- 분산 시스템 방식
    - 클라이언트 장치의 성능 향상으로 자체적인 처리 능력 보유(클라이언트가 일정 부분 데이터 처리)
    - **클라이언트-서버(Client-Server) 데이터베이스 시스템**

분산 시스템 방식은 부하를 분산하고 소프트웨어 유지보수 비용 절감 및 이식성 증대의 측면에서 효율적입니다.
또한 분산 시스템은 비즈니스 로직 어플리케이션 서버가 추가적으로 분리되었는지 여부에 따라 2계층 구조와 3계층 구조로 나뉩니다.


<br>
## 2. 데이터베이스 모델링

데이터베이스를 사용하기 위한 계획을 세우는 과정을 모델링이라고 합니다.

### 데이터베이스 모델링의 이해

- 데이터베이스 모델링의 필요
    - 비즈니스적 관점: 어떤 데이터를 저장해야 하는가?
    - 컴퓨터 프로그래머 관점: 어떻게 데이터를 저장해야 하는가?
- 데이터베이스 시스템 구현 과정(데이터의 관점)
    - 사용자 요구사항 분석
    - 개념적 데이터 모델링
    - 논리적 데이터 모델링 > 개념 스키마 생성
    - 물리적 데이터 모델링 > 내부 스키마 생성
    - ![create db system]({{ site.github.url }}{% link assets/post-img/create_db_system.png %})
- 데이터베이스 모델링의 개념
    - 데이터의 의미를 파악하고 데이터와 관여하는 업무 프로세스를 개념적으로 정의하고 분석하는 작업
    - 모델링의 단계
    - ![steps of data modeling]({{ site.github.url }}{% link assets/post-img/steps_of_data_modeling.png %})

**데이터 모델**이란 요구사항에 필요한 데이터를 선별하고 구조화하기 위해 표준적으로 정의된 개념 틀이라고 생각하면 됩니다.
우리가 필요한 데이터는 이렇게 설계된 모델에 맞게 저장 및 사용되죠.

> 데이터 모델: 의미, 데이터 타입, 연산 등을 명시하기 위해 사용할 수 있는 개념들의 집합

**데이터 모델링**이라 함은 실세계의 일부분을 구조화된 데이터 모델의 형태로 나타내는 과정입니다.
데이터 모델링은 아래의 단계에 맞게 진행됩니다.

**1. 개념적 데이터 모델링**
    - 요구사항의 해석 오류를 방지
    - 데이터 구조, 데이터 타입, 속성, 관계, 제약조건 등을 이끌어내는 과정
    
**2. 논리적 데이터 모델링**
    - 특정 DBMS의 구현 모델에 맞춰 데이터를 표현하는 과정
    - 데이터 정의 언어(DDL)로 기술된 개념 스키마 생성
    
**3. 물리적 데이터 모델링**
    - 데이터베이스 파일의 내부 저장구조, 파일 구성, 인덱스, 접근 경로 등을 결정하는 과정

### 사용자 요구사항 분석

- 사용자 요구사항이 왜 필요할까요?
        > 충분한 사전 분석없이 적절한 설계가 불가능하기 때문입니다.
    - 데이터베이스 구조가 복잡해지고 수명 주기가 단축되고 있기 때문에 신속성 및 정확성이 요구되며, 효율적 운용에 초점이 맞춰지고 있습니다.
    - **사용자의 요구를 명세하지 않고 설계 및 개발을 진행하면, 결과물의 완성도가 저하되고 신뢰도가 추락**할 수 있습니다.
    - 개발 후 발생하는 에러 수정에 많은 **추가 비용이 지출**됩니다.
- 사용자 요구사항 분석의 개념
    - 시스템의 대상이 되는 업무를 분석하여, 필요한 데이터를 저장 및 운용할 수 있는 구조를 개발합니다.
    - 이는 **도출, 분석, 기록** 단계로 수행되며 국제 표준화 기준이 있습니다.
        > [IEEE-Std-830](https://standards.ieee.org/standard/830-1998.html)
- 분석 과정
    - 제안요청서를 통한 **요구사항 도출** 단계
        - 구축 대상, 프로젝트 목표, 범위 기준
        - 업무 관계자 인터뷰
        - 외부자료 수집 및 분석
    - 요구사항 명세서를 통한 **요구사항 분석** 단계
        - 이전 단계의 고객 요구사항에 분석가 및 개발자 관점의 명세사항 추가
        - 도출된 요구사항의 명확성, 완전성, 모호성 검증
        - 불완전한 부분이 존재할 경우 도출 단계 재수행
        - 요구사항을 분류하여 통합 또는 분리
    - 요구사항 정의서를 통한 **요구사항 기록** 단계
        - 요구사항 목록 정리 및 관리자의 승인
        - 정리된 요구사항을 형식에 맞춰 문서화
        - 프로젝트 종료 때까지 반영 여부 지속적 관리

### ER 모델

ER 모델은 실세계의 속성들로 이루어진 **개체(Entity)와 개체 간 관계(Relationship)**를 정형화시킨 모델이며,
데이터베이스 시스템 구현 과정 중 **개념적 모델링 단계**에서 ER 표현을 위해 사용됩니다.
이것은 ER 다이어그램(ERD)로 표현됩니다. 그 구성요소는 다음과 같습니다.

- 개체 집합(Entity set)
    - 실세계에서 다른 객체와 구별되는 유무형의 사물을 개체(Entity)라 하며, 여러 속성들로 구성됨
    - 개체 집합이란 같은 속성을 공유하는 개체들의 모임
    - ex. \[학생 개체\] -> (201934-021216, 유관순, 여, 17)
        - | 학생 |
          |:---:|
          | 학생번호 |
          | 학생이름 |
          | 성별 |
          | 나이 |
- 관계 집합
    - 개체 집합 '학생'과 '학과'가 있다고 가정했을 때, 각각은 동질성을 지닌 속성으로 이루어진 개체들로 구성됨
    - 이때 '학생' 개체는 전공을 선택하는 과정에서 '학과' 개체와 '전공' 관계를 맺음
    - 이러한 관계는 개체 간 연관성을 나타내며,
    - 관계 집합이란 개체 집합 간의 연결 관계를 의미
        - ![erd01]({{ site.github.url }}{% link assets/post-img/erd01.png %})
- 속성
    - 속성은 개체를 구체적으로 설명하는 것
    - 속성에 포함될 수 있는 값의 특성에 따라 여러 종류로 구분
    - 속성의 종류
        - **단순 속성**: 더 작은 구성요소로 나눌 수 없는 속성
        - **복합 속성**: 더 작은 구성요소로 나눌 수 있는 속성
        - **단일값 속성**: 한 개체에 단 하나의 값만 가지는 속성
        - **다중값 속성**: 여러 값을 가지는 속성
        - **유도 속성**: 다른 속성의 값으로부터 값이 유추될 수 있는 속성 (ex. 생년월일로 나이 유추 가능)
        - **저장 속성**: 유도 속성을 위해 사용될 수 있도록 개체에 저장되어 있는 속성
    - 학번은 복합 속성이면서 단일 값 속성이며, 저장 속성
    - 나이는 단순 속성이면서 단일 값 속성이며, 유도 속성
    - 요구사항에 따라 단일 값 속성일수도, 다중 값 속성일수도 있음
- 제약조건(Constraints)
    - ER 모델에서 다루는 데이터 모델은 데이터의 조건을 표현하기 위한 도구이기도 함
    - 이러한 데이터 조건은 개체와 관계에 대한 **표현의 정확성**을 위해 필요함
    - 이를 **데이터가 준수해야 하는 제약조건**으로 정의할 수 있음
    - 제약조건의 종류
        - **사상수(mapping cardinality)**: 한 개체 집합이 관계 집합 내에서 다른 개체와 관계를 맺을 수 있는 수량
            - 일대일(1:1) 관계: 개체X 한 개와 개체Y 한 개씩만 관계를 맺음
            - 일대다(1:N) 관계: 개체X 한 개와 개체Y 여러 개가 관계를 맺음
            - 다대다(N:M) 관계: 개체X 여러 개와 개체Y 여러 개가 관계를 맺음
        - **참가 제약조건**
            - 전체적 참가: 한 개체 집합의 모든 개체가 관계 집합에 참여하는 경우로 이중선으로 표현
            - 부분적 참가: 한 개체 집합의 일부 개체가 관계 집합에 참여하는 경우로 단일선으로 표현
            - 예를 들어 교수 개체 집합과 과목 개체 집합이 관계를 맺는다고 가정을 했을 때,
            - 과목 개체 집합은 전체적 참가, 교수 개체 집합은 부분적 참가 제약조건을 지정할 수 있음
        - **키 속성**
            - 특정 개체를 식별하기 위해 유일한 값을 가지는 속성의 집합, 밑줄로 표현
            - 개체를 고유하게 구분하기도 하지만, **관계 집합의 특정 관계를 찾는 역할**도 함
            - 학생 이름은 키 속성이 될 수 없지만(동명이인) 학생 번호는 유일할 수 있음
- 특수 속성과 특수 관계
    - 어떤 학생이 수강 신청을 할때 그 시각을 저장하기 위한 속성은 어느 한쪽 개체에도 없음
    - **관계 집합의 속성**: 이때, 관계 집합의 속성으로써 수강 신청 시각을 표현할 수 있음
        - ![erd02]({{ site.github.url }}{% link assets/post-img/erd02.png %})
    - **재귀적 관계**: 한 개체 집합이 자기 자신과 관계 집합을 형성하는 관계
        - ex. 과목 개체 -> 과목코드와 선수과목코드의 관계
    - **특수 관계**
        - 약한 개체 집합: 개체의 존재 유무가 관계를 맺고 있는 다른 개체에 종속되는 개체 집합
        - 강한 개체 집합: 상대적으로 약한 개체 집합과 연결되는 일반 개체 집합. (관계는 1:N 으로 구성)
        - ex. 학생 개체와 계좌 개체 간의 관계. 학생 개체가 사라지면 계좌 개체도 사라짐
        - ![erd03]({{ site.github.url }}{% link assets/post-img/erd03.png %})

<br>
## 3. 관계형 모델

관계형 모델은 논리적 모델링 단계에서 산출됩니다.
이는 이전 단계인 개념적 모델링의 개체-관계모델(ERD)을 통해 도출됩니다.

개념 단계를 넘어서 DBMS에서 사용하는 데이터 모델에 맞추어 데이터를 표현해야 하는데 이를 논리적 데이터 모델링이라 합니다.
이것의 최종 목적은 데이터 정의 언어로 기술된 개념 스키마를 생성하여 관계형 모델을 만드는 것입니다.

---

### 관계형 모델의 개념

- 관계형 모델(relational model)
    - 릴레이션(relation)으로 데이터 표현
    - 단순하고 직관적인 구조화 모델
    - 현재 대다수 DBMS의 시초 > RDBMS

> #### 릴레이션의 구성과 특징
> ![relation01]({{ site.github.url }}{% link assets/post-img/relation01.png %})
> - 레코드의 유일성: 중복된 레코드의 존재 불가능
> - 레코드의 무순서성: 레코드 순서는 의미가 없음
> - 컬럼의 무순서성: 컬럼도 순서가 없으며, 이름과 값의 쌍임
> - 컬럼값의 원자성: 모든 값들은 나눌 수 없는 단 하나의 의미

앞서 개체 집합에는 키 속성이 있다고 했는데, 릴레이션에서 이것은 유일성을 가지는 키 컬럼으로 지정할 수 있습니다.
예를 들어 학과 릴레이션에서 학과명 혹은 전화번호가 그것입니다.

유일성을 가진 릴레이션 키 속성은 개체 집합에서의 키 속성과 한 가지 차이점이 있습니다.
그것은 **최소성(Irreducibility)**인데, 레코드를 대표하는 식별키는 군더더기를 제외한 가장 간결한 값이어야 합니다.

> #### 키의 종류 및 속성
> - 키의 속성 >> 유일성(Uniqueness), 최소성(Irreducibility)
> - 키의 종류
>   - 수퍼키(super key): 유일성 만족
>   - 후보키(candidate key): 유일성, 최소성 만족
>   - 기본키(PK: primary key): 레코드의 구분을 위해 **선택된 후보키**
>   - 외래키(FK: foreign key): 참조된 다른 릴레이션의 기본키

유일성을 만족시키기 위해서는 학과명 컬럼 하나만으로도 가능하지만, **학과명+단과대학**의 결합으로도 유일성을 만족시킬 수 있습니다.
따라서 특별한 사유가 있는것이 아니라면 릴레이션의 기본키 속성으로 선택되기 위해서는 최소성까지도 만족하는 학과명만을 사용하게 됩니다.

또는 유일성+최소성을 만족시키는 주소 컬럼, 전화번호 컬럼 등을 기본키로 선택할 수 있습니다.
이렇게 기본키가 될 수 있는(유일성+최소성을 만족하는) 컬럼을 후보키라고 합니다.

외래키는 릴레이션 간의 관계를 표현할 때 유용합니다.
예를 들어 교수의 소속 학과를 저장하기 위해서는 교수 릴레이션에 **소속학과 외래키(FK)**를 지정하게 됩니다.
앞서 1장에서 **파일 처리 시스템은 여러 파일에 걸쳐 동일한 데이터가 존재하는 데이터 중복의 문제**가 있다고 했는데,
외래키를 사용하면 교수가 속한 학과의 정보는 학과 릴레이션에 한 번만 저장되기 때문에 이 문제를 해결할 수 있습니다.

![relation02]({{ site.github.url }}{% link assets/post-img/relation02.png %})

DBMS(매니지먼트 시스템)는 데이터의 무결성을 만족시키기 위해 **관계형 모델에 제약조건**을 가지고 있습니다.
파일 처리 시스템에서는 데이터를 넣는 대로 파일에 저장이 되었으나, DBMS 에서는 관리 시스템이 이를 차단하게 됩니다.

> #### 관계형 모델의 제약조건
> - 영역 제약조건: 컬럼에 정의된 도메인(domain, 영역)에 속한 값으로만 컬럼값이 결정
> - 키 제약조건: 유일성과 최소성을 만족하지 않는 데이터는 키 컬럼에 입력되지 않음
> - 개체 무결성 제약조건: 어떠한 기본키(PK) 값도 널(null)이 될 수 없음
> - 참조 무결성 제약조건: 반드시 존재하는 레코드의 기본키만 참조 가능

여기서 널(null)은 '아직 데이터를 알 수 없다'의 의미입니다. 미지의 값이라는 것이죠. '0'이나 '없음'과는 다른 값입니다.
따라서 기본키에 null 값을 넣을 수 있다면 null 이 있는 레코드 자체를 식별할 수 없게 됩니다. > **개체 무결성 제약조건**

---

### ERD의 변환

논리적 데이터 모델링은 **DBMS의 구현 모델에 맞춰 데이터를 표현하는 과정**입니다.
개념적 데이터 모델링에서 생성된 ERD를 DBMS에 최적화하여 구현하는 것이죠.
우리가 데이터베이스를 사용할 때 실제 커뮤니케이션하는 층위는 DBMS이기 때문에 이 과정은 필요합니다.

또한 이 과정에서는 데이터 정의 언어(DDL)로 기술합니다.

> #### 관계형 모델로 변환 방법
> 1. 개체 집합: 개체 집합은 릴레이션으로 변환
> 2. 약한 개체 집합: 강한 개체 집합의 키 속성을 약한 개체 집합의 릴레이션에 포함
> 3. 일대일 관계: 두 릴레이션 중에서 한 릴레이션의 PK를 다른 릴레이션의 FK로 참조
> 4. 일대다 혹은 다대일 관계: '일'쪽의 PK를 '다'쪽 릴레이션에서 FK로 참조
> 5. 다대다 관계: 관계 릴레이션을 생성하고, 두 릴레이션의 PK를 각각 참조하는 FK를 복합키 형태의 컬럼으로 구성
> 6. 다중값 속성: 릴레이션의 PK를 참조하는 FK와 다중값 속성으로 별도 릴레이션 구성
> 7. 관계 집합의 속성: FK가 위치한 릴레이션의 컬럼으로 삽입

그럼 ER 다이어그램을 관계형 모델로 변환해 봅시다.
교수 개체 집합과 과목 개체 집합 간의 관계입니다.

(교수) <- <강의> = (과목)

> ![erd_relation01]({{ site.github.url }}{% link assets/post-img/erd_relation01.png %})

이는 일대다 관계입니다. 따라서 '다'쪽의 과목 릴레이션에 '일'쪽 교수 릴레이션의 PK가 교수번호 FK로써 저장되었습니다.

(학생) - <수강> - (과목)

> ![erd_relation02]({{ site.github.url }}{% link assets/post-img/erd_relation02.png %})

이번에는 다대다의 관계입니다. 학생 릴레이션의 PK, 과목 릴레이션의 PK 각각을 PK, FK 쌍으로 갖는 **수강 릴레이션이 생성**되었습니다.
여기에는 수강 신청시각의 관계집합의 속성이 컬럼으로 저장될 수 있습니다.

다음으로는 특수한 상황입니다. **약한 개체 집합을 릴레이션으로 표현하는 경우**인데요,

(학생) <- <<보유>> -> (계좌)

> ![erd_relation03]({{ site.github.url }}{% link assets/post-img/erd_relation03.png %})

기본적으로는 일대일의 관계이지만, 계좌 개체 집합이 약한 개체 집합이므로 강한 개체 집합인 학생 개체 집합의 의존적인 데이터가 사라지면
약한 개체 집합의 계좌 데이터도 함께 사라져야만 합니다.

일대일에서 릴레이션의 FK는 어느 쪽에 추가해도 상관없지만(가급적 개수가 적은 쪽으로, 의미적으로 의존적인 쪽으로),
약한 개체 집합의 경우는 계좌 릴레이션에 학생 릴레이션의 학생번호 PK를 FK로써 저장해야 합니다.
또한 연쇄삭제를 의미하기 위해 **학생번호 FK를 PK의 제약조건까지 만족하는 복합키**로써 지정합니다. >> 계좌번호+학생번호(복합키: PK, FK)

---

### 데이터 연산

위 과정을 통해 도출된 관계형 모델을 통해 관계 연산을 수행할 수 있습니다.
관계 연산은 **DBMS가 결과적으로 여러 릴레이션 간의 관계를 하나의 릴레이션으로 표현**하여 보여주기 위해 필요합니다.

- **관계 연산의 개념**: 관계형 모델을 기반으로 새로운 릴레이션을 생성하는 표현

관계 연산을 정의하기 위해 **관계 대수(relational algebra)**를 활용합니다.
이때 연산자는 다음과 같습니다.

> ![relational algebra](http://www.mathcs.emory.edu/~cheung/Courses/377/Syllabus/4-RelAlg/FIGS/rel-alg.gif)
> <small style="float: right;">출처: <a href="http://www.mathcs.emory.edu/~cheung/Courses/377/Syllabus/4-RelAlg/intro.html" target="_blank">mathcs</a></small>

각각 순서대로 합집합, 교집합, 차집합, 카티션, 셀렉션, 프로젝션, 조인, 디비전 등등입니다.
관계 대수 연산자의 중첩을 통해 연산 처리 절차 자체를 표현할 수도 있고,
이 결과 생성된 임시 릴레이션은 사용자가 원하는 데이터셋을 가공하여 보여줍니다.

여기서 **집합 연산자(합, 교, 차, 카티션)**의 경우는 각 릴레이션을 하나의 집합으로, 레코드를 집합에 포함된 원소로 가정합니다.

> #### 관계 대수를 활용한 연산 표현
> - 셀렉션
>   - ![algebra_selection]({{ site.github.url }}{% link assets/post-img/algebra_selection.png %})
> - 프로젝션
>   - ![algebra_projection]({{ site.github.url }}{% link assets/post-img/algebra_projection.png %})
> - Q1. 직위가 '부교수'인 교수의 교수이름을 출력하라.
>   - ![algebra_selection_projection]({{ site.github.url }}{% link assets/post-img/algebra_selection_projection.png %})
>   - 셀력션 후 프로젝션을 수행하는 연산 처리 절차를 표현
> - 집합 연산자 사용 조건
>   - 연산을 위해 릴레이션 R과 S의 차수(컬럼의 개수)가 동일
>   - 모든 i에 대해 R의 i번째 컬럼의 도메인과 S의 i번째 컬럼의 도메인이 반드시 동일
> - 카티션 프로덕트 연산
>   - 두 릴레이션에 포함된 레코드 간의 **모든 조합을 생성하는 이항 연산자 'X'**(R X S)
>   - 카티션 프로덕트는 서로 다른 컬럼과 레코드를 가지고 있는 두 릴레이션을 결합하는 역할
> - **조인(JOIN)**
>   - 조건 상관 없이 결합하는 카티션과 다르게 특정 조건을 만족하는 릴레이션 간 레코드를 결합
>   - ![algebra_join01]({{ site.github.url }}{% link assets/post-img/algebra_join01.png %})
>   - 조인의 연산 처리 절차를 살펴보면, 내부적으로 cartesian 이후 selection 이 수행됨을 확인할 수 있습니다.
>   - ![algebra_join02]({{ site.github.url }}{% link assets/post-img/algebra_join02.png %})
>   - 과목과 교수 릴레이션을 카티션한 후, 교수번호가 동일한 레코드 결과만 셀렉션하는 조인 연산입니다.

위와 같이 여러 조건에 따른 관계성을 표현하는 집합 연산 외에 수량적인 연산이 필요할 수 있습니다.
특정 조건을 만족하는 레코드의 개수 구하기처럼 말이죠.
이때는 sum, avg, count 등의 **집계 함수**를 사용합니다.

다음은 과목 릴레이션의 과목명 개수를 추출하는 count 집계함수의 활용예입니다.

- ![algebra_function01]({{ site.github.url }}{% link assets/post-img/algebra_function01.png %})

여기서는 단순히 과목명의 개수를 추출합니다.

그렇다면 소속학과 별 교수가 몇명인지는 어떻게 추출할까요?
학과의 개수를 세서? 교수의 명수를 세서?
한 릴레이션 내에서 특정 조건을 만족하는 개수를 추출할 때는 그룹화(group) 절차를 거칩니다.

- ![algebra_function02]({{ site.github.url }}{% link assets/post-img/algebra_function02.png %})

연산식을 보면, 소속학과에 따라 레코드들을 그룹화하고, 각 그룹의 레코드 개수를 추출함으로써 원하는 결과를 얻었습니다.

<br>
## 4. SQL 1

SQL을 통해 우리는 DBMS에게 데이터베이스를 조작하도록 명령할 수 있습니다.
DBMS를 거치는 이유는 1강에서 살펴 본 파일 처리 시스템의 문제들을 방지하면서 데이터 구조와 데이터를 조작하고,
사용자가 원하는 뷰를 유기적으로 제공하기 위함입니다.

---

### 데이터베이스 언어

> **SQL**의 개요 및 특징
>> 개요: Structured Query Language로써, 관계대수에 기초하여 RDBMS의 데이터 관리를 위해 설계된 언어.
>> 특징: 비절차적(선언형) 언어, 필요한 데이터만 기술.
>>      인간의 언어와 매우 유사하고 간단, 명료.

데이터베이스 언어에는 DDL과 DML이 있습니다.

#### **DDL**(Data Definition Language), 데이터 정의 언어

- 데이터베이스 내 객체 생성 및 삭제, 그 구조를 조작
    - 데이터베이스 객체의 종류에는 데이터 저장을 위한 **스키마, 테이블, 인덱스, 뷰** 등과
    - 데이터 조작을 위한 **트리거, 프로시저, 함수** 등이 있습니다.
- 데이터가 준수해야 하는 제약조건 기술
- **CREATE, ALTER, DROP**

먼저 **데이터베이스를 생성**해 봅시다.
한 조직의 데이터베이스 시스템의 운영에 필요한 모든 객체의 집합을 스키마라고 부르기 때문에
데이터베이스 생성은 곧 **스키마 생성**을 의미합니다.

![create_schema01]({{ site.github.url }}{% link assets/post-img/create_schema01.png %})

일반적으로 **ALTER 스키마는 사용하지 않습니다.**
데이터베이스 자체는 수정이 아닌 생성하거나 삭제하는 대상으로만 취급되기 때문입니다.

데이터베이스 생성 이후에는 **테이블을 생성**합니다.
테이블은 스키마에 속하는 릴레이션입니다.
'교수'릴레이션을 통해 테이블을 생성하는 다음의 예시를 봅시다.

![create_table01]({{ site.github.url }}{% link assets/post-img/create_table01.png %})

위와 같이 테이블은 ```CREATE TABLE [테이블명] ([상세내용])```의 방식으로 생성합니다.
여기서 주목할 부분은 [상세내용] 중 각 컬럼의 **데이터 타입**과 **제약조건**입니다.

- **데이터 타입**
    - 컬럼이 가질 수 있는 값의 범위, 즉 도메인을 결정
    - 프로그래밍 언어에서 변수의 데이터 타입 사용목적과 방법이 매우 유사
    - **[문자]** 문자열
        - CHAR(N): 최대 길이가 N인 **고정길이** 문자
        - VARCHAR(N): 최대 길이가 N인 **가변길이** 문자열
        - TEXT, CLOB: 길이가 최대 2 ~ 4GB인 가변길이 문자열(CHAR, VARCHAR의 일반적인 최대 문자수는 4000자.)
        - ENUM: 유한개의 문자열 집합 중 하나의 값을 선택 >> ex. ENUM('남', '여'), ENUM('A', 'B', 'O', 'AB')
    - **[숫자]** 정수형
        - TINYINT: 1byte 정수, -128 ~ 127 >> 나이, 학년 등 작은 크기
        - SMALLINT: 2byte 정수, -32768 ~ 32767 >> 번호, 인원 등 중간 크기
        - INT: 4byte 정수, 약 -20억 ~ 20억 >> 금액, 전화번호 등의 일반 크기
        - BIGINT: 8byte 정수 >> 계좌의 잔고, 천문학적 크기
    - **[숫자]** 실수형
        - [고정소수형] DECIMAL(m, n): 전체 m자리, 소수점 이하 n자리 소수 >> DECIMAL(5, 2)는 -999.99 ~ 999.99
        - [고정소수형] NUMERIC: equals to DECIMAL
        - [부동소수형] FLOAT: 4byte 소수
        - [부동소수형] FLOAT(P): 소수점 이하 P개 자리의 소수
        - [부동소수형] DOUBLE: 8byte 소수
    - **[날짜/시간]** 날짜형
        - DATE: 'YYYY-MM-DD' 형식
        - YEAR: 'YYYY' 형식
    - **[날짜/시간]** 시간형
        - TIME: 'HH:MI:SS' 형식
    - **[날짜/시간]** 날짜 및 시간형
        - DATETIME: 'YYYY-MM-DD HH:MI:SS' 형식
        - TIMESTAMP: equals to DATETIME

문자 데이터 타입 중 고정길이 **CHAR**와 가변길이 **VARCHAR**의 차이에 주목해 봅시다.
둘다 사이즈 10의 컬럼으로 정의한다고 했을 때, 전자는 언제나 10칸을 차지하는 반면에 후자는 10칸 이하라면 그것에 맞는 크기만 차지합니다.

VARCHAR의 가변길이 특성은 자신 이후에 뒤따르는 다른 컬럼의 저장공간에도 영향을 미쳐
부수적인 작업이 수행되므로 상대적인 성능 저하를 불러올 수 있습니다.
따라서 저장되는 문자열의 길이가 유의미하게 가변적이라면 VARCHAR가 효율적일 수 있고,
반면에 어느 정도 고정된 크기의 입력이 예산된다면 적절한 크기의 CHAR 타입을 사용하는 것을 고려해 보아야 합니다.

다음으로는 **테이블을 수정**해 봅시다.
테이블 수정의 상황은 컬럼 추가, 수정(이름, 데이터 타입, 제약조건), 삭제가 있습니다.
특히 컬럼의 삭제 혹은 데이터 타입 수정시 데이터가 소실되므로 각별히 주의해야 합니다.

![alter_table01]({{ site.github.url }}{% link assets/post-img/alter_table01.png %})

예시로 ```[교수] 테이블에 INT 데이터 타입의 '나이' 컬럼을 추가```는 쿼리는 다음과 같습니다.

```text
ALTER TABLE 교수
    ADD COLUMN 나이 INT
```

기존의 레코드들에 없던 컬럼이 일괄적으로 추가되는 것이기 때문에 각 값으로 ```NULL```이 투입됩니다.

**테이블 삭제** 쿼리는 사용이 간단하지만
모든 데이터가 소실되어 복구가 불가능해 그 결과가 치명적일 수 있으므로 각별히 주의해야 합니다.
교수 테이블 삭제 쿼리는 다음과 같습니다.

```text
DROP TABLE 교수
```

마지막으로, 테이블 관리 시 각 컬럼의 **제약 조건**을 적절히 설정하는 것은 중요합니다.

- **제약 조건**
    - 테이블에 존재하는 데이터의 무결성 관리의 목적
    - DBMS는 테이블 조작 시 제약조건을 만족시키는지 지속적으로 검사
    - **PRIMARY KEY**: 기본키를 지정, UNIQUE + NOT-NULL 특성
    - **FOREIGN KEY**: 외래키를 지정
    - **NOT NULL**: NULL이 될 수 없는 컬럼 지정
    - **UNIQUE**: 동일한 컬럼값을 가질 수 없음
    - **DEFAULT**: 기본 값 지정
    - **AUTO_INCREMENT**: 데이터 삽입 시 자동으로 1씩 증가
    - **CHECK**: 컬럼이 특정 조건 준수 여부 지정

테이블을 생성하는 위 그림을 살펴보면, 모든 컬럼에 ```NOT NULL``` 제약조건을 지정함을 볼 수 있습니다.
또한 '교수번호' 컬럼에 ```PRIMARY KEY``` 제약조건을, '소속학과' 컬럼에 ```FOREIGN KEY``` 제약조건을 지정하였습니다.
```PRIMARY KEY``` 제약조건은 컬럼 선언 뒷부분에 추가할 수도 있지만, 기본키를 지정할 컬럼을 기술할 때 제약조건 부분에 지정할 수도 있습니다.

#### **DML**(Data Manipulation Language), 데이터 조작 언어

- DDL에 의해 정의된 테이블의 데이터를 조작
- [CRUD] 생성, 검색, 수정, 삭제 / INSERT, SELECT, UPDATE, DELETE

---

<br>
## 5. SQL 2

<br>
## 6. SQL 3

<br>
## 7. 정규화

<br>
## 8. 연습문제 풀이01

<br>
## 9. 데이터 저장과 파일

DBMS는 데이터의 물리적 저장방식을 **고도로 추상화하여 제공**하기 때문에 사용자 및 개발자는
인터페이스 혹은 논리적 비절차 언어를 활용하기만 하면 되었습니다.
하지만 **DBA의 관점에서는 데이터가 물리적으로 어떻게 저장되는 것이 효율적인가에 대해서도 고려**해야 합니다.

이번 장에서는 DBMS가 활용하는 컴퓨터 시스템(저장장치, OS)의 물리적 저장장치 계층 구조,
물리적 데이터 파일의 구성 및 저장장치 접근 기법, 관리에 대해 살펴봅니다.

---

#### 9.1 물리적 저장장치

컴퓨터 시스템의 물리적 저장장치는 데이터 접근 속도, 용량을 기준으로 다양한 장치로 구성됩니다.

#### 물리적 저장장치의 구성

![physical disc01](https://user-images.githubusercontent.com/33562226/54992343-6c618d80-5002-11e9-96d1-17b9c7bb25df.png)
<small>이미지 출처: [chogyujin 블로그](https://chogyujin.github.io/2019/03/26/2.8-%EC%A0%80%EC%9E%A5-%EC%9E%A5%EC%B9%98%EC%9D%98-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0/)</small>

각 저장장치의 특성은 다음과 같습니다.

- 휘발성
    - **캐시**: 고비용, 빠른 접근 속도
    - **메인 메모리**: 실제 프로그램과 데이터 적재
- 비휘발성
    - **플래쉬 메모리**: 메인 메모리와 유사하나 비휘발성
    - **자기 디스크**: 데이터베이스 전체를 안정적으로 저장
    - **광학 디스크 드라이브**: CD, DVD, Blue-ray 등
    - **테이프 장치**: 용량이 크고 저렴하나 순차 접근 방식으로 속도가 매우 느림

---

#### 9.2 파일

여러 계층으로 구성된 컴퓨터 저장장치에서 DBMS는 어떻게 데이터를 물리적으로 저장하고 관리할까요?
바로 파일시스템입니다.

물리적 차원에서 DBMS는 OS의 파일시스템에 맞게 파일 단위로 데이터를 관리합니다.

#### 물리적 저장장치

사실 저장장치의 측면에서 파일 자체도 논리적 개념입니다.
파일 내 데이터는 물리적 저장장치에 저장될 때 가장 작은 **블럭**이라는 데이터 묶음 단위로 나뉘어서 저장됩니다.
그리고 이 블럭은 릴레이션의 레코드들로 구성되어 있습니다.

![physical disc02](https://t1.daumcdn.net/cfile/tistory/2721404F56E2CEB41B)
<small>이미지 출처: [firewall 티스토리 블로그](https://firewall.tistory.com/46)</small>

- **파일**: 데이터를 영구적으로 저장하기 위해 사용되는 가장 기초적인 논리적 구조
- **블럭**
    - 파일을 고정적인 길이로 분할하여 생기는 균등한 크기의 데이터 묶음
    - 일반적으로 메모리와 디스크 간 데이터 전송 단위로 결정
- **레코드**
    - 블럭을 구성하는 요소
    - 더 이상 분리될 수 없는 최소 데이터 저장 단위

#### 파일의 구성

그렇다면 하나의 블럭에는 데이터가 어떻게 저장될까요?
방금 레코드라고 이야기했는데, 레코드에는 **고정 길이 레코드**와 **가변 길이 레코드**가 있습니다.

- **고정 길이 레코드**
    - 한 릴레이션의 모든 레코드가 고정적인 바이트 수를 갖음
    - [사번 릴레이션 - 레코드] 사번-CHAR(8), 이름-CHAR(20), 부서명-CHAR(10), 연봉-INT
    - 위 사번 릴레이션의 한 레코드는 **8+20+10+4 = 42byte 의 고정 길이**를 갖음
    - 데이터 접근
        - 각 레코드는 42byte 고정 크기이므로,
        - i번째 레코드 접근(0, 43, 85, ...) >> **(i - 1) * 42 + 1**
    - 잔여 고정 길이 레코드는?
        - 1) 마지막 레코드의 잔여 공간을 비워두는 방법
            - 간편하지만, 블럭 내 잔여공간이 남음
        - 2) 마지막 레코드의 잔여 공간에 다음 블럭의 첫 번째 레코드를 나누어 저장하는 방법
            - 잔여공간이 발생하지 않음
            - 다음 블럭의 첫 번째 레코드 접근 시 두 블럭에 접근해야 함
            - 두 블럭 접근시에는 읽는 속도가 상대적으로 느려짐

고정 길이 레코드 방식은 위와 같은 특징이 있습니다.
주목할 부분은 데이터를 장기적으로 운용하면서 수정, 삭제 작업이 지속적으로 발생시 어떤 현상이 일어나는가입니다.

특히 삭제 시에는 삭제 후 중간 공간이 비워지지만 그것을 모두 알 수는 없기 때문에 장기적으로 저장 공간 낭비가 누적됩니다.

- 레코드 삭제 대처
    - 1) 삭제 시마다 마지막 레코드로 공백 대체 > 레코드의 순서가 달라져 검색 속도에 영향
    - 2) 삭제 레코드 이후의 레코드를 이동 > 순서성에 영향은 없지만 데이터 이동으로 인한 비용이 많음(이후 레코드 많을수록)
    - 3) 가용 리스트 관리
        - 파일 헤더에 공백 레코드 포인터(연결 리스트 방식)를 두어 빈 공간을 표시
        - 삽입시 빈 공간에 데이터를 넣고 포인터 변경

이제 가변 길이 레코드를 살펴봅시다.
가변적인 여러 레코드를 한 블럭에 저장하기 위하여 현존하는 가장 효율적인 방법은 **슬롯 페이지 구조**입니다.

- **가변 길이 레코드**
    - 한 블럭에 서로 다른 길이의 레코드 저장(가변적, 여러 릴레이션 등)
    - 상황
        - 한 블럭 내에 저장되는 레코드 유형이 둘 이상
        - 길이가 고정되지 않은 컬럼의 개수가 하나 이상(VARCHAR 등)
        - 레코드가 멀티셋을 허용한 컬럼을 가질 때
    > 멀티셋
    >> 레코드의 컬럼값이 여러 개인 컬럼
    - [사번 릴레이션 - 레코드] 사번-CHAR(8), 이름-VARCHAR(20), 부서명-CHAR(10), 연봉-INT
    - 레코드의 맨 앞 4byte에 가변 길이 컬럼의 정보 표시
    - 가변 길이 컬럼까지 가서는 앞에 null 값을 삽입
    ![가변길이레코드01](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F994336405AFD9A880758BA)
    <small>이미지 출처: [jundol 블로그](https://jundol.me/124)</small>

가변 길이 레코드를 효율적으로 관리하기 위해 슬롯 페이지 구조가 사용됩니다.

- **슬롯 페이지 구조**
    - 기본적으로 가변 길이 레코드를 관리하려면 각 레코드의 시작과 끝 정보를 알고 있어야 함
    - 블럭 헤더에 가변 레코드들의 정보를 기술 >> 레코드 개수, 가용공간의 끝 위치, 레코드 요약 정보, 링크 등등
    ![가변길이레코드02](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F9950C93B5AFD9BC507861E)
    <small>이미지 출처: [jundol 블로그](https://jundol.me/124)</small>
    - 가용 공간의 끝에서부터 채워나가면서 잔여 가용 공간 정보를 확인

가변 길이 레코드의 슬롯 페이지 구조에서 레코드 삭제에 대한 대응은 **삭제되어 빈 공간 이후의 레코드들을 이동시키는 방식**으로 이루어집니다.
이러한 방식은 고정 길이 레코드에서는 이후 모든 레코드와 블럭에 대한 이동을 의미하기 때문에 너무 많은 비용이 소요되지만,
가변 길이 레코드에서는 **해당 블럭 내의 레코드들만 이동**시키기 때문에 그렇게 많은 비용이 들지 않습니다.
레코드 이동 이후 정보는 블럭 헤더에 반영됩니다.

#### 파일 구조화

이렇게 구성된 블럭들이 모여 파일을 구성합니다.

그런데 가변 길이 레코드에서 보았듯이, 하나의 블럭에서는 여러 릴리에션의 다양한 길이의 레코드가 저장될 수 있고,
반대로 하나의 릴레이션의 레코드들은 빈 공간을 찾아 여러 블럭에 걸쳐서 저장될 수 있습니다.

**파일 구조화**는 파일 수준에서 릴레이션의 레코드를 관리(순서 등)하는 기법입니다.

- 1) **힙(Heap) 파일 구조**: 저장 순서 고려 없이 파일 내 임의의 위치에 배치
    - 저장 시 가장 빠르고 간편하지만 데이터 활용 시 가장 비효율적
    - 임의의 블럭에 레코드를 저장했기 때문에 해당 값을 찾기 위해 모든 블럭을 메모리에 적재해 탐색해야 함
- 2) **순차 파일 구조**: 레코드들이 탐색키 기준으로 정렬되어 저장(정렬키로써의 특정 컬럼)
    - 예를 들어 사번 컬럼 순으로 정렬되어 저장
    - 힙 파일 구조보다 저장 속도는 느리지만, 탐색 시 훨씬 빠름(이진 탐색 가능)
- 3) **해시 파일 구조**: 사전에 정의된 해시 함수를 사용하여 저장될 블럭의 주소를 계산
    - 해시 함수의 성능에 따라 저장 및 탐색의 효율성이 결정됨

시스템에 최적화된 해시 함수를 적용할 수 있다면 해시 파일 구조가 가장 효율적이겠으나,
일반적으로는 파일 구조화 시 탐색키를 활용하는 순차 파일 구조를 차용합니다.

- **순차 파일 구조**의 특징
    - 레코드가 검색키 순서대로 정렬(연결 리스트)
    - 레코드가 파일에 삽입되는 시점에서 키 값이 부여됨
    - 장점
        - 검색키 정렬 연산 불필요(이미 정렬되어 저장), 키 값들의 순서로 레코드 판독 연산에 효율적
        - 현재 레코드에서 정렬된 키 순서로 다음 레코드를 찾을 때 부가적인 블럭 접근이 불필요 > 같은 블럭 내에 있다는 보장이 있음
        - 이진 탐색으로 빠른 레코드 탐색 가능
    - 단점
        - 레코드의 삽입, 삭제에 많은 비용 소요

신규 삽입 시 순차 파일 구조의 단점을 개선하기 위해 **오버플로우 블럭**이 활용됩니다.

- **오버플로우 블럭**
    - 레코드 정렬의 순서성을 유지하며 삽입 시 이후 레코드들의 이동을 방지하기 위해 사용
    - 새로운 오버플로우 블럭을 생성해 Linked List 방식으로 새 레코드 저장 및 연결
    ![오버플로우 블럭01]({{ site.github.url }}{% link assets/post-img/overflow_block01.png %})
    <small>이미지 출처: 9강 참조</small>

---

#### 9.3 저장장치 관리

지금까지 DBMS가 물리적 저장장치에 데이터를 저장하고 관리하기 위해 사용하는 파일 구조에 대해 알아봤습니다.

앞서 설명했듯 파일 자체는 저장장치의 관점에서 봤을 때 논리적 저장 객체입니다.
실체 물리적 관점에서는 여러 개의 블럭으로 저장되며, 블럭은 고정적 혹은 가변적 형태의 레코드로 구성되어 있습니다.

이러한 저장장치에 저장된 데이터에는 어떤 식으로 접근하게 될까요?
가장 주목해야 할 점은 효율성과 속도입니다.

#### 저장장치 접근

우선 최소 단위인 블럭을 살펴봅시다.

- 블럭
    - 메모리와 디스크 간 데이터 전송 단위
    - 일반적으로 2KB ~ 32KB 사용(보통 4KB)
    - 블럭 전송을 최소화 할수록 입출력 소요 시간이 단축
    - but, 메모리의 적재 공간은 한정적임을 고려

프로그램에서 사용중인 메모리보다는 디스크의 읽기 속도가 더 느리기 때문에
효율성의 측면에서는 디스크 읽기 횟수가 적을 수록, 메모리에 적재한 블럭의 활용 빈도가 높을수록 효율적입니다.

하지만 메모리의 가용량은 한정적인 경우가 많으므로 한 번에 불필요하게 많은 데이터(블럭)을 읽어들이면 비효율적일 수 있습니다.
따라서 적절한 크기의 블럭을 한 번에 읽어들여 여러 번 재사용 할수록 좋습니다.

또한 적재된 블럭 중 사용되지 않는 블럭은 할당을 해제하고 새 블럭을 읽어들일 수도 있습니다.
이러한 작업을 위해 DBMS는 **버퍼 관리자**를 두어 메모리 내부 버퍼 공간에 블럭을 적재 혹은 할당 해제하는 등의 관리를 수행합니다.

#### 버퍼 관리자

먼저 DBMS상의 소프트웨어는 필요한 블럭이 있을 때 버퍼 관리자에게 해당 블럭을 요청합니다.

- 1) 버퍼 관리자는 해당 블럭이 버퍼(메모리)에 있다면 블럭이 위치한 주소를 프로그램에게 전달합니다.
- 2) 요청한 블럭이 없다면 버퍼 내 새로운 공간을 할당하고 디스크로부터 해당 블럭을 적재합니다.
- 3) 더 이상 적재할 공간이 없다면 버퍼 내 기존 블럭을 해제하고 새 블럭을 적재합니다.

#### 버퍼 교체 전략

교체 전략의 핵심은 위 세 번째 경우에서 할당을 해제할 기존 블럭을 선정하는 것입니다.
가장 안 쓰일것 같은 블럭을 잘 선택하는게 관건이겠죠.

- **버퍼 교체 전략**
    - 미래에 가장 적게 사용될 블럭을 선택하는 것이 이상적
    - 기법
        - LRU(Least Recently Used): 최근에 가장 적게 참조된 블럭을 교체
            - 버퍼 내 블럭들의 마지막 참조 시점을 기록
        - MFU(Most Frequently Used): 특정 기간 동안 가장 여러번 사용된 블럭을 선택하여 교체
            - 블럭이 몇 번 참조되었는지를 기록
            - 가장 빈번한게 사용된 블럭은 미래에 재사용 가능성이 적을 것이라는 논리

버퍼 교체 전략 중 가장 좋은 것은 없으므로 상황에 맞게 선정해야 합니다.
경우에 따라 LFU(Least ~) 방식을 차용할 수도 있는 것입니다.

#### 추가적인 관리 기법

버퍼 관리자에 의해 블럭이 내보내지는 것을 방지하기 위해 고정해 두는 **고정 블럭**과
내보내질것 같지는 않지만 강제로 내보내도록 하는 **블럭 강제 출력**이 있습니다.

- 고정 블럭
    - 프로그램 진행 중이어서 완성되지 않은 데이터가 디스크에 기록되는 것을 방지
    - 혹은 예기치 못하게 중단되어 복구중인 작업의 블럭 결과물 기록 방지

- 블럭 강제 출력
    - 메모리의 휘발성의 특성으로 인해 급작스러운 상황을 대비해 데이터를 디스크에 저장하기 위해 메모리 버퍼 여유가 있더라도 강제 출력
    - 시스템 로그, 계좌의 거래정보 등

<br>
## 10. 인덱싱

<br>
## 11. 해싱과 특수 인덱스
