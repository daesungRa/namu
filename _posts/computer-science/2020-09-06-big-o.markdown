---
title:  "시간/공간 복잡도와 Big-O 표기법"
created:   2020-09-06 22:15:25 +0900
updated:   2020-09-06 22:15:25 +0900
author: namu
categories: computer-science
permalink: "/computer-science/:year/:month/:day/:title"
image: https://bitxorbyteshome.files.wordpress.com/2019/11/blog-cover.png
image-view: true
image-author: bitxorbytes.home.blog/
image-source: https://bitxorbytes.home.blog/2019/11/25/space-and-time-complexity/
---


---

[목차]

1. [들어가며](#들어가며)
2. [시간 복잡도](#시간-복잡도)
3. [공간 복잡도](#공간-복잡도)
4. [Big-O 표기법](#big-o-표기법)

[참조]

1. [이상진, "자료구조 입문", 프리렉(2016)](http://www.yes24.com/Product/Goods/28194882)

---

<br>
## 들어가며

우리에게 알고리즘이 주어졌다고 했을 때 그것의 구현방식이나 사용하는 프로그래밍 언어의 문법에 따라 성능 차이가 있을 수 있다.
이전보다 더 나아보이는 방식으로 코드를 개선했는데, 얼마만큼의 성능이 좋아졌을까?
우리는 이 글에서 살펴볼 방법으로 **알고리즘의 성능을 분석**할 수 있다.

<br>
## 시간 복잡도

1 ~ 100 의 합을 구하는 문제가 주어졌다고 하자.<br>
처음에는 100번의 반복연산을 통해 값을 구하는 알고리즘을 구현했다.
하지만 'N * (N + 1) / 2' 의 공식을 알게 된 이후 더 나은 방식으로 코드를 개선했다.
3번의 연산만 하면 동일한 결과가 나오기 때문에 효율성이 획기적으로 증대되었다고 생각된다.

하지만 오늘날의 컴퓨터 성능 면에서 3번의 연산이나 100번의 연산이나 실제 실행시간 면에서 사실상 큰 차이가 없다.
한 번의 연산이 수행되는 속도 자체는 하드웨어적인 성능에 따라 서로 다를 수 있기 때문에
우리는 그러한 연산이 몇번 수행되는지를 측정하여 성능을 비교한다.
만약 동일한 하드웨어 성능의 두 컴퓨터로 두 알고리즘의 성능을 비교한다고 하면,
연산이 몇번 수행되는지에 따라 총 시간이 결정되기 때문이다.

그러므로 **시간 복잡도**에서 시간은 **입력 값 n에 따라 수행되는 연산의 횟수**를 의미한다.

확실히 100번보다는 3번의 연산으로 동일한 결과를 출력하는 알고리즘이 시간 복잡도 면에서 더 효율적이라고 볼 수 있다.

> 시간 복잡도 : 입력 값 n에 따라 수행되는 연산의 횟수

<br>
## 공간 복잡도

공간 복잡도는 보다 물리적인 측면에서 계산된다.<br>
시간 복잡도가 알고리즘 수행에 시간이 얼마만큼 걸리는지를 나타낸 것이라면,
공간 복잡도는 **알고리즘 수행에 얼마만큼의 저장 공간(메모리, 디스크)이 필요한지**를 나타낸 것이다.

예를 들어 알고리즘 A 는 수행에 1MB 메모리가 필요하고 알고리즘 B 는 1KB 메모리가 필요하다면,
B 는 A 에 비해 1,024배 효율적인 알고리즘이다.

그러나 대부분의 프로그램 환경에서 공간에 대한 비용보다 시간에 대한 비용이 더 많이 들고, 그 증가율도 크기 때문에
일반적으로 알고리즘 성능 분석이라 함은 시간 복잡도를 의미한다.

<br>
## Big-O 표기법
